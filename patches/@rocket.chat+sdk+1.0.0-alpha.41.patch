diff --git a/node_modules/@rocket.chat/sdk/.DS_Store b/node_modules/@rocket.chat/sdk/.DS_Store
new file mode 100644
index 0000000..5008ddf
Binary files /dev/null and b/node_modules/@rocket.chat/sdk/.DS_Store differ
diff --git a/node_modules/@rocket.chat/sdk/clients/Bot.d.ts b/node_modules/@rocket.chat/sdk/clients/Bot.d.ts
deleted file mode 100644
index b56675d..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Bot.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export * from '../lib/clients/Bot';
diff --git a/node_modules/@rocket.chat/sdk/clients/Bot.js b/node_modules/@rocket.chat/sdk/clients/Bot.js
deleted file mode 100644
index d374bed..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Bot.js
+++ /dev/null
@@ -1,7 +0,0 @@
-"use strict";
-function __export(m) {
-    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
-}
-Object.defineProperty(exports, "__esModule", { value: true });
-__export(require("../lib/clients/Bot"));
-//# sourceMappingURL=Bot.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Bot.js.map b/node_modules/@rocket.chat/sdk/clients/Bot.js.map
deleted file mode 100644
index 1e36def..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Bot.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Bot.js","sourceRoot":"","sources":["../../src/clients/Bot.ts"],"names":[],"mappings":";;;;;AAAA,wCAAkC","sourcesContent":["export * from '../lib/clients/Bot'\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Bot.ts b/node_modules/@rocket.chat/sdk/clients/Bot.ts
new file mode 100644
index 0000000..b638412
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/clients/Bot.ts
@@ -0,0 +1 @@
+export * from '../lib/clients/Bot'
diff --git a/node_modules/@rocket.chat/sdk/clients/Livechat.d.ts b/node_modules/@rocket.chat/sdk/clients/Livechat.d.ts
deleted file mode 100644
index 4b905d2..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Livechat.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export * from '../lib/clients/Livechat';
diff --git a/node_modules/@rocket.chat/sdk/clients/Livechat.js b/node_modules/@rocket.chat/sdk/clients/Livechat.js
deleted file mode 100644
index 99e0aa7..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Livechat.js
+++ /dev/null
@@ -1,7 +0,0 @@
-"use strict";
-function __export(m) {
-    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
-}
-Object.defineProperty(exports, "__esModule", { value: true });
-__export(require("../lib/clients/Livechat"));
-//# sourceMappingURL=Livechat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Livechat.js.map b/node_modules/@rocket.chat/sdk/clients/Livechat.js.map
deleted file mode 100644
index 7890219..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Livechat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Livechat.js","sourceRoot":"","sources":["../../src/clients/Livechat.ts"],"names":[],"mappings":";;;;;AAAA,6CAAuC","sourcesContent":["export * from '../lib/clients/Livechat'\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Livechat.ts b/node_modules/@rocket.chat/sdk/clients/Livechat.ts
new file mode 100644
index 0000000..3b8d643
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/clients/Livechat.ts
@@ -0,0 +1 @@
+export * from '../lib/clients/Livechat'
diff --git a/node_modules/@rocket.chat/sdk/clients/Rocketchat.d.ts b/node_modules/@rocket.chat/sdk/clients/Rocketchat.d.ts
deleted file mode 100644
index c6d0e3f..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Rocketchat.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export * from '../lib/clients/Rocketchat';
diff --git a/node_modules/@rocket.chat/sdk/clients/Rocketchat.js b/node_modules/@rocket.chat/sdk/clients/Rocketchat.js
deleted file mode 100644
index f6ebab6..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Rocketchat.js
+++ /dev/null
@@ -1,7 +0,0 @@
-"use strict";
-function __export(m) {
-    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
-}
-Object.defineProperty(exports, "__esModule", { value: true });
-__export(require("../lib/clients/Rocketchat"));
-//# sourceMappingURL=Rocketchat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Rocketchat.js.map b/node_modules/@rocket.chat/sdk/clients/Rocketchat.js.map
deleted file mode 100644
index 9a71838..0000000
--- a/node_modules/@rocket.chat/sdk/clients/Rocketchat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Rocketchat.js","sourceRoot":"","sources":["../../src/clients/Rocketchat.ts"],"names":[],"mappings":";;;;;AAAA,+CAAyC","sourcesContent":["export * from '../lib/clients/Rocketchat'\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/clients/Rocketchat.ts b/node_modules/@rocket.chat/sdk/clients/Rocketchat.ts
new file mode 100644
index 0000000..b4b14b7
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/clients/Rocketchat.ts
@@ -0,0 +1 @@
+export * from '../lib/clients/Rocketchat'
diff --git a/node_modules/@rocket.chat/sdk/index.d.ts b/node_modules/@rocket.chat/sdk/index.d.ts
deleted file mode 100644
index bb07649..0000000
--- a/node_modules/@rocket.chat/sdk/index.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-import * as settings from './lib/settings';
-import Livechat from './lib/clients/Livechat';
-import Bot from './lib/clients/Bot';
-import Rocketchat from './lib/clients/Rocketchat';
-export { settings, Livechat, Bot, Rocketchat };
diff --git a/node_modules/@rocket.chat/sdk/index.js b/node_modules/@rocket.chat/sdk/index.js
deleted file mode 100644
index 05f967f..0000000
--- a/node_modules/@rocket.chat/sdk/index.js
+++ /dev/null
@@ -1,21 +0,0 @@
-"use strict";
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var settings = __importStar(require("./lib/settings"));
-exports.settings = settings;
-var Livechat_1 = __importDefault(require("./lib/clients/Livechat"));
-exports.Livechat = Livechat_1.default;
-var Bot_1 = __importDefault(require("./lib/clients/Bot"));
-exports.Bot = Bot_1.default;
-var Rocketchat_1 = __importDefault(require("./lib/clients/Rocketchat"));
-exports.Rocketchat = Rocketchat_1.default;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/index.js.map b/node_modules/@rocket.chat/sdk/index.js.map
deleted file mode 100644
index 198b54f..0000000
--- a/node_modules/@rocket.chat/sdk/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,uDAA0C;AAKxC,4BAAQ;AAJV,oEAA6C;AAK3C,mBALK,kBAAQ,CAKL;AAJV,0DAAmC;AAKjC,cALK,aAAG,CAKL;AAJL,wEAAiD;AAK/C,qBALK,oBAAU,CAKL","sourcesContent":["import * as settings from './lib/settings'\nimport Livechat from './lib/clients/Livechat'\nimport Bot from './lib/clients/Bot'\nimport Rocketchat from './lib/clients/Rocketchat'\nexport {\n  settings,\n  Livechat,\n  Bot,\n  Rocketchat\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/index.spec.ts b/node_modules/@rocket.chat/sdk/index.spec.ts
new file mode 100644
index 0000000..fb4b16e
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/index.spec.ts
@@ -0,0 +1,13 @@
+import { expect } from 'chai'
+import * as rocketchat from '@rocket.chat/sdk'
+
+describe('index:', () => {
+  it('exports all lib members', () => {
+    expect(Object.keys(rocketchat)).to.eql([
+      'driver',
+      'methodCache',
+      'api',
+      'settings'
+    ])
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/index.ts b/node_modules/@rocket.chat/sdk/index.ts
new file mode 100644
index 0000000..877141e
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/index.ts
@@ -0,0 +1,10 @@
+import * as settings from './lib/settings'
+import Livechat from './lib/clients/Livechat'
+import Bot from './lib/clients/Bot'
+import Rocketchat from './lib/clients/Rocketchat'
+export {
+  settings,
+  Livechat,
+  Bot,
+  Rocketchat
+}
diff --git a/node_modules/@rocket.chat/sdk/interfaces/index.js b/node_modules/@rocket.chat/sdk/interfaces/index.js
deleted file mode 100644
index 1c7ca9a..0000000
--- a/node_modules/@rocket.chat/sdk/interfaces/index.js
+++ /dev/null
@@ -1,28 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-/** Password login credential type guard */
-function isLoginPass(params) {
-    return (params.user &&
-        params.password &&
-        params.user.username !== undefined &&
-        params.password.digest !== undefined);
-}
-exports.isLoginPass = isLoginPass;
-/** Password login credential type guard */
-function isLoginOAuth(params) {
-    return (params.oath &&
-        params.credentialToken !== undefined &&
-        params.credentialSecret !== undefined);
-}
-exports.isLoginOAuth = isLoginOAuth;
-/** Password login credential type guard */
-function isLoginAuthenticated(params) {
-    return (params.resume !== undefined);
-}
-exports.isLoginAuthenticated = isLoginAuthenticated;
-/** Password login credential type guard */
-function isLoginResult(params) {
-    return (params.token !== undefined);
-}
-exports.isLoginResult = isLoginResult;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/interfaces/index.js.map b/node_modules/@rocket.chat/sdk/interfaces/index.js.map
deleted file mode 100644
index a9b8a08..0000000
--- a/node_modules/@rocket.chat/sdk/interfaces/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/interfaces/index.ts"],"names":[],"mappings":";;AAkFA,2CAA2C;AAC3C,SAAgB,WAAW,CAAE,MAAW;IACtC,OAAO,CACL,MAAM,CAAC,IAAI;QACX,MAAM,CAAC,QAAQ;QACf,MAAM,CAAC,IAAI,CAAC,QAAQ,KAAK,SAAS;QAClC,MAAM,CAAC,QAAQ,CAAC,MAAM,KAAK,SAAS,CACrC,CAAA;AACH,CAAC;AAPD,kCAOC;AAOD,2CAA2C;AAC3C,SAAgB,YAAY,CAAE,MAAW;IACvC,OAAO,CACL,MAAM,CAAC,IAAI;QACX,MAAM,CAAC,eAAe,KAAK,SAAS;QACpC,MAAM,CAAC,gBAAgB,KAAK,SAAS,CACtC,CAAA;AACH,CAAC;AAND,oCAMC;AAOD,2CAA2C;AAC3C,SAAgB,oBAAoB,CAAE,MAAW;IAC/C,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,SAAS,CAAC,CAAA;AACtC,CAAC;AAFD,oDAEC;AA6BD,2CAA2C;AAC3C,SAAgB,aAAa,CAAE,MAAW;IACxC,OAAO,CAAC,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,CAAA;AACrC,CAAC;AAFD,sCAEC","sourcesContent":["/** Loggers need to provide the same set of methods */\nexport interface ILogger {\n  debug: (...args: any[]) => void\n  info: (...args: any[]) => void\n  warning: (...args: any[]) => void\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n}\n\n/**\n * Connection options type\n * @param host        Host URL:PORT, converted to websocket protocol\n * @param useSsl      Use SSL (https/wss) to connect\n * @param timeout     How long to wait (ms) before abandoning connection\n * @param reopen      ms interval before attempting reopens on disconnect\n * @param ping        ms interval between each ping\n * @param close       ms interval to wait for socket close to succeed\n * @param integration Name added to message `bot` attribute to identify SDK use\n */\nexport interface ISocketOptions {\n  host?: string\n  useSsl?: boolean\n  timeout?: number\n  reopen?: number\n  ping?: number\n  close?: number\n  integration?: string\n}\n\n/**\n * DDP Message Handler defines attributes to match on incoming messages and\n * fire a callback. There may be multiple handlers for any given message.\n * @param callback    Function to call when matching message received\n * @param persist     Optionally (true) to continue using handler after matching\n * @param msg         The `data.msg` value to match in message\n * @param id          The `data.id` value to match in message\n * @param collection  The `data.collection` value to match in message\n */\nexport interface ISocketMessageHandler {\n  callback: ISocketMessageCallback\n  persist?: boolean\n  msg?: string\n  id?: string\n  collection?: string\n}\n\n/** Function interface for DDP message handler callback */\nexport interface ISocketMessageCallback {\n  (data: any): void\n}\n\n/**\n * Message respond options\n * @param rooms       Respond to only selected room/s (names or IDs)\n * @param allPublic   Respond on all public channels (ignores rooms if true)\n * @param dm          Respond to messages in DM / private chats\n * @param livechat    Respond to messages in livechat\n * @param edited      Respond to edited messages\n */\nexport interface IRespondOptions {\n  rooms?: string[]\n  allPublic?: boolean\n  dm?: boolean\n  livechat?: boolean\n  edited?: boolean\n}\n\n/** User credentials generic interface */\nexport interface ICredentials {\n  password: string\n  username: string\n  email?: string\n  ldap?: boolean\n  ldapOptions?: object\n}\n\n/** User credentials for password login method */\nexport interface ICredentialsPass {\n  user: { username: string }\n  password: { digest: string, algorithm: string }\n}\n\n/** Password login credential type guard */\nexport function isLoginPass (params: any): params is ICredentialsPass {\n  return (\n    params.user &&\n    params.password &&\n    params.user.username !== undefined &&\n    params.password.digest !== undefined\n  )\n}\n\n/** User credentials for oath login method  */\nexport interface ICredentialsOAuth {\n  oauth: { credentialToken: string, credentialSecret: string }\n}\n\n/** Password login credential type guard */\nexport function isLoginOAuth (params: any): params is ICredentialsOAuth {\n  return (\n    params.oath &&\n    params.credentialToken !== undefined &&\n    params.credentialSecret !== undefined\n  )\n}\n\n/** User credentials for authenticated login method */\nexport interface ICredentialsAuthenticated {\n  resume: string\n}\n\n/** Password login credential type guard */\nexport function isLoginAuthenticated (params: any): params is ICredentialsAuthenticated {\n  return (params.resume !== undefined)\n}\n\n/**\n * Common args for POST, GET, PUT, DELETE requests\n * @param endpoint The API endpoint (including version) e.g. `chat.update`\n * @param data     Payload for POST request to endpoint\n * @param auth     Require auth headers for endpoint, default true\n * @param ignore   Allows certain matching error messages to not count as errors\n */\nexport interface IAPIRequest {\n  (\n    endpoint: string,\n    data?: any,\n    auth?: boolean,\n    ignore?: RegExp,\n    options?: any\n  ): Promise<any>\n}\n\n/**\n * Response from login method (called by websocket)\n * @todo make test to inspect websocket login result interface\n */\nexport interface ILoginResult {\n  id: string, // userId\n  token: string,\n  createCipher: { '$date': number }\n}\n\n/** Password login credential type guard */\nexport function isLoginResult (params: any): params is ILoginResult {\n  return (params.token !== undefined)\n}\n\n/** Credentials for logging into API */\nexport interface ICredentialsAPI {\n  username: string\n  password: string\n}\n\n/**\n * Result object from an API login\n * @param status      e.g. 'success'\n * @param data        Logged in user data\n * @param data.authToken Login renewal token\n * @param userId      ID of logged-in user\n */\nexport interface ILoginResultAPI {\n  status: string // e.g. 'success'\n  data: {\n    authToken: string\n    userId: string\n  }\n}\n\n/** Error-first callback param type */\nexport interface ICallback {\n  (error: Error | null, ...args: any[]): void\n}\n\n/** Error-first callback for message stream events */\nexport interface IMessageCallback {\n  (error: Error | null, message?: IMessage, meta?: IMessageMeta): void\n}\n\n/**\n * Websocket stream subscription\n * @param id          Subscription ID\n * @param name        Stream/collection name\n * @param unsubscribe Method for unsubscribing\n */\nexport interface ISubscription {\n  id?: string\n  name?: any\n  unsubscribe: () => Promise<any>\n  onEvent: (callback: ISocketMessageCallback) => void\n  [key: string]: any\n}\n\n/**\n * Subscription events (changes) in message stream\n * @param msg         The event type (usually 'change')\n * @param collection  Streamed collection name, e.g. 'stream-room-messages'\n * @param id          Collection ID (some streams don't include other than 'id')\n * @param fields      Emitted event arguments\n * @param fields.eventName The room or sub-collection name for this event\n * @param fields.args Event rgs, for message events it will be message and meta\n */\nexport interface ISubscriptionEvent {\n  msg: string\n  collection: 'stream-room-messages'\n  id: 'id'\n  fields: {\n    eventName: '__my_messages__'\n    args: [ IMessage, IMessageMeta ]\n  }\n}\n\n/**\n * API result for channel.history request\n * @todo Incomplete\n */\nexport interface IHistoryAPI {\n  messages: IMessageReceipt[]\n}\n\n/**\n * Message schema\n * @param rid         Room ID\n * @param _id         Mongo collection ID generated by Random.id()\n * @param t           Room type e.g. \"c\" for channel\n * @param msg         Text content\n * @param alias       ?\n * @param emoji       Emoji to use as avatar\n * @param avatar      URL of avatar image\n * @param groupable   Group with consecutive messages\n * @param bot         Integration details\n * @param urls        ?\n * @param mentions    ?\n * @param u           User who sent the message\n * @param ts          Message created timestamp\n * @param editedBy    User who edited the message\n * @param editedAt    When the message was edited\n * @todo contribute these to @types/rocketchat and require\n */\nexport interface IMessage {\n  rid?: string\n  _id?: string\n  t?: string\n  msg?: string\n  alias?: string\n  emoji?: string\n  avatar?: string\n  groupable?: boolean\n  bot?: any\n  urls?: string[]\n  mentions?: string[]\n  attachments?: IMessageAttachment[]\n  reactions?: IMessageReaction\n  location ?: IMessageLocation\n  u?: IUser\n  ts?: { '$date': Date }\n  editedBy?: IUser\n  editedAt?: { '$date': Date }\n}\n\n/**\n * Extra details emitted about message in stream events.\n * @param roomParticipant If the logged in user was joined to the room\n * @param roomType    Type of room (public, private, DM, livechat)\n * @param roomName    The room name if public or named private group\n */\nexport interface IMessageMeta {\n  roomParticipant: boolean\n  roomType: RoomType\n  roomName?: 'general'\n}\n\n/**\n * Message receipt returned after send (not the same as sent object).\n * @todo Confirm why/if this is actually different to IMessage, e.g. msg vs text\n * @param _id         ID of sent message\n * @param rid         Room ID of sent message\n * @param alias       ?\n * @param msg         Content of message\n * @param parseUrls   URL parsing enabled on message hooks\n * @param groupable   Grouping message enabled\n * @param ts          Timestamp of message creation\n * @param _updatedAt  Time message last updated\n * @param editedAt    Time updated by edit\n */\nexport interface IMessageReceipt {\n  _id: string\n  rid: string\n  alias: string\n  msg: string\n  parseUrls: boolean\n  groupable: boolean\n  ts: string\n  _updatedAt: string\n  editedAt?: string\n  u: IUser\n  editedBy?: IUser\n  attachments?: IAttachmentAPI[]\n  reactions?: IMessageReaction\n}\n\n/**\n * Payload structure for `chat.postMessage` endpoint\n * @param roomId      The room id of where the message is to be sent\n * @param channel     The channel name with the prefix in front of it\n * @param text        The text of the message to send is optional because of attachments\n * @param alias       This will cause the messenger name to appear as the given alias but username will still display\n * @param emoji       If provided this will make the avatar on this message be an emoji\n * @param avatar      If provided this will make the avatar use the provided image url\n */\nexport interface IMessageAPI {\n  roomId: string\n  channel?: string\n  text?: string\n  alias?: string\n  emoji?: string\n  avatar?: string\n  attachments?: IAttachmentAPI[]\n}\n\n/**\n * Payload structure for `chat.update` endpoint\n * @param roomId      The room id of where the message is\n * @param msgId       The message id to update\n * @param text        Updated text for the message\n */\nexport interface IMessageUpdateAPI {\n  roomId: string\n  msgId: string\n  text: string\n}\n\n/** Message Attachment schema */\nexport interface IMessageAttachment {\n  fields?: IAttachmentField[]\n  actions?: IMessageAction[]\n  color?: string\n  text?: string\n  ts?: string\n  thumb_url?: string\n  message_link?: string\n  collapsed?: boolean\n  author_name?: string\n  author_link?: string\n  author_icon?: string\n  title?: string\n  title_link?: string\n  title_link_download?: string\n  image_url?: string\n  audio_url?: string\n  video_url?: string\n}\n\n/** Attachment field schema */\nexport interface IAttachmentField {\n  short?: boolean\n  title?: string\n  value?: string\n}\n\n/** Message emoji reaction attribute schema (emoji: [usernames that reacted]) */\nexport interface IMessageReaction {\n  [emoji: string]: { usernames: string[] }\n}\n\n/** Rich message action schema */\nexport interface IMessageAction {\n  type?: string\n  text?: string\n  url?: string\n  image_url?: string\n  is_webview?: boolean\n  webview_height_ratio?: 'compact' | 'tall' | 'full'\n  msg?: string\n  msg_in_chat_window?: boolean\n  button_alignment?: 'vertical' | 'horizontal'\n  temporary_buttons?: boolean\n}\n\n/** Geo-location attribute schema */\nexport interface IMessageLocation {\n  type: string                // e.g. Point\n  coordinates: string[]       // longitude latitude\n}\n\n/**\n * Payload structure for message attachments\n * @param color       The color you want the order on the left side to be any value background-css supports\n * @param text        The text to display for this attachment it is different than the message text\n * @param ts          ISO timestamp displays the time next to the text portion\n * @param thumb_url   An image that displays to the left of the text looks better when this is relatively small\n * @param message_link Only applicable if the ts is provided as it makes the time clickable to this link\n * @param collapsed   Causes the image audio and video sections to be hiding when collapsed is true\n * @param author_name Name of the author\n * @param author_link Providing this makes the author name clickable and points to this link\n * @param author_icon Displays a tiny icon to the left of the author's name\n * @param title       Title to display for this attachment displays under the author\n * @param title_link  Providing this makes the title clickable pointing to this link\n * @param title_link_download_true When this is true a download icon appears and clicking this saves the link to file\n * @param image_url   The image to display will be “big” and easy to see\n * @param audio_url   Audio file to play only supports what html audio does\n * @param video_url   Video file to play only supports what html video does\n */\nexport interface IAttachmentAPI {\n  color?: string\n  text?: string\n  ts?: string\n  thumb_url?: string\n  message_link?: string\n  collapsed?: boolean\n  author_name?: string\n  author_link?: string\n  author_icon?: string\n  title?: string\n  title_link?: string\n  title_link_download_true?: string\n  image_url?: string\n  audio_url?: string\n  video_url?: string\n  fields?: IAttachmentFieldAPI[]\n  actions?: IMessageAction[]\n}\n\n/**\n * Payload structure for attachment field object\n * The field property of the attachments allows for “tables” or “columns” to be displayed on messages\n * @param short       Whether this field should be a short field\n * @param title       The title of this field\n * @param value       The value of this field displayed underneath the title value\n */\nexport interface IAttachmentFieldAPI {\n  short?: boolean\n  title: string\n  value: string\n}\n\n/**\n * Result structure for message endpoints\n * @param ts          Seconds since unix epoch\n * @param channel     Name of channel without prefix\n * @param message     Sent message\n * @param success     Send status\n */\nexport interface IMessageResultAPI {\n  ts: number\n  channel: string\n  message: IMessageReceipt\n  success: boolean\n}\n\n/**\n * User (as attribute) schema\n * @param _id         Mongo collection ID generated by Random.id()\n * @param username    Username\n * @param name        Display name\n */\nexport interface IUser {\n  _id: string\n  username: string\n  name?: string\n}\n\n/**\n * User object structure for creation endpoints\n * @param email       Email address\n * @param name        Full name\n * @param password    User pass\n * @param username    Username\n * @param active      Subscription is active\n * @param roles       Role IDs\n * @param joinDefaultChannels Auto join channels marked as default\n * @param requirePasswordChange Direct to password form on next login\n * @param sendWelcomeEmail  Send new credentials in email\n * @param verified    Email address verification status\n */\nexport interface INewUserAPI {\n  email?: string\n  name?: string\n  password: string\n  username: string\n  active?: true\n  roles?: string[]\n  joinDefaultChannels?: boolean\n  requirePasswordChange?: boolean\n  sendWelcomeEmail?: boolean\n  verified?: true\n}\n\n/**\n * User object structure for queries (not including admin access level)\n * @param _id         MongoDB user doc ID\n * @param type        user / bot ?\n * @param status      online | offline\n * @param active      Subscription is active\n * @param name        Full name\n * @param utcOffset   Hours off UTC/GMT\n * @param username    Username\n */\nexport interface IUserAPI {\n  _id: string\n  type: string\n  status: string\n  active: boolean\n  name: string\n  utcOffset: number\n  username: string\n}\n\n/**\n * Result structure for user data request (by non-admin)\n * @param user    The requested user\n * @param success Status of request\n */\nexport interface IUserResultAPI {\n  user: IUserAPI\n  success: boolean\n}\n\n/** Room type literal (channel private direct livechat) */\nexport type RoomType = 'c' | 'p' | 'd' | 'l'\n\n/**\n * Room object structure from API\n * @param _id         Room ID\n * @param _updatedAt  ISO timestamp\n * @param ts          ISO timestamp (current time in room?)\n * @param msgs        Count of messages in room\n */\nexport interface IRoomAPI {\n  t: RoomType\n  _id: string\n  _updatedAt: string\n  ts: string\n  msgs: number\n  meta: IRoomMetaAPI\n}\n\n/** Room result meta from API */\nexport interface IRoomMetaAPI {\n  revision: number\n  created: number\n  version: number\n}\n\n/**\n * Channel result schema\n * @param _id         Channel ID\n * @param name        Channel name\n * @param default     Is default channel\n * @param ts          ISO timestamp (current time in room?)\n * @param msgs        Count of messages in room\n */\nexport interface IChannelAPI {\n  t: RoomType\n  _id: string\n  name: string\n  default: boolean\n  ts: string\n  msgs: number\n  u: IUser\n}\n\n/**\n * Group (private room) result schema\n * @param _id         Group ID\n * @param name        Group name\n * @param default     Is default channel (would be false)\n * @param usernames   Users in group\n * @param msgs        Count of messages in room\n * @param ts          ISO timestamp (current time in room?)\n */\nexport interface IGroupAPI {\n  t: RoomType\n  _id: string\n  name: string\n  default: boolean\n  usernames: string[]\n  msgs: number\n  ts: string\n  u: IUser\n}\n\n/** Result structure for room creation (e.g. DM) */\nexport interface IRoomResultAPI {\n  room: IRoomAPI\n  success: boolean\n}\n\n/** Result structure for channel creation */\nexport interface IChannelResultAPI {\n  channel: IChannelAPI\n  success: boolean\n}\n\n/** Result structure for group creation */\nexport interface IGroupResultAPI {\n  group: IGroupAPI\n  success: boolean\n}\n\n/** Structure for livechat token field api */\nexport interface ILivechatTokenAPI {\n  token: string\n}\n\n/** Structure for livechat room credential api */\nexport interface ILivechatRoomCredentialAPI {\n  token: string\n}\n/** Structure for livechat room credential api */\nexport interface ILivechatRoom {\n  rid: string\n  department?: string\n}\n\n/** Structure to get(new) livechat room */\nexport interface INewLivechatRoomCredentialAPI {\n  rid?: string\n  agentId?: string\n}\n\n/** Structure for livechat room messages api */\nexport interface ILivechatRoomMessagesAPI {\n  token: string   // Visitor token\n  ts?: string     // ISO timestamp\n  end?: string    // ISO timestamp\n  limit?: number   // number of messages to load\n}\n\n/** Payload structure for livechat `room.transfer` endpoint */\nexport interface ILivechatRoomTransferAPI {\n  token: string\n  department: string\n}\n\n/** Payload structure for livechat survey values */\nexport interface ILivechatSurveyAPI {\n  name: 'satisfaction' | 'agentKnowledge' | 'agentResponsiveness' | 'agentFriendliness'\n  value: '1' | '2' | '3' | '4' | '5'\n}\n\n/** Payload structure for livechat `room.transfer` endpoint */\nexport interface ILivechatRoomSurveyAPI {\n  rid: string\n  data?: ILivechatSurveyAPI[] // See surcvey interface above\n}\n\n/** Livechat New Room object structure */\nexport interface ILivechatNewRoomAPI {\n  _id: string           // Room ID\n  _updatedAt: string    // ISO timestamp\n  t: 'r'                // Room type (channel, private, direct, livechat)\n  msgs: number          // Count of messages in room\n  ts: string            // ISO timestamp (current time in room?)\n  lm?: string           // ISO timestamp (last message)\n  open?: boolean        // Room status\n  departmentId?: string // Livechat Department _id\n  fname: string         // Room display name\n  v: {\n\t  _id: number         // Visitor ID\n\t  token: string       // Visitor token\n\t  username: number    // Visitor username\n  }\n}\n\n/** Result structure for room creation (e.g. DM) */\nexport interface ILivechatNewRoomResultAPI {\n  room: ILivechatNewRoomAPI\n  newRoom: boolean\n  success: boolean\n}\n\n/** Custom Field object structure for livechat endpoints */\nexport interface ILivechatGuestCustomFieldAPI {\n  key: string\n  value: string\n  overwrite: boolean\n}\n\n/** Payload structure for new Livechat Visitors */\nexport interface ILivechatGuestAPI {\n  token: string\n  name?: string\n  email?: string\n  department?: string\n  phone?: string\n  username?: string\n  customFields?: ILivechatGuestCustomFieldAPI[]\n}\n\n/** Visitor object structure for livechat endpoints */\nexport interface INewLivechatGuestAPI {\n  visitor: ILivechatGuestAPI\n}\n\n/** Payload structure for new Livechat Message */\nexport interface INewLivechatMessageAPI {\n  _id?: string          // Message ID\n  msg: string           // Message text\n  token: string         // Livechat Token\n  rid: string           // Room ID\n  agent?: {\n    agentId: string\n    username: string\n  }\n}\n\n/** Result structure for visitor emails */\nexport interface ILivechatEmailAPI {\n  address: string,\n  verified?: boolean\n}\n\n/** Result structure for visitor phones */\nexport interface ILivechatVisitorPhoneAPI {\n  phoneNumber: string\n}\n\n/** Result structure for visitor prop */\nexport interface ILivechatVisitorAPI {\n  token: string\n  _updatedAt: string\n  name?: string\n  phone?: ILivechatVisitorPhoneAPI[]\n  username: string\n  visitorEmails?: ILivechatEmailAPI[]\n  livechatData?: object\n}\n\n/** Result structure for visitor creation */\nexport interface ILivechatVisitorResultAPI {\n  visitor: ILivechatVisitorAPI\n  success: boolean\n}\n\n/** Result structure for config survey */\nexport interface ILivechatConfigSurveyAPI {\n  items: ['satisfaction', 'agentKnowledge', 'agentResponsiveness', 'agentFriendliness']\n  values: ['1', '2', '3', '4', '5']\n}\n\n/** Result structure for config prop */\nexport interface ILivechatConfigAPI {\n  enabled: boolean\n  online?: boolean\n  settings?: object\n  theme?: object\n  messages?: object\n  survey?: ILivechatConfigSurveyAPI,\n  guest?: ILivechatGuestAPI\n}\n\n/** Result structure for Livechat config */\nexport interface ILivechatConfigResultAPI {\n  config: ILivechatConfigAPI\n  success: boolean\n}\n\n/** Livechat Room object structure */\nexport interface ILivechatRoomAPI {\n  _id: string           // Room ID\n  open?: boolean        // Room status\n  departmentId?: string // Livechat Department _id\n  servedBy: {\n\t  _id: number         // Agent ID\n    username: number    // Agent username\n  }\n}\n\n/** Result structure for room */\nexport interface ILivechatRoomResultAPI {\n  room: ILivechatRoomAPI\n  success: boolean\n}\n\n/** Livechat Agent object structure */\nexport interface ILivechatAgentAPI {\n  _id: string           // Agent ID\n  name: string          // Agent name\n  username: string      // Agent username\n  emails: ILivechatEmailAPI[]\n}\n\n/** Result structure for agent */\nexport interface ILivechatAgentResultAPI {\n  agent: ILivechatAgentAPI\n  success: boolean\n}\n\n/** Livechat Message object structure */\nexport interface ILivechatMessageAPI {\n  msg: string\n  u: {\n    _id: string\n    username: string\n    name: string\n  }\n  ts: string\n}\n\n/** Result structure for Livechat Message */\nexport interface ILivechatMessageResultAPI {\n  message: ILivechatMessageAPI\n  success: boolean\n}\n\n/** Payload structure for new Livechat Offline Message */\nexport interface INewLivechatOfflineMessageAPI {\n  name: string          // Message Name\n  email: string         // Message email\n  message: string       // Message text\n}\n\n/** Result structure for Livechat Offline Message */\nexport interface ILivechatOfflineMessageResultAPI {\n  message: string\n  success: boolean\n}\n\n/** Navigation object structure for livechat endpoints */\nexport interface ILivechatNavigation {\n  change: string      // Action (Url or Page Title)\n  title: string       // Page Title\n  location: {\n    href: string\n  }\n  token?: string\n}\n\n/** Payload structure for new Livechat Visitor Navigation */\nexport interface INewLivechatNavigationAPI {\n  token: string         // Livechat Token\n  rid: string           // Room ID\n  pageInfo: ILivechatNavigation\n}\n\n/** Result structure for Livechat Navigation */\nexport interface ILivechatNavigationResultAPI {\n  page?: {\n    msg: string\n    navigation: ILivechatNavigation\n  }\n  success: boolean\n}\n\n/** Result structure for Livechat Transcript */\nexport interface ILivechatTranscriptResultAPI {\n  message: string\n  success: boolean\n}\n\n/** Livechat VideoCall object structure */\nexport interface ILivechatVideoCallAPI {\n  rid: string           // Room ID\n  domain: string        // Video Call provider domain\n  provider: string      // Video Call provider name\n  room: string          // Video Call room\n}\n\n/** Result structure for Livechat VideoCall */\nexport interface ILivechatVideoCallResultAPI {\n  videoCall: ILivechatVideoCallAPI\n  success: boolean\n}\n\n/** Payload structure for new Livechat CustomField */\nexport interface ILivechatCustomFieldAPI {\n  key: string\n  value: string\n  overwrite: boolean\n}\n\n/** Livechat CustomField object structure */\nexport interface INewLivechatCustomFieldAPI {\n  key: string          // CustomField key\n  value: string        // CustomField value\n  overwrite: boolean   // Overwrite CustomField value if exists\n}\n\n/** Result structure for Livechat CustomField */\nexport interface ILivechatCustomFieldResultAPI {\n  field: ILivechatCustomFieldAPI\n  success: boolean\n}\n\n/** Structure for Livechat CustomFields api */\nexport interface INewLivechatCustomFieldsAPI {\n  token: string   // Visitor token\n  customFields: ILivechatCustomFieldAPI[]\n}\n\n/** Result structure for Livechat CustomFields */\nexport interface ILivechatCustomFieldsResultAPI {\n  fields: ILivechatCustomFieldAPI[]\n  success: boolean\n}\n\n/** Structure for Livechat Upload api */\nexport interface ILivechatUploadAPI {\n  rid: string\n  file: File\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/interfaces/index.d.ts b/node_modules/@rocket.chat/sdk/interfaces/index.ts
similarity index 62%
rename from node_modules/@rocket.chat/sdk/interfaces/index.d.ts
rename to node_modules/@rocket.chat/sdk/interfaces/index.ts
index f418e2a..88950db 100644
--- a/node_modules/@rocket.chat/sdk/interfaces/index.d.ts
+++ b/node_modules/@rocket.chat/sdk/interfaces/index.ts
@@ -1,11 +1,12 @@
 /** Loggers need to provide the same set of methods */
 export interface ILogger {
-    debug: (...args: any[]) => void;
-    info: (...args: any[]) => void;
-    warning: (...args: any[]) => void;
-    warn: (...args: any[]) => void;
-    error: (...args: any[]) => void;
+  debug: (...args: any[]) => void
+  info: (...args: any[]) => void
+  warning: (...args: any[]) => void
+  warn: (...args: any[]) => void
+  error: (...args: any[]) => void
 }
+
 /**
  * Connection options type
  * @param host        Host URL:PORT, converted to websocket protocol
@@ -17,14 +18,15 @@ export interface ILogger {
  * @param integration Name added to message `bot` attribute to identify SDK use
  */
 export interface ISocketOptions {
-    host?: string;
-    useSsl?: boolean;
-    timeout?: number;
-    reopen?: number;
-    ping?: number;
-    close?: number;
-    integration?: string;
-}
+  host?: string
+  useSsl?: boolean
+  timeout?: number
+  reopen?: number
+  ping?: number
+  close?: number
+  integration?: string
+}
+
 /**
  * DDP Message Handler defines attributes to match on incoming messages and
  * fire a callback. There may be multiple handlers for any given message.
@@ -35,16 +37,18 @@ export interface ISocketOptions {
  * @param collection  The `data.collection` value to match in message
  */
 export interface ISocketMessageHandler {
-    callback: ISocketMessageCallback;
-    persist?: boolean;
-    msg?: string;
-    id?: string;
-    collection?: string;
+  callback: ISocketMessageCallback
+  persist?: boolean
+  msg?: string
+  id?: string
+  collection?: string
 }
+
 /** Function interface for DDP message handler callback */
 export interface ISocketMessageCallback {
-    (data: any): void;
+  (data: any): void
 }
+
 /**
  * Message respond options
  * @param rooms       Respond to only selected room/s (names or IDs)
@@ -54,47 +58,62 @@ export interface ISocketMessageCallback {
  * @param edited      Respond to edited messages
  */
 export interface IRespondOptions {
-    rooms?: string[];
-    allPublic?: boolean;
-    dm?: boolean;
-    livechat?: boolean;
-    edited?: boolean;
+  rooms?: string[]
+  allPublic?: boolean
+  dm?: boolean
+  livechat?: boolean
+  edited?: boolean
 }
+
 /** User credentials generic interface */
 export interface ICredentials {
-    password: string;
-    username: string;
-    email?: string;
-    ldap?: boolean;
-    ldapOptions?: object;
+  password: string
+  username: string
+  email?: string
+  ldap?: boolean
+  ldapOptions?: object
 }
+
 /** User credentials for password login method */
 export interface ICredentialsPass {
-    user: {
-        username: string;
-    };
-    password: {
-        digest: string;
-        algorithm: string;
-    };
+  user: { username: string }
+  password: { digest: string, algorithm: string }
 }
+
 /** Password login credential type guard */
-export declare function isLoginPass(params: any): params is ICredentialsPass;
+export function isLoginPass (params: any): params is ICredentialsPass {
+  return (
+    params.user &&
+    params.password &&
+    params.user.username !== undefined &&
+    params.password.digest !== undefined
+  )
+}
+
 /** User credentials for oath login method  */
 export interface ICredentialsOAuth {
-    oauth: {
-        credentialToken: string;
-        credentialSecret: string;
-    };
+  oauth: { credentialToken: string, credentialSecret: string }
 }
+
 /** Password login credential type guard */
-export declare function isLoginOAuth(params: any): params is ICredentialsOAuth;
+export function isLoginOAuth (params: any): params is ICredentialsOAuth {
+  return (
+    params.oath &&
+    params.credentialToken !== undefined &&
+    params.credentialSecret !== undefined
+  )
+}
+
 /** User credentials for authenticated login method */
 export interface ICredentialsAuthenticated {
-    resume: string;
+  resume: string
 }
+
 /** Password login credential type guard */
-export declare function isLoginAuthenticated(params: any): params is ICredentialsAuthenticated;
+export function isLoginAuthenticated (params: any): params is ICredentialsAuthenticated {
+  return (params.resume !== undefined)
+}
+
 /**
  * Common args for POST, GET, PUT, DELETE requests
  * @param endpoint The API endpoint (including version) e.g. `chat.update`
@@ -103,26 +122,36 @@ export declare function isLoginAuthenticated(params: any): params is ICredential
  * @param ignore   Allows certain matching error messages to not count as errors
  */
 export interface IAPIRequest {
-    (endpoint: string, data?: any, auth?: boolean, ignore?: RegExp, options?: any): Promise<any>;
-}
+  (
+    endpoint: string,
+    data?: any,
+    auth?: boolean,
+    ignore?: RegExp,
+    options?: any
+  ): Promise<any>
+}
+
 /**
  * Response from login method (called by websocket)
  * @todo make test to inspect websocket login result interface
  */
 export interface ILoginResult {
-    id: string;
-    token: string;
-    createCipher: {
-        '$date': number;
-    };
+  id: string, // userId
+  token: string,
+  createCipher: { '$date': number }
 }
+
 /** Password login credential type guard */
-export declare function isLoginResult(params: any): params is ILoginResult;
+export function isLoginResult (params: any): params is ILoginResult {
+  return (params.token !== undefined)
+}
+
 /** Credentials for logging into API */
 export interface ICredentialsAPI {
-    username: string;
-    password: string;
+  username: string
+  password: string
 }
+
 /**
  * Result object from an API login
  * @param status      e.g. 'success'
@@ -131,20 +160,23 @@ export interface ICredentialsAPI {
  * @param userId      ID of logged-in user
  */
 export interface ILoginResultAPI {
-    status: string;
-    data: {
-        authToken: string;
-        userId: string;
-    };
+  status: string // e.g. 'success'
+  data: {
+    authToken: string
+    userId: string
+  }
 }
+
 /** Error-first callback param type */
 export interface ICallback {
-    (error: Error | null, ...args: any[]): void;
+  (error: Error | null, ...args: any[]): void
 }
+
 /** Error-first callback for message stream events */
 export interface IMessageCallback {
-    (error: Error | null, message?: IMessage, meta?: IMessageMeta): void;
+  (error: Error | null, message?: IMessage, meta?: IMessageMeta): void
 }
+
 /**
  * Websocket stream subscription
  * @param id          Subscription ID
@@ -152,12 +184,13 @@ export interface IMessageCallback {
  * @param unsubscribe Method for unsubscribing
  */
 export interface ISubscription {
-    id?: string;
-    name?: any;
-    unsubscribe: () => Promise<any>;
-    onEvent: (callback: ISocketMessageCallback) => void;
-    [key: string]: any;
+  id?: string
+  name?: any
+  unsubscribe: () => Promise<any>
+  onEvent: (callback: ISocketMessageCallback) => void
+  [key: string]: any
 }
+
 /**
  * Subscription events (changes) in message stream
  * @param msg         The event type (usually 'change')
@@ -168,21 +201,23 @@ export interface ISubscription {
  * @param fields.args Event rgs, for message events it will be message and meta
  */
 export interface ISubscriptionEvent {
-    msg: string;
-    collection: 'stream-room-messages';
-    id: 'id';
-    fields: {
-        eventName: '__my_messages__';
-        args: [IMessage, IMessageMeta];
-    };
-}
+  msg: string
+  collection: 'stream-room-messages'
+  id: 'id'
+  fields: {
+    eventName: '__my_messages__'
+    args: [ IMessage, IMessageMeta ]
+  }
+}
+
 /**
  * API result for channel.history request
  * @todo Incomplete
  */
 export interface IHistoryAPI {
-    messages: IMessageReceipt[];
+  messages: IMessageReceipt[]
 }
+
 /**
  * Message schema
  * @param rid         Room ID
@@ -203,29 +238,26 @@ export interface IHistoryAPI {
  * @todo contribute these to @types/rocketchat and require
  */
 export interface IMessage {
-    rid?: string;
-    _id?: string;
-    t?: string;
-    msg?: string;
-    alias?: string;
-    emoji?: string;
-    avatar?: string;
-    groupable?: boolean;
-    bot?: any;
-    urls?: string[];
-    mentions?: string[];
-    attachments?: IMessageAttachment[];
-    reactions?: IMessageReaction;
-    location?: IMessageLocation;
-    u?: IUser;
-    ts?: {
-        '$date': Date;
-    };
-    editedBy?: IUser;
-    editedAt?: {
-        '$date': Date;
-    };
-}
+  rid?: string
+  _id?: string
+  t?: string
+  msg?: string
+  alias?: string
+  emoji?: string
+  avatar?: string
+  groupable?: boolean
+  bot?: any
+  urls?: string[]
+  mentions?: string[]
+  attachments?: IMessageAttachment[]
+  reactions?: IMessageReaction
+  location ?: IMessageLocation
+  u?: IUser
+  ts?: { '$date': Date }
+  editedBy?: IUser
+  editedAt?: { '$date': Date }
+}
+
 /**
  * Extra details emitted about message in stream events.
  * @param roomParticipant If the logged in user was joined to the room
@@ -233,10 +265,11 @@ export interface IMessage {
  * @param roomName    The room name if public or named private group
  */
 export interface IMessageMeta {
-    roomParticipant: boolean;
-    roomType: RoomType;
-    roomName?: 'general';
+  roomParticipant: boolean
+  roomType: RoomType
+  roomName?: 'general'
 }
+
 /**
  * Message receipt returned after send (not the same as sent object).
  * @todo Confirm why/if this is actually different to IMessage, e.g. msg vs text
@@ -251,20 +284,21 @@ export interface IMessageMeta {
  * @param editedAt    Time updated by edit
  */
 export interface IMessageReceipt {
-    _id: string;
-    rid: string;
-    alias: string;
-    msg: string;
-    parseUrls: boolean;
-    groupable: boolean;
-    ts: string;
-    _updatedAt: string;
-    editedAt?: string;
-    u: IUser;
-    editedBy?: IUser;
-    attachments?: IAttachmentAPI[];
-    reactions?: IMessageReaction;
-}
+  _id: string
+  rid: string
+  alias: string
+  msg: string
+  parseUrls: boolean
+  groupable: boolean
+  ts: string
+  _updatedAt: string
+  editedAt?: string
+  u: IUser
+  editedBy?: IUser
+  attachments?: IAttachmentAPI[]
+  reactions?: IMessageReaction
+}
+
 /**
  * Payload structure for `chat.postMessage` endpoint
  * @param roomId      The room id of where the message is to be sent
@@ -275,14 +309,15 @@ export interface IMessageReceipt {
  * @param avatar      If provided this will make the avatar use the provided image url
  */
 export interface IMessageAPI {
-    roomId: string;
-    channel?: string;
-    text?: string;
-    alias?: string;
-    emoji?: string;
-    avatar?: string;
-    attachments?: IAttachmentAPI[];
-}
+  roomId: string
+  channel?: string
+  text?: string
+  alias?: string
+  emoji?: string
+  avatar?: string
+  attachments?: IAttachmentAPI[]
+}
+
 /**
  * Payload structure for `chat.update` endpoint
  * @param roomId      The room id of where the message is
@@ -290,60 +325,64 @@ export interface IMessageAPI {
  * @param text        Updated text for the message
  */
 export interface IMessageUpdateAPI {
-    roomId: string;
-    msgId: string;
-    text: string;
+  roomId: string
+  msgId: string
+  text: string
 }
+
 /** Message Attachment schema */
 export interface IMessageAttachment {
-    fields?: IAttachmentField[];
-    actions?: IMessageAction[];
-    color?: string;
-    text?: string;
-    ts?: string;
-    thumb_url?: string;
-    message_link?: string;
-    collapsed?: boolean;
-    author_name?: string;
-    author_link?: string;
-    author_icon?: string;
-    title?: string;
-    title_link?: string;
-    title_link_download?: string;
-    image_url?: string;
-    audio_url?: string;
-    video_url?: string;
-}
+  fields?: IAttachmentField[]
+  actions?: IMessageAction[]
+  color?: string
+  text?: string
+  ts?: string
+  thumb_url?: string
+  message_link?: string
+  collapsed?: boolean
+  author_name?: string
+  author_link?: string
+  author_icon?: string
+  title?: string
+  title_link?: string
+  title_link_download?: string
+  image_url?: string
+  audio_url?: string
+  video_url?: string
+}
+
 /** Attachment field schema */
 export interface IAttachmentField {
-    short?: boolean;
-    title?: string;
-    value?: string;
+  short?: boolean
+  title?: string
+  value?: string
 }
+
 /** Message emoji reaction attribute schema (emoji: [usernames that reacted]) */
 export interface IMessageReaction {
-    [emoji: string]: {
-        usernames: string[];
-    };
+  [emoji: string]: { usernames: string[] }
 }
+
 /** Rich message action schema */
 export interface IMessageAction {
-    type?: string;
-    text?: string;
-    url?: string;
-    image_url?: string;
-    is_webview?: boolean;
-    webview_height_ratio?: 'compact' | 'tall' | 'full';
-    msg?: string;
-    msg_in_chat_window?: boolean;
-    button_alignment?: 'vertical' | 'horizontal';
-    temporary_buttons?: boolean;
-}
+  type?: string
+  text?: string
+  url?: string
+  image_url?: string
+  is_webview?: boolean
+  webview_height_ratio?: 'compact' | 'tall' | 'full'
+  msg?: string
+  msg_in_chat_window?: boolean
+  button_alignment?: 'vertical' | 'horizontal'
+  temporary_buttons?: boolean
+}
+
 /** Geo-location attribute schema */
 export interface IMessageLocation {
-    type: string;
-    coordinates: string[];
+  type: string                // e.g. Point
+  coordinates: string[]       // longitude latitude
 }
+
 /**
  * Payload structure for message attachments
  * @param color       The color you want the order on the left side to be any value background-css supports
@@ -363,24 +402,25 @@ export interface IMessageLocation {
  * @param video_url   Video file to play only supports what html video does
  */
 export interface IAttachmentAPI {
-    color?: string;
-    text?: string;
-    ts?: string;
-    thumb_url?: string;
-    message_link?: string;
-    collapsed?: boolean;
-    author_name?: string;
-    author_link?: string;
-    author_icon?: string;
-    title?: string;
-    title_link?: string;
-    title_link_download_true?: string;
-    image_url?: string;
-    audio_url?: string;
-    video_url?: string;
-    fields?: IAttachmentFieldAPI[];
-    actions?: IMessageAction[];
-}
+  color?: string
+  text?: string
+  ts?: string
+  thumb_url?: string
+  message_link?: string
+  collapsed?: boolean
+  author_name?: string
+  author_link?: string
+  author_icon?: string
+  title?: string
+  title_link?: string
+  title_link_download_true?: string
+  image_url?: string
+  audio_url?: string
+  video_url?: string
+  fields?: IAttachmentFieldAPI[]
+  actions?: IMessageAction[]
+}
+
 /**
  * Payload structure for attachment field object
  * The field property of the attachments allows for “tables” or “columns” to be displayed on messages
@@ -389,10 +429,11 @@ export interface IAttachmentAPI {
  * @param value       The value of this field displayed underneath the title value
  */
 export interface IAttachmentFieldAPI {
-    short?: boolean;
-    title: string;
-    value: string;
+  short?: boolean
+  title: string
+  value: string
 }
+
 /**
  * Result structure for message endpoints
  * @param ts          Seconds since unix epoch
@@ -401,11 +442,12 @@ export interface IAttachmentFieldAPI {
  * @param success     Send status
  */
 export interface IMessageResultAPI {
-    ts: number;
-    channel: string;
-    message: IMessageReceipt;
-    success: boolean;
+  ts: number
+  channel: string
+  message: IMessageReceipt
+  success: boolean
 }
+
 /**
  * User (as attribute) schema
  * @param _id         Mongo collection ID generated by Random.id()
@@ -413,10 +455,11 @@ export interface IMessageResultAPI {
  * @param name        Display name
  */
 export interface IUser {
-    _id: string;
-    username: string;
-    name?: string;
+  _id: string
+  username: string
+  name?: string
 }
+
 /**
  * User object structure for creation endpoints
  * @param email       Email address
@@ -431,17 +474,18 @@ export interface IUser {
  * @param verified    Email address verification status
  */
 export interface INewUserAPI {
-    email?: string;
-    name?: string;
-    password: string;
-    username: string;
-    active?: true;
-    roles?: string[];
-    joinDefaultChannels?: boolean;
-    requirePasswordChange?: boolean;
-    sendWelcomeEmail?: boolean;
-    verified?: true;
-}
+  email?: string
+  name?: string
+  password: string
+  username: string
+  active?: true
+  roles?: string[]
+  joinDefaultChannels?: boolean
+  requirePasswordChange?: boolean
+  sendWelcomeEmail?: boolean
+  verified?: true
+}
+
 /**
  * User object structure for queries (not including admin access level)
  * @param _id         MongoDB user doc ID
@@ -453,25 +497,28 @@ export interface INewUserAPI {
  * @param username    Username
  */
 export interface IUserAPI {
-    _id: string;
-    type: string;
-    status: string;
-    active: boolean;
-    name: string;
-    utcOffset: number;
-    username: string;
-}
+  _id: string
+  type: string
+  status: string
+  active: boolean
+  name: string
+  utcOffset: number
+  username: string
+}
+
 /**
  * Result structure for user data request (by non-admin)
  * @param user    The requested user
  * @param success Status of request
  */
 export interface IUserResultAPI {
-    user: IUserAPI;
-    success: boolean;
+  user: IUserAPI
+  success: boolean
 }
+
 /** Room type literal (channel private direct livechat) */
-export declare type RoomType = 'c' | 'p' | 'd' | 'l';
+export type RoomType = 'c' | 'p' | 'd' | 'l'
+
 /**
  * Room object structure from API
  * @param _id         Room ID
@@ -480,19 +527,21 @@ export declare type RoomType = 'c' | 'p' | 'd' | 'l';
  * @param msgs        Count of messages in room
  */
 export interface IRoomAPI {
-    t: RoomType;
-    _id: string;
-    _updatedAt: string;
-    ts: string;
-    msgs: number;
-    meta: IRoomMetaAPI;
-}
+  t: RoomType
+  _id: string
+  _updatedAt: string
+  ts: string
+  msgs: number
+  meta: IRoomMetaAPI
+}
+
 /** Room result meta from API */
 export interface IRoomMetaAPI {
-    revision: number;
-    created: number;
-    version: number;
+  revision: number
+  created: number
+  version: number
 }
+
 /**
  * Channel result schema
  * @param _id         Channel ID
@@ -502,14 +551,15 @@ export interface IRoomMetaAPI {
  * @param msgs        Count of messages in room
  */
 export interface IChannelAPI {
-    t: RoomType;
-    _id: string;
-    name: string;
-    default: boolean;
-    ts: string;
-    msgs: number;
-    u: IUser;
-}
+  t: RoomType
+  _id: string
+  name: string
+  default: boolean
+  ts: string
+  msgs: number
+  u: IUser
+}
+
 /**
  * Group (private room) result schema
  * @param _id         Group ID
@@ -520,290 +570,333 @@ export interface IChannelAPI {
  * @param ts          ISO timestamp (current time in room?)
  */
 export interface IGroupAPI {
-    t: RoomType;
-    _id: string;
-    name: string;
-    default: boolean;
-    usernames: string[];
-    msgs: number;
-    ts: string;
-    u: IUser;
-}
+  t: RoomType
+  _id: string
+  name: string
+  default: boolean
+  usernames: string[]
+  msgs: number
+  ts: string
+  u: IUser
+}
+
 /** Result structure for room creation (e.g. DM) */
 export interface IRoomResultAPI {
-    room: IRoomAPI;
-    success: boolean;
+  room: IRoomAPI
+  success: boolean
 }
+
 /** Result structure for channel creation */
 export interface IChannelResultAPI {
-    channel: IChannelAPI;
-    success: boolean;
+  channel: IChannelAPI
+  success: boolean
 }
+
 /** Result structure for group creation */
 export interface IGroupResultAPI {
-    group: IGroupAPI;
-    success: boolean;
+  group: IGroupAPI
+  success: boolean
 }
+
 /** Structure for livechat token field api */
 export interface ILivechatTokenAPI {
-    token: string;
+  token: string
 }
+
 /** Structure for livechat room credential api */
 export interface ILivechatRoomCredentialAPI {
-    token: string;
+  token: string
 }
 /** Structure for livechat room credential api */
 export interface ILivechatRoom {
-    rid: string;
-    department?: string;
+  rid: string
+  department?: string
 }
+
 /** Structure to get(new) livechat room */
 export interface INewLivechatRoomCredentialAPI {
-    rid?: string;
-    agentId?: string;
+  rid?: string
+  agentId?: string
 }
+
 /** Structure for livechat room messages api */
 export interface ILivechatRoomMessagesAPI {
-    token: string;
-    ts?: string;
-    end?: string;
-    limit?: number;
+  token: string   // Visitor token
+  ts?: string     // ISO timestamp
+  end?: string    // ISO timestamp
+  limit?: number   // number of messages to load
 }
+
 /** Payload structure for livechat `room.transfer` endpoint */
 export interface ILivechatRoomTransferAPI {
-    token: string;
-    department: string;
+  token: string
+  department: string
 }
+
 /** Payload structure for livechat survey values */
 export interface ILivechatSurveyAPI {
-    name: 'satisfaction' | 'agentKnowledge' | 'agentResponsiveness' | 'agentFriendliness';
-    value: '1' | '2' | '3' | '4' | '5';
+  name: 'satisfaction' | 'agentKnowledge' | 'agentResponsiveness' | 'agentFriendliness'
+  value: '1' | '2' | '3' | '4' | '5'
 }
+
 /** Payload structure for livechat `room.transfer` endpoint */
 export interface ILivechatRoomSurveyAPI {
-    rid: string;
-    data?: ILivechatSurveyAPI[];
+  rid: string
+  data?: ILivechatSurveyAPI[] // See surcvey interface above
 }
+
 /** Livechat New Room object structure */
 export interface ILivechatNewRoomAPI {
-    _id: string;
-    _updatedAt: string;
-    t: 'r';
-    msgs: number;
-    ts: string;
-    lm?: string;
-    open?: boolean;
-    departmentId?: string;
-    fname: string;
-    v: {
-        _id: number;
-        token: string;
-        username: number;
-    };
-}
+  _id: string           // Room ID
+  _updatedAt: string    // ISO timestamp
+  t: 'r'                // Room type (channel, private, direct, livechat)
+  msgs: number          // Count of messages in room
+  ts: string            // ISO timestamp (current time in room?)
+  lm?: string           // ISO timestamp (last message)
+  open?: boolean        // Room status
+  departmentId?: string // Livechat Department _id
+  fname: string         // Room display name
+  v: {
+	  _id: number         // Visitor ID
+	  token: string       // Visitor token
+	  username: number    // Visitor username
+  }
+}
+
 /** Result structure for room creation (e.g. DM) */
 export interface ILivechatNewRoomResultAPI {
-    room: ILivechatNewRoomAPI;
-    newRoom: boolean;
-    success: boolean;
+  room: ILivechatNewRoomAPI
+  newRoom: boolean
+  success: boolean
 }
+
 /** Custom Field object structure for livechat endpoints */
 export interface ILivechatGuestCustomFieldAPI {
-    key: string;
-    value: string;
-    overwrite: boolean;
+  key: string
+  value: string
+  overwrite: boolean
 }
+
 /** Payload structure for new Livechat Visitors */
 export interface ILivechatGuestAPI {
-    token: string;
-    name?: string;
-    email?: string;
-    department?: string;
-    phone?: string;
-    username?: string;
-    customFields?: ILivechatGuestCustomFieldAPI[];
-}
+  token: string
+  name?: string
+  email?: string
+  department?: string
+  phone?: string
+  username?: string
+  customFields?: ILivechatGuestCustomFieldAPI[]
+}
+
 /** Visitor object structure for livechat endpoints */
 export interface INewLivechatGuestAPI {
-    visitor: ILivechatGuestAPI;
+  visitor: ILivechatGuestAPI
 }
+
 /** Payload structure for new Livechat Message */
 export interface INewLivechatMessageAPI {
-    _id?: string;
-    msg: string;
-    token: string;
-    rid: string;
-    agent?: {
-        agentId: string;
-        username: string;
-    };
-}
+  _id?: string          // Message ID
+  msg: string           // Message text
+  token: string         // Livechat Token
+  rid: string           // Room ID
+  agent?: {
+    agentId: string
+    username: string
+  }
+}
+
 /** Result structure for visitor emails */
 export interface ILivechatEmailAPI {
-    address: string;
-    verified?: boolean;
+  address: string,
+  verified?: boolean
 }
+
 /** Result structure for visitor phones */
 export interface ILivechatVisitorPhoneAPI {
-    phoneNumber: string;
+  phoneNumber: string
 }
+
 /** Result structure for visitor prop */
 export interface ILivechatVisitorAPI {
-    token: string;
-    _updatedAt: string;
-    name?: string;
-    phone?: ILivechatVisitorPhoneAPI[];
-    username: string;
-    visitorEmails?: ILivechatEmailAPI[];
-    livechatData?: object;
-}
+  token: string
+  _updatedAt: string
+  name?: string
+  phone?: ILivechatVisitorPhoneAPI[]
+  username: string
+  visitorEmails?: ILivechatEmailAPI[]
+  livechatData?: object
+}
+
 /** Result structure for visitor creation */
 export interface ILivechatVisitorResultAPI {
-    visitor: ILivechatVisitorAPI;
-    success: boolean;
+  visitor: ILivechatVisitorAPI
+  success: boolean
 }
+
 /** Result structure for config survey */
 export interface ILivechatConfigSurveyAPI {
-    items: ['satisfaction', 'agentKnowledge', 'agentResponsiveness', 'agentFriendliness'];
-    values: ['1', '2', '3', '4', '5'];
+  items: ['satisfaction', 'agentKnowledge', 'agentResponsiveness', 'agentFriendliness']
+  values: ['1', '2', '3', '4', '5']
 }
+
 /** Result structure for config prop */
 export interface ILivechatConfigAPI {
-    enabled: boolean;
-    online?: boolean;
-    settings?: object;
-    theme?: object;
-    messages?: object;
-    survey?: ILivechatConfigSurveyAPI;
-    guest?: ILivechatGuestAPI;
-}
+  enabled: boolean
+  online?: boolean
+  settings?: object
+  theme?: object
+  messages?: object
+  survey?: ILivechatConfigSurveyAPI,
+  guest?: ILivechatGuestAPI
+}
+
 /** Result structure for Livechat config */
 export interface ILivechatConfigResultAPI {
-    config: ILivechatConfigAPI;
-    success: boolean;
+  config: ILivechatConfigAPI
+  success: boolean
 }
+
 /** Livechat Room object structure */
 export interface ILivechatRoomAPI {
-    _id: string;
-    open?: boolean;
-    departmentId?: string;
-    servedBy: {
-        _id: number;
-        username: number;
-    };
-}
+  _id: string           // Room ID
+  open?: boolean        // Room status
+  departmentId?: string // Livechat Department _id
+  servedBy: {
+	  _id: number         // Agent ID
+    username: number    // Agent username
+  }
+}
+
 /** Result structure for room */
 export interface ILivechatRoomResultAPI {
-    room: ILivechatRoomAPI;
-    success: boolean;
+  room: ILivechatRoomAPI
+  success: boolean
 }
+
 /** Livechat Agent object structure */
 export interface ILivechatAgentAPI {
-    _id: string;
-    name: string;
-    username: string;
-    emails: ILivechatEmailAPI[];
+  _id: string           // Agent ID
+  name: string          // Agent name
+  username: string      // Agent username
+  emails: ILivechatEmailAPI[]
 }
+
 /** Result structure for agent */
 export interface ILivechatAgentResultAPI {
-    agent: ILivechatAgentAPI;
-    success: boolean;
+  agent: ILivechatAgentAPI
+  success: boolean
 }
+
 /** Livechat Message object structure */
 export interface ILivechatMessageAPI {
-    msg: string;
-    u: {
-        _id: string;
-        username: string;
-        name: string;
-    };
-    ts: string;
-}
+  msg: string
+  u: {
+    _id: string
+    username: string
+    name: string
+  }
+  ts: string
+}
+
 /** Result structure for Livechat Message */
 export interface ILivechatMessageResultAPI {
-    message: ILivechatMessageAPI;
-    success: boolean;
+  message: ILivechatMessageAPI
+  success: boolean
 }
+
 /** Payload structure for new Livechat Offline Message */
 export interface INewLivechatOfflineMessageAPI {
-    name: string;
-    email: string;
-    message: string;
+  name: string          // Message Name
+  email: string         // Message email
+  message: string       // Message text
 }
+
 /** Result structure for Livechat Offline Message */
 export interface ILivechatOfflineMessageResultAPI {
-    message: string;
-    success: boolean;
+  message: string
+  success: boolean
 }
+
 /** Navigation object structure for livechat endpoints */
 export interface ILivechatNavigation {
-    change: string;
-    title: string;
-    location: {
-        href: string;
-    };
-    token?: string;
-}
+  change: string      // Action (Url or Page Title)
+  title: string       // Page Title
+  location: {
+    href: string
+  }
+  token?: string
+}
+
 /** Payload structure for new Livechat Visitor Navigation */
 export interface INewLivechatNavigationAPI {
-    token: string;
-    rid: string;
-    pageInfo: ILivechatNavigation;
+  token: string         // Livechat Token
+  rid: string           // Room ID
+  pageInfo: ILivechatNavigation
 }
+
 /** Result structure for Livechat Navigation */
 export interface ILivechatNavigationResultAPI {
-    page?: {
-        msg: string;
-        navigation: ILivechatNavigation;
-    };
-    success: boolean;
+  page?: {
+    msg: string
+    navigation: ILivechatNavigation
+  }
+  success: boolean
 }
+
 /** Result structure for Livechat Transcript */
 export interface ILivechatTranscriptResultAPI {
-    message: string;
-    success: boolean;
+  message: string
+  success: boolean
 }
+
 /** Livechat VideoCall object structure */
 export interface ILivechatVideoCallAPI {
-    rid: string;
-    domain: string;
-    provider: string;
-    room: string;
+  rid: string           // Room ID
+  domain: string        // Video Call provider domain
+  provider: string      // Video Call provider name
+  room: string          // Video Call room
 }
+
 /** Result structure for Livechat VideoCall */
 export interface ILivechatVideoCallResultAPI {
-    videoCall: ILivechatVideoCallAPI;
-    success: boolean;
+  videoCall: ILivechatVideoCallAPI
+  success: boolean
 }
+
 /** Payload structure for new Livechat CustomField */
 export interface ILivechatCustomFieldAPI {
-    key: string;
-    value: string;
-    overwrite: boolean;
+  key: string
+  value: string
+  overwrite: boolean
 }
+
 /** Livechat CustomField object structure */
 export interface INewLivechatCustomFieldAPI {
-    key: string;
-    value: string;
-    overwrite: boolean;
+  key: string          // CustomField key
+  value: string        // CustomField value
+  overwrite: boolean   // Overwrite CustomField value if exists
 }
+
 /** Result structure for Livechat CustomField */
 export interface ILivechatCustomFieldResultAPI {
-    field: ILivechatCustomFieldAPI;
-    success: boolean;
+  field: ILivechatCustomFieldAPI
+  success: boolean
 }
+
 /** Structure for Livechat CustomFields api */
 export interface INewLivechatCustomFieldsAPI {
-    token: string;
-    customFields: ILivechatCustomFieldAPI[];
+  token: string   // Visitor token
+  customFields: ILivechatCustomFieldAPI[]
 }
+
 /** Result structure for Livechat CustomFields */
 export interface ILivechatCustomFieldsResultAPI {
-    fields: ILivechatCustomFieldAPI[];
-    success: boolean;
+  fields: ILivechatCustomFieldAPI[]
+  success: boolean
 }
+
 /** Structure for Livechat Upload api */
 export interface ILivechatUploadAPI {
-    rid: string;
-    file: File;
+  rid: string
+  file: File
 }
diff --git a/node_modules/@rocket.chat/sdk/lib/api/Livechat.d.ts b/node_modules/@rocket.chat/sdk/lib/api/Livechat.d.ts
deleted file mode 100644
index 2afba32..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/Livechat.d.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * @module ApiLivechat
- * Provides a client for making requests with Livechat Rocket.Chat's REST API
- */
-import { ILivechatTokenAPI, ILivechatRoomCredentialAPI, ILivechatRoomSurveyAPI, INewLivechatGuestAPI, INewLivechatMessageAPI, ILivechatRoomMessagesAPI, INewLivechatNavigationAPI, INewLivechatCustomFieldAPI, INewLivechatOfflineMessageAPI, INewLivechatCustomFieldsAPI, ILivechatRoom, INewLivechatRoomCredentialAPI, ILivechatUploadAPI } from '../../interfaces';
-import ApiBase from './api';
-export default class ApiLivechat extends ApiBase {
-    credentials: ILivechatRoomCredentialAPI;
-    login(guest: INewLivechatGuestAPI | any): Promise<any>;
-    config(params?: ILivechatTokenAPI): Promise<any>;
-    room(params?: INewLivechatRoomCredentialAPI): Promise<any>;
-    closeChat({ rid }: ILivechatRoom): Promise<any>;
-    transferChat({ rid, department }: ILivechatRoom): Promise<any>;
-    chatSurvey(survey: ILivechatRoomSurveyAPI): Promise<any>;
-    visitor(): Promise<any>;
-    grantVisitor(guest: INewLivechatGuestAPI): Promise<any>;
-    deleteVisitor(): Promise<any>;
-    updateVisitorStatus(status: string): Promise<any>;
-    nextAgent(department?: string): Promise<any>;
-    agent({ rid }: any): Promise<any>;
-    message(id: string, params: ILivechatRoom): Promise<any>;
-    sendMessage(message: INewLivechatMessageAPI): Promise<any>;
-    editMessage(id: string, message: INewLivechatMessageAPI): Promise<any>;
-    deleteMessage(id: string, { rid }: ILivechatRoom): Promise<any>;
-    loadMessages(rid: string, params?: ILivechatRoomMessagesAPI): Promise<any>;
-    sendOfflineMessage(message: INewLivechatOfflineMessageAPI): Promise<any>;
-    sendVisitorNavigation(page: INewLivechatNavigationAPI): Promise<any>;
-    requestTranscript(email: string, { rid }: ILivechatRoom): Promise<any>;
-    videoCall({ rid }: ILivechatRoom): Promise<any>;
-    sendCustomField(field: INewLivechatCustomFieldAPI): Promise<any>;
-    sendCustomFields(fields: INewLivechatCustomFieldsAPI): Promise<any>;
-    uploadFile(params: ILivechatUploadAPI): Promise<any>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/api/Livechat.js b/node_modules/@rocket.chat/sdk/lib/api/Livechat.js
deleted file mode 100644
index de9ae29..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/Livechat.js
+++ /dev/null
@@ -1,206 +0,0 @@
-"use strict";
-/**
- * @module ApiLivechat
- * Provides a client for making requests with Livechat Rocket.Chat's REST API
- */
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var api_1 = __importDefault(require("./api"));
-var ApiLivechat = /** @class */ (function (_super) {
-    __extends(ApiLivechat, _super);
-    function ApiLivechat() {
-        var _this = _super !== null && _super.apply(this, arguments) || this;
-        _this.credentials = {};
-        return _this;
-    }
-    ApiLivechat.prototype.login = function (guest) { return this.grantVisitor(guest); };
-    ApiLivechat.prototype.config = function (params) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get('livechat/config', params, false)];
-                case 1: return [2 /*return*/, (_a.sent()).config];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.room = function (params) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get('livechat/room', __assign({ token: this.credentials.token }, params), false)];
-                case 1: return [2 /*return*/, (_a.sent()).room];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.closeChat = function (_a) {
-        var rid = _a.rid;
-        return this.post('livechat/room.close', { rid: rid, token: this.credentials.token }, false);
-    };
-    ApiLivechat.prototype.transferChat = function (_a) {
-        var rid = _a.rid, department = _a.department;
-        return (this.post('livechat/room.transfer', { rid: rid, token: this.credentials.token, department: department }, false));
-    };
-    ApiLivechat.prototype.chatSurvey = function (survey) { return (this.post('livechat/room.survey', { rid: survey.rid, token: this.credentials.token, data: survey.data }, false)); };
-    ApiLivechat.prototype.visitor = function () { return this.get("livechat/visitor/" + this.credentials.token); };
-    ApiLivechat.prototype.grantVisitor = function (guest) {
-        return __awaiter(this, void 0, void 0, function () {
-            var visitor;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.post('livechat/visitor', guest, false)];
-                    case 1:
-                        visitor = (_a.sent()).visitor;
-                        this.credentials = {
-                            token: visitor.token
-                        };
-                        return [2 /*return*/, visitor];
-                }
-            });
-        });
-    };
-    ApiLivechat.prototype.deleteVisitor = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.del("livechat/visitor/" + this.credentials.token)];
-                case 1: return [2 /*return*/, (_a.sent()).visitor];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.updateVisitorStatus = function (status) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.post("livechat/visitor.status", { token: this.credentials.token, status: status })];
-                case 1: return [2 /*return*/, (_a.sent()).status];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.nextAgent = function (department) {
-        if (department === void 0) { department = ''; }
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get("livechat/agent.next/" + this.credentials.token, { department: department })];
-                case 1: return [2 /*return*/, (_a.sent()).agent];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.agent = function (_a) {
-        var rid = _a.rid;
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_b) {
-            switch (_b.label) {
-                case 0: return [4 /*yield*/, this.get("livechat/agent.info/" + rid + "/" + this.credentials.token)];
-                case 1: return [2 /*return*/, (_b.sent()).agent];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.message = function (id, params) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get("livechat/message/" + id, __assign({ token: this.credentials.token }, params))];
-                case 1: return [2 /*return*/, (_a.sent()).message];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.sendMessage = function (message) { return (this.post('livechat/message', __assign({}, message, { token: this.credentials.token }), false)); };
-    ApiLivechat.prototype.editMessage = function (id, message) { return (this.put("livechat/message/" + id, message, false)); };
-    ApiLivechat.prototype.deleteMessage = function (id, _a) {
-        var rid = _a.rid;
-        return (this.del("livechat/message/" + id, { rid: rid, token: this.credentials.token }, false));
-    };
-    ApiLivechat.prototype.loadMessages = function (rid, params) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get("livechat/messages.history/" + rid, __assign({}, params, { token: this.credentials.token }), false)];
-                case 1: return [2 /*return*/, (_a.sent()).messages];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.sendOfflineMessage = function (message) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.post('livechat/offline.message', __assign({}, message), false)];
-                case 1: return [2 /*return*/, (_a.sent()).message];
-            }
-        }); });
-    };
-    ApiLivechat.prototype.sendVisitorNavigation = function (page) { return (this.post('livechat/page.visited', __assign({}, page), false)); };
-    ApiLivechat.prototype.requestTranscript = function (email, _a) {
-        var rid = _a.rid;
-        return (this.post('livechat/transcript', { token: this.credentials.token, rid: rid, email: email }, false));
-    };
-    ApiLivechat.prototype.videoCall = function (_a) {
-        var rid = _a.rid;
-        return this.get("livechat/video.call/" + this.credentials.token, { rid: rid }, false);
-    };
-    ApiLivechat.prototype.sendCustomField = function (field) { return this.post('livechat/custom.field', field, false); };
-    ApiLivechat.prototype.sendCustomFields = function (fields) { return this.post('livechat/custom.fields', fields, false); };
-    ApiLivechat.prototype.uploadFile = function (params) {
-        var formData = new FormData();
-        var headersNeededForUpload = {
-            'x-visitor-token': this.credentials.token
-        };
-        formData.append('file', params.file);
-        return this.post("livechat/upload/" + params.rid, formData, false, undefined, { customHeaders: headersNeededForUpload });
-    };
-    return ApiLivechat;
-}(api_1.default));
-exports.default = ApiLivechat;
-//# sourceMappingURL=Livechat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/Livechat.js.map b/node_modules/@rocket.chat/sdk/lib/api/Livechat.js.map
deleted file mode 100644
index f382ee0..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/Livechat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Livechat.js","sourceRoot":"","sources":["../../../src/lib/api/Livechat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module ApiLivechat\n * Provides a client for making requests with Livechat Rocket.Chat's REST API\n */\n\nimport {\n\tILivechatTokenAPI,\n\tILivechatRoomCredentialAPI,\n\tILivechatRoomSurveyAPI,\n\tINewLivechatGuestAPI,\n\tINewLivechatMessageAPI,\n\tILivechatRoomMessagesAPI,\n\tINewLivechatNavigationAPI,\n\tINewLivechatCustomFieldAPI,\n\tINewLivechatOfflineMessageAPI,\n\tINewLivechatCustomFieldsAPI,\n\tILivechatRoom,\n\tINewLivechatRoomCredentialAPI,\n\tILivechatUploadAPI\n} from '../../interfaces'\n\nimport ApiBase from './api'\n\nexport default class ApiLivechat extends ApiBase {\n  credentials: ILivechatRoomCredentialAPI = {} as any\n  login (guest: INewLivechatGuestAPI | any) { return this.grantVisitor(guest) }\n  async config (params?: ILivechatTokenAPI) { return (await this.get('livechat/config', params, false)).config }\n  async room (params?: INewLivechatRoomCredentialAPI) { return (await this.get('livechat/room', { token: this.credentials.token, ...params }, false)).room }\n  closeChat ({ rid }: ILivechatRoom) { return this.post('livechat/room.close', { rid, token: this.credentials.token }, false) }\n  transferChat ({ rid, department }: ILivechatRoom) { return (this.post('livechat/room.transfer', { rid, token: this.credentials.token, department }, false)) }\n  chatSurvey (survey: ILivechatRoomSurveyAPI) { return (this.post('livechat/room.survey', { rid: survey.rid, token: this.credentials.token, data: survey.data }, false)) }\n  visitor () { return this.get(`livechat/visitor/${this.credentials.token}`) }\n  async grantVisitor (guest: INewLivechatGuestAPI) {\n    const { visitor } = await this.post('livechat/visitor', guest, false)\n    this.credentials = {\n      token: visitor.token\n    }\n    return visitor\n  }\n  async deleteVisitor () { return (await this.del(`livechat/visitor/${this.credentials.token}`)).visitor }\n  async updateVisitorStatus (status: string) { return (await this.post(`livechat/visitor.status`, { token: this.credentials.token, status })).status }\n  async nextAgent (department: string = '') { return (await this.get(`livechat/agent.next/${this.credentials.token}`, { department })).agent }\n  async agent ({ rid }: any) { return (await this.get(`livechat/agent.info/${rid}/${this.credentials.token}`)).agent }\n  async message (id: string, params: ILivechatRoom) { return (await this.get(`livechat/message/${id}`, { token: this.credentials.token, ...params })).message }\n  sendMessage (message: INewLivechatMessageAPI) { return (this.post('livechat/message', { ...message, token: this.credentials.token }, false)) }\n  editMessage (id: string, message: INewLivechatMessageAPI) { return (this.put(`livechat/message/${id}`, message, false)) }\n  deleteMessage (id: string, { rid }: ILivechatRoom) { return (this.del(`livechat/message/${id}`, { rid, token: this.credentials.token }, false)) }\n  async loadMessages (rid: string, params?: ILivechatRoomMessagesAPI) { return (await this.get(`livechat/messages.history/${rid}`, { ...params, token: this.credentials.token }, false)).messages }\n  async sendOfflineMessage (message: INewLivechatOfflineMessageAPI) { return (await this.post('livechat/offline.message', { ...message }, false)).message }\n  sendVisitorNavigation (page: INewLivechatNavigationAPI) { return (this.post('livechat/page.visited', { ...page }, false)) }\n  requestTranscript (email: string, { rid }: ILivechatRoom) { return (this.post('livechat/transcript', { token: this.credentials.token, rid, email }, false)) }\n  videoCall ({ rid }: ILivechatRoom) { return this.get(`livechat/video.call/${this.credentials.token}`, { rid }, false) }\n  sendCustomField (field: INewLivechatCustomFieldAPI) { return this.post('livechat/custom.field', field, false) }\n  sendCustomFields (fields: INewLivechatCustomFieldsAPI) { return this.post('livechat/custom.fields', fields, false) }\n  uploadFile (params: ILivechatUploadAPI) {\n    const formData = new FormData()\n    const headersNeededForUpload = {\n      'x-visitor-token': this.credentials.token\n    }\n    formData.append('file', params.file)\n    return this.post(`livechat/upload/${params.rid}`, formData, false, undefined, { customHeaders: headersNeededForUpload })\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/Livechat.spec.ts b/node_modules/@rocket.chat/sdk/lib/api/Livechat.spec.ts
new file mode 100644
index 0000000..4fb1c79
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/api/Livechat.spec.ts
@@ -0,0 +1,221 @@
+import 'mocha'
+import { expect } from 'chai'
+import { silence } from '../log'
+const initEnv = process.env // store configs to restore after tests
+import {
+  botUser,
+  mockUser,
+  mockVisitor,
+  mockSurvey,
+  mockVisitorNavigation,
+  mockOfflineMessage,
+  mockCustomField,
+  mockCustomFields
+} from '../../utils/config'
+import BotDriver from '../clients/Bot'
+import ClientApi from './RocketChat'
+
+import LivechatApi from './Livechat'
+import * as settings from '../settings'
+import { IMessage } from '../../interfaces'
+global.fetch = require('node-fetch')
+global.FormData = require('form-data')
+// silence() // suppress log during tests (disable this while developing tests)
+
+const clientApi = new ClientApi({})
+const livechatApi = new LivechatApi({})
+const driver = new BotDriver({})
+
+// livechat data, to be populated in before hooks
+let department = settings.department
+let room: any
+let rid: any
+let newMessage: any
+let editMessage: any
+let pageInfo: any
+let email = 'sample@rocket.chat'
+
+describe.skip('.livechat', () => {
+  before(async () => {
+    try {
+
+      const visitor = await livechatApi.grantVisitor(mockVisitor)
+      const room = await livechatApi.room()
+      rid = room._id
+      newMessage = { rid, msg: 'sending livechat message...' }
+      editMessage = { rid, msg: 'editing livechat message...' }
+      pageInfo = Object.assign({}, mockVisitorNavigation, { rid })
+    } catch (error) {
+      console.log(error)
+    }
+  })
+  describe('.config', () => {
+    it('returns data from basic Livechat initial config', async () => {
+      const result = await livechatApi.config()
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('config')
+      expect(result.config).to.include.all.keys([
+        'enabled', 'settings', 'theme', 'messages', 'survey'
+      ])
+    })
+    it('returns data from Livechat config with a valid token', async () => {
+      const { token } = mockVisitor.visitor
+      const result = await livechatApi.config({ token })
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('config')
+      expect(result.config).to.include.all.keys([
+        'enabled', 'settings', 'theme', 'messages', 'survey', 'guest', 'room', 'agent'
+      ])
+    })
+  })
+  describe('.rooms', () => {
+    (department ? it : it.skip)('requests a Livechat transfer', async () => { // TODO CHECK
+      const room = await livechatApi.transferChat({ rid, department })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(room).to.have.property('servedBy')
+      expect(room).to.have.property('open')
+      expect(room).to.have.property('departmentId')
+    })
+    it('sends a Livechat survey', async () => {
+      console.log({ rid, data: mockSurvey })
+      const result = await livechatApi.chatSurvey({ rid, data: mockSurvey })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('rid')
+    })
+    it('requests a Livechat video call', async () => {
+      const result = await livechatApi.videoCall({ rid })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('videoCall')
+    })
+    it.skip('close a Livechat room', async () => {
+      const result = await livechatApi.closeChat({ rid })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('rid')
+      expect(result).to.have.property('comment')
+    })
+    it('requests a Livechat transcript', async () => {
+      const result = await livechatApi.requestTranscript(email, { rid })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('message')
+    })
+  })
+  describe('.agents', () => {
+    it('returns data of a given Livechat room', async () => {
+      const result = await livechatApi.agent({ rid })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('agent')
+      expect(result.agent).to.have.property('emails')
+      expect(result.agent).to.have.property('name')
+      expect(result.agent).to.have.property('username')
+    })
+    it('returns the data of the next Livechat agent available', async () => {
+      const result = await livechatApi.nextAgent({ department })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('agent')
+      expect(result.agent).to.have.property('emails')
+      expect(result.agent).to.have.property('name')
+      expect(result.agent).to.have.property('username')
+    })
+  })
+  describe('.messages', () => {
+    it('sends a new Livechat message', async () => {
+      const result = await livechatApi.sendMessage(newMessage)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('message')
+      expect(result.message).to.have.property('_id')
+      expect(result.message).to.have.property('msg')
+      expect(result.message).to.have.property('u')
+    })
+    it.skip('edit a Livechat Message', async () => {
+      const msg = await livechatApi.sendMessage(newMessage)
+      const _id = msg && msg.message && msg.message._id
+      const result = await livechatApi.editMessage(_id, editMessage)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('message')
+      expect(result.message).to.have.property('_id')
+      expect(result.message).to.have.property('msg')
+      expect(result.message).to.have.property('u')
+    })
+    it('retrieves a list of Livechat messages', async () => {
+      const result = await livechatApi.loadMessages(rid)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('messages')
+      const messages = result.messages.map((msg: IMessage) => msg.rid)
+      expect(messages).to.include(rid)
+    })
+    it.skip('deletes a Livechat message', async () => {
+      const msg = await livechatApi.sendMessage(newMessage)
+      const _id = msg && msg.message && msg.message._id
+      const result = await livechatApi.deleteMessage(_id, { rid })
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('message')
+      expect(result.message).to.have.property('_id')
+      expect(result.message._id).to.equal(_id)
+    })
+    it.skip('sends a Livechat offline message', async () => {
+      const result = await livechatApi.sendOfflineMessage(mockOfflineMessage)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('message')
+    })
+    it('sends a Livechat visitor navigation history', async () => {
+      const result = await livechatApi.sendVisitorNavigation({ rid }, pageInfo)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('page')
+      expect(result.page).to.have.property('msg')
+      expect(result.page).to.have.property('navigation')
+      expect(result.page.navigation).to.have.property('token')
+    })
+  })
+  describe('.visitors', () => {
+    it('registers and grants access to a Livechat visitor', async () => {
+      const visitor = await livechatApi.grantVisitor(mockVisitor)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(visitor).to.have.property('token')
+    })
+    it.skip('assigns a customField to a Livechat visitor', async () => {
+      const result = await livechatApi.sendCustomField(mockCustomField)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('field')
+      expect(result.field).to.have.property('key')
+      expect(result.field.key).to.equal(mockCustomField.key)
+      expect(result.field).to.have.property('value')
+      expect(result.field.value).to.equal(mockCustomField.value)
+    })
+    it.skip('assigns an array of customFields to a Livechat visitor', async () => {
+      const result = await livechatApi.sendCustomFields(mockCustomFields)
+      expect('Content-Type', 'application/json')
+      expect(200)
+      expect(result).to.have.property('success', true)
+      expect(result).to.have.property('fields')
+    })
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/api/Livechat.ts b/node_modules/@rocket.chat/sdk/lib/api/Livechat.ts
new file mode 100644
index 0000000..07635b7
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/api/Livechat.ts
@@ -0,0 +1,63 @@
+/**
+ * @module ApiLivechat
+ * Provides a client for making requests with Livechat Rocket.Chat's REST API
+ */
+
+import {
+	ILivechatTokenAPI,
+	ILivechatRoomCredentialAPI,
+	ILivechatRoomSurveyAPI,
+	INewLivechatGuestAPI,
+	INewLivechatMessageAPI,
+	ILivechatRoomMessagesAPI,
+	INewLivechatNavigationAPI,
+	INewLivechatCustomFieldAPI,
+	INewLivechatOfflineMessageAPI,
+	INewLivechatCustomFieldsAPI,
+	ILivechatRoom,
+	INewLivechatRoomCredentialAPI,
+	ILivechatUploadAPI
+} from '../../interfaces'
+
+import ApiBase from './api'
+
+export default class ApiLivechat extends ApiBase {
+  credentials: ILivechatRoomCredentialAPI = {} as any
+  login (guest: INewLivechatGuestAPI | any) { return this.grantVisitor(guest) }
+  async config (params?: ILivechatTokenAPI) { return (await this.get('livechat/config', params, false)).config }
+  async room (params?: INewLivechatRoomCredentialAPI) { return (await this.get('livechat/room', { token: this.credentials.token, ...params }, false)).room }
+  closeChat ({ rid }: ILivechatRoom) { return this.post('livechat/room.close', { rid, token: this.credentials.token }, false) }
+  transferChat ({ rid, department }: ILivechatRoom) { return (this.post('livechat/room.transfer', { rid, token: this.credentials.token, department }, false)) }
+  chatSurvey (survey: ILivechatRoomSurveyAPI) { return (this.post('livechat/room.survey', { rid: survey.rid, token: this.credentials.token, data: survey.data }, false)) }
+  visitor () { return this.get(`livechat/visitor/${this.credentials.token}`) }
+  async grantVisitor (guest: INewLivechatGuestAPI) {
+    const { visitor } = await this.post('livechat/visitor', guest, false)
+    this.credentials = {
+      token: visitor.token
+    }
+    return visitor
+  }
+  async deleteVisitor () { return (await this.del(`livechat/visitor/${this.credentials.token}`)).visitor }
+  async updateVisitorStatus (status: string) { return (await this.post(`livechat/visitor.status`, { token: this.credentials.token, status })).status }
+  async nextAgent (department: string = '') { return (await this.get(`livechat/agent.next/${this.credentials.token}`, { department })).agent }
+  async agent ({ rid }: any) { return (await this.get(`livechat/agent.info/${rid}/${this.credentials.token}`)).agent }
+  async message (id: string, params: ILivechatRoom) { return (await this.get(`livechat/message/${id}`, { token: this.credentials.token, ...params })).message }
+  sendMessage (message: INewLivechatMessageAPI) { return (this.post('livechat/message', { ...message, token: this.credentials.token }, false)) }
+  editMessage (id: string, message: INewLivechatMessageAPI) { return (this.put(`livechat/message/${id}`, message, false)) }
+  deleteMessage (id: string, { rid }: ILivechatRoom) { return (this.del(`livechat/message/${id}`, { rid, token: this.credentials.token }, false)) }
+  async loadMessages (rid: string, params?: ILivechatRoomMessagesAPI) { return (await this.get(`livechat/messages.history/${rid}`, { ...params, token: this.credentials.token }, false)).messages }
+  async sendOfflineMessage (message: INewLivechatOfflineMessageAPI) { return (await this.post('livechat/offline.message', { ...message }, false)).message }
+  sendVisitorNavigation (page: INewLivechatNavigationAPI) { return (this.post('livechat/page.visited', { ...page }, false)) }
+  requestTranscript (email: string, { rid }: ILivechatRoom) { return (this.post('livechat/transcript', { token: this.credentials.token, rid, email }, false)) }
+  videoCall ({ rid }: ILivechatRoom) { return this.get(`livechat/video.call/${this.credentials.token}`, { rid }, false) }
+  sendCustomField (field: INewLivechatCustomFieldAPI) { return this.post('livechat/custom.field', field, false) }
+  sendCustomFields (fields: INewLivechatCustomFieldsAPI) { return this.post('livechat/custom.fields', fields, false) }
+  uploadFile (params: ILivechatUploadAPI) {
+    const formData = new FormData()
+    const headersNeededForUpload = {
+      'x-visitor-token': this.credentials.token
+    }
+    formData.append('file', params.file)
+    return this.post(`livechat/upload/${params.rid}`, formData, false, undefined, { customHeaders: headersNeededForUpload })
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.d.ts b/node_modules/@rocket.chat/sdk/lib/api/RocketChat.d.ts
deleted file mode 100644
index 0bc5946..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.d.ts
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
-    * @module ApiRocketChat
-    * Provides a client for handling requests with Rocket.Chat's REST API
-    */
-export declare type RID = string;
-import { IMessage, IChannelAPI, IGroupAPI, IMessageReceipt } from '../../interfaces';
-import ApiBase from './api';
-/** Defaults for user queries */
-export declare const userFields: {
-    name: number;
-    username: number;
-    status: number;
-    type: number;
-};
-/** Query helpers for user collection requests */
-export default class ApiRocketChat extends ApiBase {
-    readonly users: any;
-    readonly rooms: any;
-    joinRoom({ rid }: any): Promise<any>;
-    info(): Promise<any>;
-    /**
-     * Send a prepared message object (with pre-defined room ID).
-     * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.
-     */
-    sendMessage(message: IMessage | string, rid: string): Promise<IMessageReceipt>;
-    getRoomIdByNameOrId(name: string): Promise<RID>;
-    getRoomNameById(rid: RID): Promise<string>;
-    getRoomName(rid: string): Promise<string>;
-    getRoomId(name: string): Promise<any>;
-    createDirectMessage(username: string): Promise<any>;
-    /**
-     * Edit an existing message, replacing any attributes with those provided.
-     * The given message object should have the ID of an existing message.
-     */
-    editMessage(message: IMessage): Promise<IMessageReceipt>;
-    /**
-     * Send a reaction to an existing message. Simple proxy for method call.
-     * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction
-     * @param messageId ID for a previously sent message
-     */
-    setReaction(emoji: string, messageId: string): Promise<any>;
-    loadHistory(rid: string, lastUpdate: Date): Promise<{
-        updated: IMessage[];
-        deleted: IMessage[];
-    }>;
-    /** Exit a room the bot has joined */
-    leaveRoom(rid: string): Promise<RID>;
-    /** Get information about a public group */
-    channelInfo(query: {
-        roomName?: string;
-        roomId?: string;
-    }): Promise<IChannelAPI>;
-    /** Get information about a private group */
-    privateInfo(query: {
-        roomName?: string;
-        roomId?: string;
-    }): Promise<IGroupAPI>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js b/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js
deleted file mode 100644
index bf533b2..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js
+++ /dev/null
@@ -1,211 +0,0 @@
-"use strict";
-/**
-    * @module ApiRocketChat
-    * Provides a client for handling requests with Rocket.Chat's REST API
-    */
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var api_1 = __importDefault(require("./api"));
-/** Defaults for user queries */
-exports.userFields = { name: 1, username: 1, status: 1, type: 1 };
-/** Query helpers for user collection requests */
-var ApiRocketChat = /** @class */ (function (_super) {
-    __extends(ApiRocketChat, _super);
-    function ApiRocketChat() {
-        return _super !== null && _super.apply(this, arguments) || this;
-    }
-    Object.defineProperty(ApiRocketChat.prototype, "users", {
-        get: function () {
-            var self = this;
-            return {
-                all: function (fields) {
-                    if (fields === void 0) { fields = exports.userFields; }
-                    return self.get('users.list', { fields: fields }).then(function (r) { return r.users; });
-                },
-                allNames: function () { return self.get('users.list', { fields: { 'username': 1 } }).then(function (r) { return r.users.map(function (u) { return u.username; }); }); },
-                allIDs: function () { return self.get('users.list', { fields: { '_id': 1 } }).then(function (r) { return r.users.map(function (u) { return u._id; }); }); },
-                online: function (fields) {
-                    if (fields === void 0) { fields = exports.userFields; }
-                    return self.get('users.list', { fields: fields, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users; });
-                },
-                onlineNames: function () { return self.get('users.list', { fields: { 'username': 1 }, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users.map(function (u) { return u.username; }); }); },
-                onlineIds: function () { return self.get('users.list', { fields: { '_id': 1 }, query: { 'status': { $ne: 'offline' } } }).then(function (r) { return r.users.map(function (u) { return u._id; }); }); },
-                info: function (username) {
-                    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-                        switch (_a.label) {
-                            case 0: return [4 /*yield*/, self.get('users.info', { username: username }, true)];
-                            case 1: return [2 /*return*/, (_a.sent()).user];
-                        }
-                    }); });
-                }
-            };
-        },
-        enumerable: true,
-        configurable: true
-    });
-    Object.defineProperty(ApiRocketChat.prototype, "rooms", {
-        get: function () {
-            var self = this;
-            return {
-                info: function (_a) {
-                    var rid = _a.rid;
-                    return self.get('rooms.info', { rid: rid }, true);
-                }
-            };
-        },
-        enumerable: true,
-        configurable: true
-    });
-    // editMessage(message: IMessage) chat.update
-    ApiRocketChat.prototype.joinRoom = function (_a) {
-        var rid = _a.rid;
-        return this.post('channels.join', { roomId: rid }, true);
-    };
-    ApiRocketChat.prototype.info = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.get('info', {}, true)];
-                case 1: return [2 /*return*/, (_a.sent()).info];
-            }
-        }); });
-    };
-    /**
-     * Send a prepared message object (with pre-defined room ID).
-     * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.
-     */
-    ApiRocketChat.prototype.sendMessage = function (message, rid) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.post('chat.sendMessage', { message: this.prepareMessage(message, rid) }, true)];
-                case 1: return [2 /*return*/, (_a.sent()).message];
-            }
-        }); });
-    };
-    ApiRocketChat.prototype.getRoomIdByNameOrId = function (name) { return this.get('chat.getRoomIdByNameOrId', { name: name }, true); };
-    ApiRocketChat.prototype.getRoomNameById = function (rid) { return this.getRoomName(rid); };
-    ApiRocketChat.prototype.getRoomName = function (rid) {
-        return __awaiter(this, void 0, void 0, function () {
-            var room;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.get('chat.getRoomNameById', { rid: rid }, true)];
-                    case 1:
-                        room = _a.sent();
-                        return [2 /*return*/, room.name];
-                }
-            });
-        });
-    };
-    ApiRocketChat.prototype.getRoomId = function (name) { return this.get('chat.find', { name: name }, true); };
-    ApiRocketChat.prototype.createDirectMessage = function (username) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.post('im.create', { username: username }, true)];
-                case 1: return [2 /*return*/, (_a.sent()).room];
-            }
-        }); });
-    };
-    /**
-     * Edit an existing message, replacing any attributes with those provided.
-     * The given message object should have the ID of an existing message.
-     */
-    ApiRocketChat.prototype.editMessage = function (message) {
-        return this.post('chat.update', { roomId: message.rid, msgId: message._id, text: message.msg });
-    };
-    /**
-     * Send a reaction to an existing message. Simple proxy for method call.
-     * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction
-     * @param messageId ID for a previously sent message
-     */
-    ApiRocketChat.prototype.setReaction = function (emoji, messageId) { return this.post('chat.react', { emoji: emoji, messageId: messageId }, true); };
-    // TODO fix this methods
-    ApiRocketChat.prototype.loadHistory = function (rid, lastUpdate) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.get('chat.syncMessages', { roomId: rid, lastUpdate: lastUpdate.toISOString() }, true)];
-                    case 1: return [2 /*return*/, (_a.sent()).result];
-                }
-            });
-        });
-    };
-    /** Exit a room the bot has joined */
-    ApiRocketChat.prototype.leaveRoom = function (rid) {
-        return this.post('rooms.leave', { rid: rid }).then(function () { return rid; });
-    };
-    /** Get information about a public group */
-    ApiRocketChat.prototype.channelInfo = function (query) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.get('channels.info', query, true)];
-                    case 1: return [2 /*return*/, (_a.sent()).channel];
-                }
-            });
-        });
-    };
-    /** Get information about a private group */
-    ApiRocketChat.prototype.privateInfo = function (query) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.get('groups.info', query, true)];
-                    case 1: return [2 /*return*/, (_a.sent()).group];
-                }
-            });
-        });
-    };
-    return ApiRocketChat;
-}(api_1.default));
-exports.default = ApiRocketChat;
-//# sourceMappingURL=RocketChat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js.map b/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js.map
deleted file mode 100644
index f2defdf..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"RocketChat.js","sourceRoot":"","sources":["../../../src/lib/api/RocketChat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n\t* @module ApiRocketChat\n\t* Provides a client for handling requests with Rocket.Chat's REST API\n\t*/\n\nexport type RID = string\nimport {\n\tIUserAPI,\n\tIMessage,\n\tIChannelAPI,\n\tIGroupAPI,\n\tIMessageReceipt\n} from '../../interfaces'\n\nimport ApiBase from './api'\n\n/** Defaults for user queries */\nexport const userFields = { name: 1, username: 1, status: 1, type: 1 }\n\n/** Query helpers for user collection requests */\nexport default class ApiRocketChat extends ApiBase {\n\n  get users (): any {\n    const self = this\n    return {\n      all (fields: any = userFields) { return self.get('users.list', { fields }).then((r: any) => r.users) },\n      allNames () { return self.get('users.list', { fields: { 'username': 1 } }).then((r: any) => r.users.map((u: IUserAPI) => u.username)) },\n      allIDs () { return self.get('users.list', { fields: { '_id': 1 } }).then((r: any) => r.users.map((u: IUserAPI) => u._id)) },\n      online (fields: any = userFields) { return self.get('users.list', { fields, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users) },\n      onlineNames () { return self.get('users.list', { fields: { 'username': 1 }, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users.map((u: IUserAPI) => u.username)) },\n      onlineIds () { return self.get('users.list', { fields: { '_id': 1 }, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users.map((u: IUserAPI) => u._id)) },\n      async info (username: string): Promise<IUserAPI> { return (await self.get('users.info', { username }, true)).user }\n    }\n  }\n\n  get rooms (): any {\n    const self = this\n    return {\n      info ({ rid }: any) { return self.get('rooms.info', { rid }, true) }\n    }\n  }\n\n\t// editMessage(message: IMessage) chat.update\n  joinRoom ({ rid }: any) { return this.post('channels.join', { roomId: rid }, true) }\n\n  async info () { return (await this.get('info', {}, true)).info }\n\t/**\n\t * Send a prepared message object (with pre-defined room ID).\n\t * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.\n\t */\n  async sendMessage (message: IMessage | string, rid: string): Promise<IMessageReceipt> { return (await this.post('chat.sendMessage', { message: this.prepareMessage(message, rid) }, true)).message }\n  getRoomIdByNameOrId (name: string): Promise<RID> { return this.get('chat.getRoomIdByNameOrId', { name }, true) }\n  getRoomNameById (rid: RID): Promise<string> { return this.getRoomName(rid) }\n  async getRoomName (rid: string): Promise<string> {\n    const room = await this.get('chat.getRoomNameById', { rid }, true)\n    return room.name\n  }\n  getRoomId (name: string) { return this.get('chat.find', { name }, true) }\n  async createDirectMessage (username: string) { return (await this.post('im.create', { username }, true)).room }\n\n/**\n * Edit an existing message, replacing any attributes with those provided.\n * The given message object should have the ID of an existing message.\n */\n  editMessage (message: IMessage): Promise<IMessageReceipt> {\n    return this.post('chat.update', { roomId: message.rid, msgId: message._id, text: message.msg })\n  }\n\t/**\n\t * Send a reaction to an existing message. Simple proxy for method call.\n\t * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction\n\t * @param messageId ID for a previously sent message\n\t */\n  setReaction (emoji: string, messageId: string) { return this.post('chat.react', { emoji, messageId }, true) }\n\n\t// TODO fix this methods\n\n  async loadHistory (rid: string, lastUpdate: Date): Promise<{\n    updated: IMessage[],\n    deleted: IMessage[]\n  }> {\n    return (await this.get('chat.syncMessages', { roomId: rid, lastUpdate: lastUpdate.toISOString() }, true)).result\n  }\n\t/** Exit a room the bot has joined */\n  leaveRoom (rid: string): Promise<RID> {\n    return this.post('rooms.leave', { rid }).then(() => rid)\n  }\n\n\t/** Get information about a public group */\n  async channelInfo (query: { roomName?: string, roomId?: string }) {\n    return (await this.get('channels.info', query, true)).channel as Promise<IChannelAPI>\n  }\n\n\t/** Get information about a private group */\n  async privateInfo (query: { roomName?: string, roomId?: string }) {\n    return (await this.get('groups.info', query, true)).group as Promise<IGroupAPI>\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/RocketChat.ts b/node_modules/@rocket.chat/sdk/lib/api/RocketChat.ts
new file mode 100644
index 0000000..3728806
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/api/RocketChat.ts
@@ -0,0 +1,97 @@
+/**
+	* @module ApiRocketChat
+	* Provides a client for handling requests with Rocket.Chat's REST API
+	*/
+
+export type RID = string
+import {
+	IUserAPI,
+	IMessage,
+	IChannelAPI,
+	IGroupAPI,
+	IMessageReceipt
+} from '../../interfaces'
+
+import ApiBase from './api'
+
+/** Defaults for user queries */
+export const userFields = { name: 1, username: 1, status: 1, type: 1 }
+
+/** Query helpers for user collection requests */
+export default class ApiRocketChat extends ApiBase {
+
+  get users (): any {
+    const self = this
+    return {
+      all (fields: any = userFields) { return self.get('users.list', { fields }).then((r: any) => r.users) },
+      allNames () { return self.get('users.list', { fields: { 'username': 1 } }).then((r: any) => r.users.map((u: IUserAPI) => u.username)) },
+      allIDs () { return self.get('users.list', { fields: { '_id': 1 } }).then((r: any) => r.users.map((u: IUserAPI) => u._id)) },
+      online (fields: any = userFields) { return self.get('users.list', { fields, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users) },
+      onlineNames () { return self.get('users.list', { fields: { 'username': 1 }, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users.map((u: IUserAPI) => u.username)) },
+      onlineIds () { return self.get('users.list', { fields: { '_id': 1 }, query: { 'status': { $ne: 'offline' } } }).then((r: any) => r.users.map((u: IUserAPI) => u._id)) },
+      async info (username: string): Promise<IUserAPI> { return (await self.get('users.info', { username }, true)).user }
+    }
+  }
+
+  get rooms (): any {
+    const self = this
+    return {
+      info ({ rid }: any) { return self.get('rooms.info', { rid }, true) }
+    }
+  }
+
+	// editMessage(message: IMessage) chat.update
+  joinRoom ({ rid }: any) { return this.post('channels.join', { roomId: rid }, true) }
+
+  async info () { return (await this.get('info', {}, true)).info }
+	/**
+	 * Send a prepared message object (with pre-defined room ID).
+	 * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.
+	 */
+  async sendMessage (message: IMessage | string, rid: string): Promise<IMessageReceipt> { return (await this.post('chat.sendMessage', { message: this.prepareMessage(message, rid) }, true)).message }
+  getRoomIdByNameOrId (name: string): Promise<RID> { return this.get('chat.getRoomIdByNameOrId', { name }, true) }
+  getRoomNameById (rid: RID): Promise<string> { return this.getRoomName(rid) }
+  async getRoomName (rid: string): Promise<string> {
+    const room = await this.get('chat.getRoomNameById', { rid }, true)
+    return room.name
+  }
+  getRoomId (name: string) { return this.get('chat.find', { name }, true) }
+  async createDirectMessage (username: string) { return (await this.post('im.create', { username }, true)).room }
+
+/**
+ * Edit an existing message, replacing any attributes with those provided.
+ * The given message object should have the ID of an existing message.
+ */
+  editMessage (message: IMessage): Promise<IMessageReceipt> {
+    return this.post('chat.update', { roomId: message.rid, msgId: message._id, text: message.msg })
+  }
+	/**
+	 * Send a reaction to an existing message. Simple proxy for method call.
+	 * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction
+	 * @param messageId ID for a previously sent message
+	 */
+  setReaction (emoji: string, messageId: string) { return this.post('chat.react', { emoji, messageId }, true) }
+
+	// TODO fix this methods
+
+  async loadHistory (rid: string, lastUpdate: Date): Promise<{
+    updated: IMessage[],
+    deleted: IMessage[]
+  }> {
+    return (await this.get('chat.syncMessages', { roomId: rid, lastUpdate: lastUpdate.toISOString() }, true)).result
+  }
+	/** Exit a room the bot has joined */
+  leaveRoom (rid: string): Promise<RID> {
+    return this.post('rooms.leave', { rid }).then(() => rid)
+  }
+
+	/** Get information about a public group */
+  async channelInfo (query: { roomName?: string, roomId?: string }) {
+    return (await this.get('channels.info', query, true)).channel as Promise<IChannelAPI>
+  }
+
+	/** Get information about a private group */
+  async privateInfo (query: { roomName?: string, roomId?: string }) {
+    return (await this.get('groups.info', query, true)).group as Promise<IGroupAPI>
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/api/api.d.ts b/node_modules/@rocket.chat/sdk/lib/api/api.d.ts
deleted file mode 100644
index 06daec4..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/api.d.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-import { ILogger, ILoginResultAPI, IAPIRequest, IMessage, ICredentials } from '../../interfaces';
-import { Message } from '../message';
-import { EventEmitter } from 'tiny-events';
-/** Check for existing login */
-/**
-    * Prepend protocol (or put back if removed from env settings for driver)
-    * Hard code endpoint prefix, because all syntax depends on this version
-    */
-/** Populate auth headers (from response data on login) */
-export interface IClient {
-    headers: any;
-    get(url: string, data: any, options?: any): Promise<any>;
-    post(url: string, data: any, options?: any): Promise<any>;
-    put(url: string, data: any, options?: any): Promise<any>;
-    delete(url: string, data: any, options?: any): Promise<any>;
-}
-export declare const regExpSuccess: RegExp;
-/**
-    * @module API
-    * Provides a base client for handling requests with generic Rocket.Chat's REST API
-    */
-export default class Api extends EventEmitter {
-    userId: string;
-    logger: ILogger;
-    client: IClient;
-    currentLogin: {
-        username: string;
-        userId: string;
-        authToken: string;
-        result: ILoginResultAPI;
-    } | null;
-    constructor({ client, host, logger }: any);
-    readonly username: string | null;
-    loggedIn(): boolean;
-    /**
-        * Do a request to an API endpoint.
-        * If it needs a token, login first (with defaults) to set auth headers.
-        * @param method   Request method GET | POST | PUT | DEL
-        * @param endpoint The API endpoint (including version) e.g. `chat.update`
-        * @param data     Payload for POST request to endpoint
-        * @param auth     Require auth headers for endpoint, default true
-        * @param ignore   Allows certain matching error messages to not count as errors
-        */
-    request: (method: "GET" | "POST" | "PUT" | "DELETE", endpoint: string, data?: any, auth?: boolean, ignore?: RegExp | undefined, options?: any) => Promise<any>;
-    /** Do a POST request to an API endpoint. */
-    post: IAPIRequest;
-    /** Do a GET request to an API endpoint. */
-    get: IAPIRequest;
-    /** Do a PUT request to an API endpoint. */
-    put: IAPIRequest;
-    /** Do a DELETE request to an API endpoint. */
-    del: IAPIRequest;
-    /** Check result data for success, allowing override to ignore some errors */
-    success(result: any, ignore?: RegExp): boolean;
-    login(credentials: ICredentials, args?: any): Promise<any>;
-    logout(): Promise<any>;
-    /**
-     * Structure message content, optionally addressing to room ID.
-     * Accepts message text string or a structured message object.
-     */
-    prepareMessage(content: string | IMessage, rid?: string, args?: any): Message;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/api/api.js b/node_modules/@rocket.chat/sdk/lib/api/api.js
deleted file mode 100644
index 5b7dc21..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/api.js
+++ /dev/null
@@ -1,311 +0,0 @@
-"use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var log_1 = require("../log");
-var message_1 = require("../message");
-var tiny_events_1 = require("tiny-events");
-var Client = /** @class */ (function () {
-    function Client(_a) {
-        var _b = _a.host, host = _b === void 0 ? 'http://localhost:3000' : _b;
-        this._headers = {};
-        this.host = host;
-    }
-    Object.defineProperty(Client.prototype, "headers", {
-        get: function () {
-            return __assign({ 'Content-Type': 'application/json' }, this._headers);
-        },
-        set: function (obj) {
-            this._headers = obj;
-        },
-        enumerable: true,
-        configurable: true
-    });
-    Client.prototype.getHeaders = function (options) {
-        return options && options.customHeaders ?
-            options.customHeaders :
-            this.headers;
-    };
-    Client.prototype.getBody = function (data) {
-        return data instanceof FormData ?
-            data :
-            JSON.stringify(data);
-    };
-    Client.prototype.get = function (url, data, options) {
-        return fetch(this.host + "/api/v1/" + encodeURI(url) + "?" + this.getParams(data), {
-            method: 'GET',
-            headers: this.getHeaders(options)
-        }).then(this.handle);
-    };
-    Client.prototype.post = function (url, data, options) {
-        return fetch(this.host + "/api/v1/" + encodeURI(url), {
-            method: 'POST',
-            body: this.getBody(data),
-            headers: this.getHeaders(options)
-        }).then(this.handle);
-    };
-    Client.prototype.put = function (url, data, options) {
-        return fetch(this.host + "/api/v1/" + encodeURI(url), {
-            method: 'PUT',
-            body: this.getBody(data),
-            headers: this.getHeaders(options)
-        }).then(this.handle);
-    };
-    Client.prototype.delete = function (url, data, options) {
-        return fetch(this.host + "/api/v1/" + encodeURI(url), {
-            method: 'DELETE',
-            body: this.getBody(data),
-            headers: this.getHeaders(options)
-        }).then(this.handle);
-    };
-    Client.prototype.handle = function (r) {
-        return __awaiter(this, void 0, void 0, function () {
-            var status, data;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        status = r.status;
-                        return [4 /*yield*/, r.json()];
-                    case 1:
-                        data = _a.sent();
-                        return [2 /*return*/, { status: status, data: data }];
-                }
-            });
-        });
-    };
-    Client.prototype.getParams = function (data) {
-        return Object.keys(data).map(function (k) {
-            return encodeURIComponent(k) + '=' + (typeof data[k] === 'object' ? encodeURIComponent(JSON.stringify(data[k])) : encodeURIComponent(data[k]));
-        }).join('&');
-    };
-    return Client;
-}());
-exports.regExpSuccess = /(?!([45][0-9][0-9]))\d{3}/;
-/**
-    * @module API
-    * Provides a base client for handling requests with generic Rocket.Chat's REST API
-    */
-var Api = /** @class */ (function (_super) {
-    __extends(Api, _super);
-    function Api(_a) {
-        var client = _a.client, host = _a.host, _b = _a.logger, logger = _b === void 0 ? log_1.logger : _b;
-        var _this = _super.call(this) || this;
-        _this.userId = '';
-        _this.currentLogin = null;
-        /**
-            * Do a request to an API endpoint.
-            * If it needs a token, login first (with defaults) to set auth headers.
-            * @param method   Request method GET | POST | PUT | DEL
-            * @param endpoint The API endpoint (including version) e.g. `chat.update`
-            * @param data     Payload for POST request to endpoint
-            * @param auth     Require auth headers for endpoint, default true
-            * @param ignore   Allows certain matching error messages to not count as errors
-            */
-        _this.request = function (method, endpoint, data, auth, ignore, options) {
-            if (data === void 0) { data = {}; }
-            if (auth === void 0) { auth = true; }
-            return __awaiter(_this, void 0, void 0, function () {
-                var result, _a, hasDataInsideResult, err_1;
-                return __generator(this, function (_b) {
-                    switch (_b.label) {
-                        case 0:
-                            this.logger && this.logger.debug("[API] " + method + " " + endpoint + ": " + JSON.stringify(data));
-                            _b.label = 1;
-                        case 1:
-                            _b.trys.push([1, 11, , 12]);
-                            if (auth && !this.loggedIn()) {
-                                throw new Error('');
-                            }
-                            result = void 0;
-                            _a = method;
-                            switch (_a) {
-                                case 'GET': return [3 /*break*/, 2];
-                                case 'PUT': return [3 /*break*/, 4];
-                                case 'DELETE': return [3 /*break*/, 6];
-                                case 'POST': return [3 /*break*/, 8];
-                            }
-                            return [3 /*break*/, 8];
-                        case 2: return [4 /*yield*/, this.client.get(endpoint, data, options)];
-                        case 3:
-                            result = _b.sent();
-                            return [3 /*break*/, 10];
-                        case 4: return [4 /*yield*/, this.client.put(endpoint, data, options)];
-                        case 5:
-                            result = _b.sent();
-                            return [3 /*break*/, 10];
-                        case 6: return [4 /*yield*/, this.client.delete(endpoint, data, options)];
-                        case 7:
-                            result = _b.sent();
-                            return [3 /*break*/, 10];
-                        case 8: return [4 /*yield*/, this.client.post(endpoint, data, options)];
-                        case 9:
-                            result = _b.sent();
-                            return [3 /*break*/, 10];
-                        case 10:
-                            if (!result)
-                                throw new Error("API " + method + " " + endpoint + " result undefined");
-                            if (!this.success(result, ignore))
-                                throw result;
-                            this.logger && this.logger.debug("[API] " + method + " " + endpoint + " result " + result.status);
-                            hasDataInsideResult = result && !result.data;
-                            return [2 /*return*/, (method === 'DELETE') && hasDataInsideResult ? result : result.data];
-                        case 11:
-                            err_1 = _b.sent();
-                            this.logger && this.logger.error("[API] POST error(" + endpoint + "): " + JSON.stringify(err_1));
-                            throw err_1;
-                        case 12: return [2 /*return*/];
-                    }
-                });
-            });
-        };
-        /** Do a POST request to an API endpoint. */
-        _this.post = function (endpoint, data, auth, ignore, options) {
-            if (options === void 0) { options = {}; }
-            return _this.request('POST', endpoint, data, auth, ignore, options);
-        };
-        /** Do a GET request to an API endpoint. */
-        _this.get = function (endpoint, data, auth, ignore, options) {
-            if (options === void 0) { options = {}; }
-            return _this.request('GET', endpoint, data, auth, ignore, options);
-        };
-        /** Do a PUT request to an API endpoint. */
-        _this.put = function (endpoint, data, auth, ignore, options) {
-            if (options === void 0) { options = {}; }
-            return _this.request('PUT', endpoint, data, auth, ignore, options);
-        };
-        /** Do a DELETE request to an API endpoint. */
-        _this.del = function (endpoint, data, auth, ignore, options) {
-            if (options === void 0) { options = {}; }
-            return _this.request('DELETE', endpoint, data, auth, ignore, options);
-        };
-        _this.client = client || new Client({ host: host });
-        _this.logger = log_1.logger;
-        return _this;
-    }
-    Object.defineProperty(Api.prototype, "username", {
-        get: function () {
-            return this.currentLogin && this.currentLogin.username;
-        },
-        enumerable: true,
-        configurable: true
-    });
-    Api.prototype.loggedIn = function () {
-        return Object.keys(this.currentLogin || {}).every(function (e) { return e; });
-    };
-    /** Check result data for success, allowing override to ignore some errors */
-    Api.prototype.success = function (result, ignore) {
-        return (typeof result.status === 'undefined' ||
-            (result.status && exports.regExpSuccess.test(result.status)) ||
-            (result.status && ignore && ignore.test(result.status))) ? true : false;
-    };
-    Api.prototype.login = function (credentials, args) {
-        return __awaiter(this, void 0, void 0, function () {
-            var data;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.post('login', __assign({}, credentials, args))];
-                    case 1:
-                        data = (_a.sent()).data;
-                        this.userId = data.userId;
-                        this.currentLogin = {
-                            username: data.me.username,
-                            userId: data.userId,
-                            authToken: data.authToken,
-                            result: data
-                        };
-                        this.client.headers = {
-                            'X-Auth-Token': data.authToken,
-                            'X-User-Id': data.userId
-                        };
-                        return [2 /*return*/, data];
-                }
-            });
-        });
-    };
-    Api.prototype.logout = function () {
-        return __awaiter(this, void 0, void 0, function () {
-            var result;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        if (!this.currentLogin) {
-                            return [2 /*return*/, null];
-                        }
-                        return [4 /*yield*/, this.post('logout', {}, true)];
-                    case 1:
-                        result = _a.sent();
-                        this.userId = '';
-                        this.currentLogin = null;
-                        return [2 /*return*/, result];
-                }
-            });
-        });
-    };
-    /**
-     * Structure message content, optionally addressing to room ID.
-     * Accepts message text string or a structured message object.
-     */
-    Api.prototype.prepareMessage = function (content, rid, args) {
-        return new message_1.Message(content, __assign({ rid: rid, roomId: rid }, args));
-    };
-    return Api;
-}(tiny_events_1.EventEmitter));
-exports.default = Api;
-//# sourceMappingURL=api.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/api.js.map b/node_modules/@rocket.chat/sdk/lib/api/api.js.map
deleted file mode 100644
index 4204aa0..0000000
--- a/node_modules/@rocket.chat/sdk/lib/api/api.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../src/lib/api/api.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger as Logger } from '../log'\n\nimport {\n\tILogger,\n\tILoginResultAPI,\n\tIAPIRequest,\n\tIMessage,\n\tICredentials\n} from '../../interfaces'\n\nimport { Message } from '../message'\n\nimport { EventEmitter } from 'tiny-events'\n\n/** Check for existing login */\n// export function loggedIn () {\n//   return (currentLogin !== null)\n// }\n\n/**\n\t* Prepend protocol (or put back if removed from env settings for driver)\n\t* Hard code endpoint prefix, because all syntax depends on this version\n\t*/\n// export const url = `${(host.indexOf('http') === -1) ? host.replace(/^(\\/\\/)?/, 'http://') : host}/api/v1/`\n\n/** Populate auth headers (from response data on login) */\n// export function setAuth (authData: {authToken: string, userId: string}) {\n//   client.defaults.headers.common['X-Auth-Token'] = authData.authToken\n//   client.defaults.headers.common['X-User-Id'] = authData.userId\n// }\n\n// /** Clear headers so they can't be used without logging in again */\n// export function clearHeaders () {\n//   delete client.defaults.headers.common['X-Auth-Token']\n//   delete client.defaults.headers.common['X-User-Id']\n// }\n\n// /**\n// \t* Login a user for further API calls\n// \t* Result should come back with a token, to authorise following requests.\n// \t* Use env default credentials, unless overridden by login arguments.\n// \t*/\n// export async function login (user: ICredentialsAPI = { username, password }) {\n//   this.logger.info(`[API] Logging in ${user.username}`)\n//   if (currentLogin !== null) {\n//     this.logger.debug(`[API] Already logged in`)\n//     if (currentLogin.username === user.username) return currentLogin.result\n//     else await logout()\n//   }\n//   const result = (await this.post('login', user, false) as ILoginResultAPI)\n//   if (result && result.data && result.data.authToken) {\n//     currentLogin = {\n//       result: result, // keep to return if login requested again for same user\n//       username: user.username, // keep to compare with following login attempt\n//       authToken: result.data.authToken,\n//       userId: result.data.userId\n//     }\n//     setAuth(currentLogin)\n//     this.logger.info(`[API] Logged in ID ${currentLogin.userId}`)\n//     return result\n//   } else {\n//     throw new Error(`[API] Login failed for ${user.username}`)\n//   }\n// }\n\n// /** Logout a user at end of API calls */\n// export function logout () {\n//   if (currentLogin === null) {\n//     this.logger.debug(`[API] Already logged out`)\n//     return Promise.resolve()\n//   }\n//   this.logger.info(`[API] Logging out ${ currentLogin.username }`)\n//   return this.get('logout', null, true).then(() => {\n//     clearHeaders()\n//     currentLogin = null\n//   })\n// }\n\nexport interface IClient {\n  headers: any\n  get (url: string, data: any, options?: any): Promise<any>\n  post (url: string, data: any, options?: any): Promise<any>\n  put (url: string, data: any, options?: any): Promise<any>\n  delete (url: string, data: any, options?: any): Promise<any>\n}\n\nclass Client implements IClient {\n  host: string\n\n  _headers: any = {}\n\n  constructor ({ host = 'http://localhost:3000' }: any) {\n    this.host = host\n  }\n\n  set headers (obj: any) {\n    this._headers = obj\n  }\n  get headers (): any {\n    return {\n      'Content-Type': 'application/json',\n      ...this._headers\n    }\n  }\n\n  getHeaders (options?: any) {\n    return options && options.customHeaders ?\n      options.customHeaders :\n      this.headers\n  }\n\n  getBody (data: any) {\n    return data instanceof FormData ?\n      data :\n      JSON.stringify(data)\n  }\n\n  get (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}?${this.getParams(data)}`, {\n      method: 'GET',\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  post (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'POST',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  put (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'PUT',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n\n  delete (url: string, data?: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'DELETE',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  private async handle (r: any) {\n    const { status } = r\n    const data = await r.json()\n\n    return { status, data }\n\n  }\n  private getParams (data: any) {\n    return Object.keys(data).map(function (k) {\n      return encodeURIComponent(k) + '=' + (typeof data[k] === 'object' ? encodeURIComponent(JSON.stringify(data[k])) : encodeURIComponent(data[k]))\n    }).join('&')\n  }\n}\n\nexport const regExpSuccess = /(?!([45][0-9][0-9]))\\d{3}/\n\n/**\n\t* @module API\n\t* Provides a base client for handling requests with generic Rocket.Chat's REST API\n\t*/\n\nexport default class Api extends EventEmitter {\n  userId: string = ''\n  logger: ILogger\n  client: IClient\n  currentLogin: {\n    username: string,\n    userId: string,\n    authToken: string,\n    result: ILoginResultAPI\n  } | null = null\n\n  constructor ({ client, host, logger = Logger }: any) {\n    super()\n    this.client = client || new Client({ host } as any)\n    this.logger = Logger\n  }\n\n  get username () {\n    return this.currentLogin && this.currentLogin.username\n  }\n\n  loggedIn () {\n    return Object.keys(this.currentLogin || {} as any).every((e: any) => e)\n  }\n/**\n\t* Do a request to an API endpoint.\n\t* If it needs a token, login first (with defaults) to set auth headers.\n\t* @param method   Request method GET | POST | PUT | DEL\n\t* @param endpoint The API endpoint (including version) e.g. `chat.update`\n\t* @param data     Payload for POST request to endpoint\n\t* @param auth     Require auth headers for endpoint, default true\n\t* @param ignore   Allows certain matching error messages to not count as errors\n\t*/\n  request = async (\n\t\tmethod: 'POST' | 'GET' | 'PUT' | 'DELETE',\n\t\tendpoint: string,\n\t\tdata: any = {},\n\t\tauth: boolean = true,\n    ignore?: RegExp,\n    options?: any\n\t) => {\n    this.logger && this.logger.debug(`[API] ${ method } ${ endpoint }: ${ JSON.stringify(data) }`)\n    try {\n      if (auth && !this.loggedIn()) {\n        throw new Error('')\n      }\n      let result\n      switch (method) {\n        case 'GET': result = await this.client.get(endpoint, data, options); break\n        case 'PUT': result = await this.client.put(endpoint, data, options); break\n        case 'DELETE': result = await this.client.delete(endpoint, data, options); break\n        default:\n        case 'POST': result = await this.client.post(endpoint, data, options); break\n      }\n      if (!result) throw new Error(`API ${ method } ${ endpoint } result undefined`)\n      if (!this.success(result, ignore)) throw result\n      this.logger && this.logger.debug(`[API] ${method} ${endpoint} result ${result.status}`)\n      const hasDataInsideResult = result && !result.data\n      return (method === 'DELETE') && hasDataInsideResult ? result : result.data\n    } catch (err) {\n      this.logger && this.logger.error(`[API] POST error(${ endpoint }): ${ JSON.stringify(err) }`)\n      throw err\n    }\n  }\n\t/** Do a POST request to an API endpoint. */\n  post: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('POST', endpoint, data, auth, ignore, options)\n\n\t/** Do a GET request to an API endpoint. */\n  get: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('GET', endpoint, data, auth, ignore, options)\n\n\t/** Do a PUT request to an API endpoint. */\n  put: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('PUT', endpoint, data, auth, ignore, options)\n\n\t/** Do a DELETE request to an API endpoint. */\n  del: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('DELETE', endpoint, data, auth, ignore, options)\n\n\t/** Check result data for success, allowing override to ignore some errors */\n  success (result: any, ignore?: RegExp) {\n    return (\n\t\t\ttypeof result.status === 'undefined' ||\n\t\t\t(result.status && regExpSuccess.test(result.status)) ||\n\t\t\t(result.status && ignore && ignore.test(result.status))\n\t\t) ? true : false\n  }\n\n  async login (credentials: ICredentials, args?: any): Promise<any> {\n    const { data } = await this.post('login', { ...credentials, ...args })\n    this.userId = data.userId\n    this.currentLogin = {\n      username: data.me.username,\n      userId: data.userId,\n      authToken: data.authToken,\n      result: data\n    }\n    this.client.headers = {\n      'X-Auth-Token': data.authToken,\n      'X-User-Id': data.userId\n    }\n    return data\n  }\n  async logout () {\n    if (!this.currentLogin) {\n      return null\n    }\n    const result = await this.post('logout', {}, true)\n    this.userId = ''\n    this.currentLogin = null\n    return result\n  }\n/**\n * Structure message content, optionally addressing to room ID.\n * Accepts message text string or a structured message object.\n */\n  prepareMessage (\n\tcontent: string | IMessage,\n\trid?: string,\n\targs?: any\n): Message {\n    return new Message(content, { rid, roomId: rid, ...args })\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/api/api.spec.ts b/node_modules/@rocket.chat/sdk/lib/api/api.spec.ts
new file mode 100644
index 0000000..f8a7d0e
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/api/api.spec.ts
@@ -0,0 +1,109 @@
+import 'mocha'
+import { expect } from 'chai'
+import { silence } from '../log'
+const initEnv = process.env // store configs to restore after tests
+import {
+  botUser,
+  mockUser,
+  mockVisitor,
+  mockSurvey,
+  mockVisitorNavigation,
+  mockOfflineMessage,
+  mockCustomField,
+  mockCustomFields
+} from '../../utils/config'
+import BotDriver from '../clients/Bot'
+import ClientApi from './RocketChat'
+import LivechatApi from './Livechat'
+import * as settings from '../settings'
+import { IMessage } from '../../interfaces'
+global.fetch = require('node-fetch')
+global.FormData = require('form-data')
+// silence() // suppress log during tests (disable this while developing tests)
+
+const clientApi = new ClientApi({})
+const livechatApi = new LivechatApi({})
+const driver = new BotDriver({})
+
+// livechat data, to be populated in before hooks
+let token = settings.token
+let department = settings.department
+let room: any
+let rid: any
+let newMessage: any
+let editMessage: any
+let pageInfo: any
+let email = 'sample@rocket.chat'
+
+describe('clientApi', () => {
+  after(() => process.env = initEnv)
+  afterEach(() => clientApi.logout())
+  describe('.success', () => {
+    it('returns true when result status is 200', () => {
+      expect(clientApi.success({ status: 200 })).to.equal(true)
+    })
+    it('returns true when success is 300', () => {
+      expect(clientApi.success({ status: 300 })).to.equal(true)
+    })
+    it('returns false when result status is 400', () => {
+      expect(clientApi.success({ status: 401 })).to.equal(false)
+    })
+    it('returns false when success is 500', () => {
+      expect(clientApi.success({ status: 500 })).to.equal(false)
+    })
+    it('returns true if status is not given', () => {
+      expect(clientApi.success({})).to.equal(true)
+    })
+  })
+  describe('.get', () => {
+    before(() => clientApi.login({ username: settings.username, password: settings.password }))
+    it('returns data from basic call without auth', async () => {
+      const server = await clientApi.info()
+      const result = await clientApi.get('info', {}, false)
+      expect(result).to.eql({
+        info: { version: server.version },
+        success: true
+      })
+    })
+    it('returns data from complex calls with auth and parameters', async () => {
+      await clientApi.login({ username: settings.username, password: settings.password })
+      const result = await clientApi.get('users.list', {
+        fields: { 'username': 1 },
+        query: { username: botUser.username, type: { $in: ['user', 'bot'] } }
+      }, true)
+      const users = result.users.map((user: any) => user.username)
+      expect(users).to.include(botUser.username, mockUser.username)
+    })
+    after(() => driver.logout())
+  })
+  describe('.login', () => {
+    before(async () => {
+      await driver.login({ username: settings.username, password: settings.password })
+    })
+    it('logs in with the default user without arguments', async () => {
+      const login = await clientApi.login({ username: settings.username, password: settings.password })
+      expect(login.userId).to.equal(clientApi.userId)
+    })
+    it('logs in with another user if given credentials', async () => {
+      await clientApi.login({
+        username: mockUser.username,
+        password: mockUser.password
+      })
+      const mockInfo = await clientApi.get('users.info', { username: mockUser.username })
+      expect(clientApi.currentLogin && clientApi.currentLogin.userId).to.equal(mockInfo.user._id)
+    })
+    it('stores logged in user result', async () => {
+      await clientApi.login({ username: settings.username, password: settings.password })
+      expect(clientApi.currentLogin && clientApi.currentLogin.userId).to.equal(driver.userId)
+    })
+    after(() => driver.logout())
+  })
+  describe('.logout', () => {
+    it('resets auth headers and clears user ID', async () => {
+      await clientApi.login({ username: settings.username, password: settings.password }).catch(e => console.log('login error', e))
+      await clientApi.logout().catch(e => console.log('logout error', e))
+      expect(clientApi.currentLogin).to.eql(null)
+    })
+  })
+
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/api/api.ts b/node_modules/@rocket.chat/sdk/lib/api/api.ts
new file mode 100644
index 0000000..b195d2b
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/api/api.ts
@@ -0,0 +1,287 @@
+import { logger as Logger } from '../log'
+
+import {
+	ILogger,
+	ILoginResultAPI,
+	IAPIRequest,
+	IMessage,
+	ICredentials
+} from '../../interfaces'
+
+import { Message } from '../message'
+
+import { EventEmitter } from 'tiny-events'
+
+/** Check for existing login */
+// export function loggedIn () {
+//   return (currentLogin !== null)
+// }
+
+/**
+	* Prepend protocol (or put back if removed from env settings for driver)
+	* Hard code endpoint prefix, because all syntax depends on this version
+	*/
+// export const url = `${(host.indexOf('http') === -1) ? host.replace(/^(\/\/)?/, 'http://') : host}/api/v1/`
+
+/** Populate auth headers (from response data on login) */
+// export function setAuth (authData: {authToken: string, userId: string}) {
+//   client.defaults.headers.common['X-Auth-Token'] = authData.authToken
+//   client.defaults.headers.common['X-User-Id'] = authData.userId
+// }
+
+// /** Clear headers so they can't be used without logging in again */
+// export function clearHeaders () {
+//   delete client.defaults.headers.common['X-Auth-Token']
+//   delete client.defaults.headers.common['X-User-Id']
+// }
+
+// /**
+// 	* Login a user for further API calls
+// 	* Result should come back with a token, to authorise following requests.
+// 	* Use env default credentials, unless overridden by login arguments.
+// 	*/
+// export async function login (user: ICredentialsAPI = { username, password }) {
+//   this.logger.info(`[API] Logging in ${user.username}`)
+//   if (currentLogin !== null) {
+//     this.logger.debug(`[API] Already logged in`)
+//     if (currentLogin.username === user.username) return currentLogin.result
+//     else await logout()
+//   }
+//   const result = (await this.post('login', user, false) as ILoginResultAPI)
+//   if (result && result.data && result.data.authToken) {
+//     currentLogin = {
+//       result: result, // keep to return if login requested again for same user
+//       username: user.username, // keep to compare with following login attempt
+//       authToken: result.data.authToken,
+//       userId: result.data.userId
+//     }
+//     setAuth(currentLogin)
+//     this.logger.info(`[API] Logged in ID ${currentLogin.userId}`)
+//     return result
+//   } else {
+//     throw new Error(`[API] Login failed for ${user.username}`)
+//   }
+// }
+
+// /** Logout a user at end of API calls */
+// export function logout () {
+//   if (currentLogin === null) {
+//     this.logger.debug(`[API] Already logged out`)
+//     return Promise.resolve()
+//   }
+//   this.logger.info(`[API] Logging out ${ currentLogin.username }`)
+//   return this.get('logout', null, true).then(() => {
+//     clearHeaders()
+//     currentLogin = null
+//   })
+// }
+
+export interface IClient {
+  headers: any
+  get (url: string, data: any, options?: any): Promise<any>
+  post (url: string, data: any, options?: any): Promise<any>
+  put (url: string, data: any, options?: any): Promise<any>
+  delete (url: string, data: any, options?: any): Promise<any>
+}
+
+class Client implements IClient {
+  host: string
+
+  _headers: any = {}
+
+  constructor ({ host = 'http://localhost:3000' }: any) {
+    this.host = host
+  }
+
+  set headers (obj: any) {
+    this._headers = obj
+  }
+  get headers (): any {
+    return {
+      'Content-Type': 'application/json',
+      ...this._headers
+    }
+  }
+
+  getHeaders (options?: any) {
+    return options && options.customHeaders ?
+      options.customHeaders :
+      this.headers
+  }
+
+  getBody (data: any) {
+    return data instanceof FormData ?
+      data :
+      JSON.stringify(data)
+  }
+
+  get (url: string, data: any, options?: any): Promise<any> {
+    return fetch(`${this.host}/api/v1/${encodeURI(url)}?${this.getParams(data)}`, {
+      method: 'GET',
+      headers: this.getHeaders(options)
+    }).then(this.handle)
+  }
+  post (url: string, data: any, options?: any): Promise<any> {
+    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {
+      method: 'POST',
+      body: this.getBody(data),
+      headers: this.getHeaders(options)
+    }).then(this.handle)
+  }
+  put (url: string, data: any, options?: any): Promise<any> {
+    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {
+      method: 'PUT',
+      body: this.getBody(data),
+      headers: this.getHeaders(options)
+    }).then(this.handle)
+  }
+
+  delete (url: string, data?: any, options?: any): Promise<any> {
+    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {
+      method: 'DELETE',
+      body: this.getBody(data),
+      headers: this.getHeaders(options)
+    }).then(this.handle)
+  }
+  private async handle (r: any) {
+    const { status } = r
+    const data = await r.json()
+
+    return { status, data }
+
+  }
+  private getParams (data: any) {
+    return Object.keys(data).map(function (k) {
+      return encodeURIComponent(k) + '=' + (typeof data[k] === 'object' ? encodeURIComponent(JSON.stringify(data[k])) : encodeURIComponent(data[k]))
+    }).join('&')
+  }
+}
+
+export const regExpSuccess = /(?!([45][0-9][0-9]))\d{3}/
+
+/**
+	* @module API
+	* Provides a base client for handling requests with generic Rocket.Chat's REST API
+	*/
+
+export default class Api extends EventEmitter {
+  userId: string = ''
+  logger: ILogger
+  client: IClient
+  currentLogin: {
+    username: string,
+    userId: string,
+    authToken: string,
+    result: ILoginResultAPI
+  } | null = null
+
+  constructor ({ client, host, logger = Logger }: any) {
+    super()
+    this.client = client || new Client({ host } as any)
+    this.logger = Logger
+  }
+
+  get username () {
+    return this.currentLogin && this.currentLogin.username
+  }
+
+  loggedIn () {
+    return Object.keys(this.currentLogin || {} as any).every((e: any) => e)
+  }
+/**
+	* Do a request to an API endpoint.
+	* If it needs a token, login first (with defaults) to set auth headers.
+	* @param method   Request method GET | POST | PUT | DEL
+	* @param endpoint The API endpoint (including version) e.g. `chat.update`
+	* @param data     Payload for POST request to endpoint
+	* @param auth     Require auth headers for endpoint, default true
+	* @param ignore   Allows certain matching error messages to not count as errors
+	*/
+  request = async (
+		method: 'POST' | 'GET' | 'PUT' | 'DELETE',
+		endpoint: string,
+		data: any = {},
+		auth: boolean = true,
+    ignore?: RegExp,
+    options?: any
+	) => {
+    this.logger && this.logger.debug(`[API] ${ method } ${ endpoint }: ${ JSON.stringify(data) }`)
+    try {
+      if (auth && !this.loggedIn()) {
+        throw new Error('')
+      }
+      let result
+      switch (method) {
+        case 'GET': result = await this.client.get(endpoint, data, options); break
+        case 'PUT': result = await this.client.put(endpoint, data, options); break
+        case 'DELETE': result = await this.client.delete(endpoint, data, options); break
+        default:
+        case 'POST': result = await this.client.post(endpoint, data, options); break
+      }
+      if (!result) throw new Error(`API ${ method } ${ endpoint } result undefined`)
+      if (!this.success(result, ignore)) throw result
+      this.logger && this.logger.debug(`[API] ${method} ${endpoint} result ${result.status}`)
+      const hasDataInsideResult = result && !result.data
+      return (method === 'DELETE') && hasDataInsideResult ? result : result.data
+    } catch (err) {
+      this.logger && this.logger.error(`[API] POST error(${ endpoint }): ${ JSON.stringify(err) }`)
+      throw err
+    }
+  }
+	/** Do a POST request to an API endpoint. */
+  post: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('POST', endpoint, data, auth, ignore, options)
+
+	/** Do a GET request to an API endpoint. */
+  get: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('GET', endpoint, data, auth, ignore, options)
+
+	/** Do a PUT request to an API endpoint. */
+  put: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('PUT', endpoint, data, auth, ignore, options)
+
+	/** Do a DELETE request to an API endpoint. */
+  del: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('DELETE', endpoint, data, auth, ignore, options)
+
+	/** Check result data for success, allowing override to ignore some errors */
+  success (result: any, ignore?: RegExp) {
+    return (
+			typeof result.status === 'undefined' ||
+			(result.status && regExpSuccess.test(result.status)) ||
+			(result.status && ignore && ignore.test(result.status))
+		) ? true : false
+  }
+
+  async login (credentials: ICredentials, args?: any): Promise<any> {
+    const { data } = await this.post('login', { ...credentials, ...args })
+    this.userId = data.userId
+    this.currentLogin = {
+      username: data.me.username,
+      userId: data.userId,
+      authToken: data.authToken,
+      result: data
+    }
+    this.client.headers = {
+      'X-Auth-Token': data.authToken,
+      'X-User-Id': data.userId
+    }
+    return data
+  }
+  async logout () {
+    if (!this.currentLogin) {
+      return null
+    }
+    const result = await this.post('logout', {}, true)
+    this.userId = ''
+    this.currentLogin = null
+    return result
+  }
+/**
+ * Structure message content, optionally addressing to room ID.
+ * Accepts message text string or a structured message object.
+ */
+  prepareMessage (
+	content: string | IMessage,
+	rid?: string,
+	args?: any
+): Message {
+    return new Message(content, { rid, roomId: rid, ...args })
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Bot.d.ts b/node_modules/@rocket.chat/sdk/lib/clients/Bot.d.ts
deleted file mode 100644
index 636d639..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Bot.d.ts
+++ /dev/null
@@ -1,93 +0,0 @@
-import Rocketchat from './Rocketchat';
-import { ISocketOptions, IRespondOptions, ICallback, IMessageCallback, IMessage, ISubscription, IMessageReceipt } from '../../interfaces';
-import { RID } from '../api/RocketChat';
-export default class BotClient extends Rocketchat {
-    integrationId: string;
-    lastReadTime: Date;
-    joinedIds: string[];
-    messages: ISubscription | null;
-    constructor({ allPublic, integrationId, cachedMethods, ...config }: any);
-    /**
-     * Initialise socket instance with given options or defaults.
-     * Proxies the DDP module socket connection. Resolves with socket when open.
-     * Accepts callback following error-first-pattern.
-     * Error returned or promise rejected on timeout.
-     * @example <caption>Use with callback</caption>
-     *  import driver from '@rocket.chat/sdk/bot'
-     *  driver.connect({}, (err) => {
-     *    if (err) throw err
-     *    else console.log('connected')
-     *  })
-     * @example <caption>Using promise</caption>
-     *  import driver from '@rocket.chat/sdk/bot'
-     *  driver.connect()
-     *    .then(() => console.log('connected'))
-     *    .catch((err) => console.error(err))
-     */
-    connect(options: ISocketOptions, callback?: ICallback): Promise<any>;
-    unsubscribeAll(): Promise<any>;
-    /** Begin subscription to user's "global" message stream. Will only allow one. */
-    subscribeToMessages(): Promise<ISubscription>;
-    /**
-     * Add callback for changes in the message stream, subscribing if not already.
-     * This can be called directly for custom extensions, but for most usage (e.g.
-     * for bots) the respondToMessages is more useful to only receive messages
-     * matching configuration.
-     *
-     * @param callback Function called with every change in subscriptions.
-     *  - Uses error-first callback pattern
-     *  - Second argument is the changed message
-     *  - Third argument is additional attributes, such as `roomType`
-     */
-    reactToMessages(callback: IMessageCallback, debug?: string): Promise<void>;
-    /**
-     * Applies `reactToMessages` with some filtering of messages based on config.
-     * If no rooms are joined at this point, it will attempt to join now based on
-     * environment config, otherwise it might not receive any messages. It doesn't
-     * matter that this happens asynchronously because joined rooms can change after
-     * the subscription is set up.
-     *
-     * @param callback Function called after filters run on subscription events.
-     *  - Uses error-first callback pattern
-     *  - Second argument is the changed item
-     *  - Third argument is additional attributes, such as `roomType`
-     * @param options Sets filters for different event/message types.
-     */
-    respondToMessages(callback: IMessageCallback, options?: IRespondOptions): Promise<void>;
-    /** Get ID for a room by name (or ID). */
-    getRoomId(name: string): Promise<RID>;
-    /** Join the bot into a room by its name or ID */
-    joinRoom({ rid }: any): Promise<RID>;
-    /** Exit a room the bot has joined */
-    leaveRoom(room: string): Promise<RID>;
-    /** Join a set of rooms by array of names or IDs */
-    joinRooms(rooms: string[]): Promise<RID[]>;
-    /**
-     * Prepare and send string/s to specified room ID.
-     * @param content Accepts message text string or array of strings.
-     * @param roomId  ID of the target room to use in send.
-     * @todo Returning one or many gets complicated with type checking not allowing
-     *       use of a property because result may be array, when you know it's not.
-     *       Solution would probably be to always return an array, even for single
-     *       send. This would be a breaking change, should hold until major version.
-     */
-    sendToRoomId(content: IMessage | string | string[], roomId: string): Promise<IMessageReceipt[] | IMessageReceipt>;
-    /**
-     * Prepare and send string/s to specified room name (or ID).
-     * @param content Accepts message text string or array of strings.
-     * @param room    A name (or ID) to resolve as ID to use in send.
-     */
-    sendToRoom(content: IMessage | string | string[], room: string): Promise<IMessageReceipt[] | IMessageReceipt>;
-    /**
-     * Prepare and send string/s to a user in a DM.
-     * @param content   Accepts message text string or array of strings.
-     * @param username  Name to create (or get) DM for room ID to use in send.
-     */
-    sendDirectToUser(content: IMessage | string | string[], username: string): Promise<IMessageReceipt[] | IMessageReceipt>;
-    /**
-     * Get ID for a DM room by its recipient's name.
-     * Will create a DM (with the bot) if it doesn't exist already.
-     * @todo test why create resolves with object instead of simply ID
-     */
-    getDirectMessageRoomId(username: string): Promise<RID>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Bot.js b/node_modules/@rocket.chat/sdk/lib/clients/Bot.js
deleted file mode 100644
index b2c6985..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Bot.js
+++ /dev/null
@@ -1,405 +0,0 @@
-"use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var log_1 = require("../log");
-var Rocketchat_1 = __importDefault(require("./Rocketchat"));
-var mem_1 = __importDefault(require("mem"));
-var MY_MESSAGES = '__my_messages__';
-var TOPIC_MESSAGES = 'stream-room-messages';
-var BotClient = /** @class */ (function (_super) {
-    __extends(BotClient, _super);
-    function BotClient(_a) {
-        var _b = _a.allPublic, allPublic = _b === void 0 ? false : _b, integrationId = _a.integrationId, _c = _a.cachedMethods, cachedMethods = _c === void 0 ? ['channelInfo', 'privateInfo', 'getRoomIdByNameOrId', 'getRoomId', 'getRoomName', 'getRoomNameById', 'getDirectMessageRoomId'] : _c, config = __rest(_a, ["allPublic", "integrationId", "cachedMethods"]);
-        var _this = _super.call(this, __assign({}, config, { allPublic: allPublic })) || this;
-        _this.lastReadTime = new Date(-8640000000000000);
-        _this.joinedIds = [];
-        _this.messages = null;
-        _this.integrationId = integrationId;
-        cachedMethods.forEach(function (name) {
-            if (_this[name]) {
-                _this[name] = mem_1.default(_this[name].bind(_this), { maxAge: 60 * 60 * 1000 }).bind(_this);
-            }
-        });
-        return _this;
-    }
-    /**
-     * Initialise socket instance with given options or defaults.
-     * Proxies the DDP module socket connection. Resolves with socket when open.
-     * Accepts callback following error-first-pattern.
-     * Error returned or promise rejected on timeout.
-     * @example <caption>Use with callback</caption>
-     *  import driver from '@rocket.chat/sdk/bot'
-     *  driver.connect({}, (err) => {
-     *    if (err) throw err
-     *    else console.log('connected')
-     *  })
-     * @example <caption>Using promise</caption>
-     *  import driver from '@rocket.chat/sdk/bot'
-     *  driver.connect()
-     *    .then(() => console.log('connected'))
-     *    .catch((err) => console.error(err))
-     */
-    BotClient.prototype.connect = function (options, callback) {
-        return __awaiter(this, void 0, void 0, function () {
-            var result, _a, _b, error_1;
-            return __generator(this, function (_c) {
-                switch (_c.label) {
-                    case 0:
-                        _c.trys.push([0, 4, , 5]);
-                        return [4 /*yield*/, _super.prototype.connect.call(this, options)];
-                    case 1:
-                        result = _c.sent();
-                        if (!callback) return [3 /*break*/, 3];
-                        _a = callback;
-                        _b = [null];
-                        return [4 /*yield*/, this.socket];
-                    case 2:
-                        _a.apply(void 0, _b.concat([(_c.sent())]));
-                        _c.label = 3;
-                    case 3: return [2 /*return*/, result];
-                    case 4:
-                        error_1 = _c.sent();
-                        if (callback) {
-                            callback(error_1, this);
-                        }
-                        return [2 /*return*/, Promise.reject(error_1)];
-                    case 5: return [2 /*return*/];
-                }
-            });
-        });
-    };
-    BotClient.prototype.unsubscribeAll = function () {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                delete this.messages;
-                return [2 /*return*/, _super.prototype.unsubscribeAll.call(this)];
-            });
-        });
-    };
-    /** Begin subscription to user's "global" message stream. Will only allow one. */
-    BotClient.prototype.subscribeToMessages = function () {
-        return __awaiter(this, void 0, void 0, function () {
-            var _a;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0:
-                        if (!!this.messages) return [3 /*break*/, 2];
-                        _a = this;
-                        return [4 /*yield*/, this.subscribe(TOPIC_MESSAGES, MY_MESSAGES)];
-                    case 1:
-                        _a.messages = _b.sent();
-                        _b.label = 2;
-                    case 2: return [2 /*return*/, this.messages];
-                }
-            });
-        });
-    };
-    /**
-     * Add callback for changes in the message stream, subscribing if not already.
-     * This can be called directly for custom extensions, but for most usage (e.g.
-     * for bots) the respondToMessages is more useful to only receive messages
-     * matching configuration.
-     *
-     * @param callback Function called with every change in subscriptions.
-     *  - Uses error-first callback pattern
-     *  - Second argument is the changed message
-     *  - Third argument is additional attributes, such as `roomType`
-     */
-    BotClient.prototype.reactToMessages = function (callback, debug) {
-        return __awaiter(this, void 0, void 0, function () {
-            var handler, _a;
-            var _this = this;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0:
-                        handler = function (e) {
-                            try {
-                                var message = e.fields.args[0];
-                                if (!message || !message._id) {
-                                    callback(new Error('Message handler fired on event without message or meta data'));
-                                }
-                                else {
-                                    callback(null, message, {});
-                                }
-                            }
-                            catch (err) {
-                                _this.logger.error("[driver] Message handler err: " + err.message);
-                                callback(err);
-                            }
-                        };
-                        _a = this;
-                        return [4 /*yield*/, this.subscribeToMessages()];
-                    case 1:
-                        _a.messages = _b.sent();
-                        this.messages.onEvent(handler);
-                        return [2 /*return*/];
-                }
-            });
-        });
-    };
-    /**
-     * Applies `reactToMessages` with some filtering of messages based on config.
-     * If no rooms are joined at this point, it will attempt to join now based on
-     * environment config, otherwise it might not receive any messages. It doesn't
-     * matter that this happens asynchronously because joined rooms can change after
-     * the subscription is set up.
-     *
-     * @param callback Function called after filters run on subscription events.
-     *  - Uses error-first callback pattern
-     *  - Second argument is the changed item
-     *  - Third argument is additional attributes, such as `roomType`
-     * @param options Sets filters for different event/message types.
-     */
-    BotClient.prototype.respondToMessages = function (callback, options) {
-        if (options === void 0) { options = {}; }
-        return __awaiter(this, void 0, void 0, function () {
-            var config, err_1;
-            var _this = this;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        config = __assign({}, this.config, options);
-                        if (!(!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0)) return [3 /*break*/, 4];
-                        _a.label = 1;
-                    case 1:
-                        _a.trys.push([1, 3, , 4]);
-                        return [4 /*yield*/, this.joinRooms(config.rooms)];
-                    case 2:
-                        _a.sent();
-                        return [3 /*break*/, 4];
-                    case 3:
-                        err_1 = _a.sent();
-                        this.logger.error("[driver] Failed to join configured rooms (" + config.rooms.join(', ') + "): " + err_1.message);
-                        return [3 /*break*/, 4];
-                    case 4: return [2 /*return*/, this.reactToMessages(function (err, message, meta) { return __awaiter(_this, void 0, void 0, function () {
-                            var room, isDM, isLC, error_2, currentReadTime;
-                            return __generator(this, function (_a) {
-                                switch (_a.label) {
-                                    case 0:
-                                        if (err) {
-                                            log_1.logger.error("[driver] Unable to receive: " + err.message);
-                                            return [2 /*return*/, callback(err)]; // bubble errors back to adapter
-                                        }
-                                        if (typeof message === 'undefined' /*|| typeof meta === 'undefined'*/) {
-                                            log_1.logger.error("[driver] Message or meta undefined");
-                                            return [2 /*return*/, callback(err)];
-                                        }
-                                        // Ignore bot's own messages
-                                        if (message.u && message.u._id === this.userId)
-                                            return [2 /*return*/];
-                                        _a.label = 1;
-                                    case 1:
-                                        _a.trys.push([1, 3, , 4]);
-                                        return [4 /*yield*/, this.rooms.info({ rid: message.rid })];
-                                    case 2:
-                                        room = _a.sent();
-                                        isDM = room.t === 'd';
-                                        if (isDM && !config.dm)
-                                            return [2 /*return*/];
-                                        isLC = room.t === 'l';
-                                        if (isLC && !config.livechat)
-                                            return [2 /*return*/];
-                                        return [3 /*break*/, 4];
-                                    case 3:
-                                        error_2 = _a.sent();
-                                        console.log(error_2);
-                                        return [3 /*break*/, 4];
-                                    case 4:
-                                        currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date();
-                                        // Ignore edited messages if configured to
-                                        if (!config.edited && message.editedAt)
-                                            return [2 /*return*/];
-                                        // Ignore messages in stream that aren't new
-                                        if (currentReadTime < this.lastReadTime)
-                                            return [2 /*return*/];
-                                        // At this point, message has passed checks and can be responded to
-                                        // const username = (message.u) ? message.u.username : 'unknown'
-                                        // this.logger.info(`[driver] Message ${message._id} from ${username}`)
-                                        this.lastReadTime = currentReadTime;
-                                        callback(null, message, meta);
-                                        return [2 /*return*/];
-                                }
-                            });
-                        }); })];
-                }
-            });
-        });
-    };
-    /** Get ID for a room by name (or ID). */
-    BotClient.prototype.getRoomId = function (name) {
-        return this.getRoomIdByNameOrId(name);
-    };
-    /** Join the bot into a room by its name or ID */
-    BotClient.prototype.joinRoom = function (_a) {
-        var rid = _a.rid;
-        return __awaiter(this, void 0, void 0, function () {
-            var roomId, joinedIndex;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0: return [4 /*yield*/, this.getRoomId(rid)];
-                    case 1:
-                        roomId = _b.sent();
-                        joinedIndex = this.joinedIds.indexOf(rid);
-                        if (joinedIndex !== -1) {
-                            log_1.logger.error("[driver] Join room failed, already joined");
-                            throw new Error("[driver] Join room failed, already joined");
-                        }
-                        return [4 /*yield*/, _super.prototype.joinRoom.call(this, { rid: roomId })];
-                    case 2:
-                        _b.sent();
-                        this.joinedIds.push(roomId);
-                        return [2 /*return*/, roomId];
-                }
-            });
-        });
-    };
-    /** Exit a room the bot has joined */
-    BotClient.prototype.leaveRoom = function (room) {
-        return __awaiter(this, void 0, void 0, function () {
-            var roomId, joinedIndex;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.getRoomId(room)];
-                    case 1:
-                        roomId = _a.sent();
-                        joinedIndex = this.joinedIds.indexOf(room);
-                        if (joinedIndex === -1) {
-                            this.logger.error("[driver] Leave room failed, bot has not joined " + room);
-                            throw new Error("[driver] Leave room failed, bot has not joined " + room);
-                        }
-                        return [4 /*yield*/, this.leaveRoom(roomId)];
-                    case 2:
-                        _a.sent();
-                        delete this.joinedIds[joinedIndex];
-                        return [2 /*return*/, roomId];
-                }
-            });
-        });
-    };
-    /** Join a set of rooms by array of names or IDs */
-    BotClient.prototype.joinRooms = function (rooms) {
-        var _this = this;
-        return Promise.all(rooms.map(function (rid) { return _this.joinRoom({ rid: rid }); }));
-    };
-    /**
-     * Prepare and send string/s to specified room ID.
-     * @param content Accepts message text string or array of strings.
-     * @param roomId  ID of the target room to use in send.
-     * @todo Returning one or many gets complicated with type checking not allowing
-     *       use of a property because result may be array, when you know it's not.
-     *       Solution would probably be to always return an array, even for single
-     *       send. This would be a breaking change, should hold until major version.
-     */
-    BotClient.prototype.sendToRoomId = function (content, roomId) {
-        var _this = this;
-        if (Array.isArray(content)) {
-            return Promise.all(content.map(function (text) {
-                return _this.sendMessage(text, roomId);
-            }));
-        }
-        return this.sendMessage(content, roomId);
-    };
-    /**
-     * Prepare and send string/s to specified room name (or ID).
-     * @param content Accepts message text string or array of strings.
-     * @param room    A name (or ID) to resolve as ID to use in send.
-     */
-    BotClient.prototype.sendToRoom = function (content, room) {
-        var _this = this;
-        return this.getRoomId(room)
-            .then(function (roomId) { return _this.sendToRoomId(content, roomId); });
-    };
-    /**
-     * Prepare and send string/s to a user in a DM.
-     * @param content   Accepts message text string or array of strings.
-     * @param username  Name to create (or get) DM for room ID to use in send.
-     */
-    BotClient.prototype.sendDirectToUser = function (content, username) {
-        var _this = this;
-        return this.getDirectMessageRoomId(username)
-            .then(function (rid) { return _this.sendToRoomId(content, rid); });
-    };
-    /**
-     * Get ID for a DM room by its recipient's name.
-     * Will create a DM (with the bot) if it doesn't exist already.
-     * @todo test why create resolves with object instead of simply ID
-     */
-    BotClient.prototype.getDirectMessageRoomId = function (username) {
-        return this.createDirectMessage(username).then(function (DM) {
-            return DM._id;
-        });
-    };
-    return BotClient;
-}(Rocketchat_1.default));
-exports.default = BotClient;
-//# sourceMappingURL=Bot.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Bot.js.map b/node_modules/@rocket.chat/sdk/lib/clients/Bot.js.map
deleted file mode 100644
index 4242bdc..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Bot.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Bot.js","sourceRoot":"","sources":["../../../src/lib/clients/Bot.ts"],"names":[],"mappings":"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","sourcesContent":["import { logger } from '../log'\nimport Rocketchat from './Rocketchat'\nimport mem from 'mem'\nimport {\n\tISocketOptions,\n\tIRespondOptions,\n\tICallback,\n\tIMessageCallback,\n\tISubscriptionEvent,\n\tIMessage,\n\tISubscription,\n\tIMessageReceipt\n} from '../../interfaces'\nimport { RID } from '../api/RocketChat'\n\nconst MY_MESSAGES = '__my_messages__'\nconst TOPIC_MESSAGES = 'stream-room-messages'\n\nexport default class BotClient extends Rocketchat {\n  integrationId: string\n  lastReadTime: Date = new Date(-8640000000000000)\n  joinedIds: string[] = []\n  messages: ISubscription | null = null\n\n  constructor ({ allPublic = false, integrationId, cachedMethods = ['channelInfo','privateInfo','getRoomIdByNameOrId', 'getRoomId', 'getRoomName','getRoomNameById','getDirectMessageRoomId' ], ...config }: any) {\n    super({ ...config, allPublic })\n    this.integrationId = integrationId\n\n    cachedMethods.forEach((name: string) => {\n      if ((this as any)[name]) {\n        (this as any)[name] = mem((this as any)[name].bind(this), { maxAge: 60 * 60 * 1000 }).bind(this)\n      }\n    })\n  }\n\t/**\n\t * Initialise socket instance with given options or defaults.\n\t * Proxies the DDP module socket connection. Resolves with socket when open.\n\t * Accepts callback following error-first-pattern.\n\t * Error returned or promise rejected on timeout.\n\t * @example <caption>Use with callback</caption>\n\t *  import driver from '@rocket.chat/sdk/bot'\n\t *  driver.connect({}, (err) => {\n\t *    if (err) throw err\n\t *    else console.log('connected')\n\t *  })\n\t * @example <caption>Using promise</caption>\n\t *  import driver from '@rocket.chat/sdk/bot'\n\t *  driver.connect()\n\t *    .then(() => console.log('connected'))\n\t *    .catch((err) => console.error(err))\n\t */\n  async connect (options: ISocketOptions, callback?: ICallback): Promise<any> {\n    try {\n      const result = await super.connect(options)\n      if (callback) {\n        callback(null, (await this.socket))\n      }\n      return result\n\n    } catch (error) {\n      if (callback) {\n        callback(error, this)\n      }\n      return Promise.reject(error)\n    }\n  }\n  async unsubscribeAll () {\n    delete this.messages\n    return super.unsubscribeAll()\n  }\n/** Begin subscription to user's \"global\" message stream. Will only allow one. */\n  async subscribeToMessages () {\n    if (!this.messages) {\n      this.messages = await this.subscribe(TOPIC_MESSAGES, MY_MESSAGES)\n    }\n    return this.messages\n  }\n/**\n * Add callback for changes in the message stream, subscribing if not already.\n * This can be called directly for custom extensions, but for most usage (e.g.\n * for bots) the respondToMessages is more useful to only receive messages\n * matching configuration.\n *\n * @param callback Function called with every change in subscriptions.\n *  - Uses error-first callback pattern\n *  - Second argument is the changed message\n *  - Third argument is additional attributes, such as `roomType`\n */\n  async reactToMessages (callback: IMessageCallback, debug?: string) {\n    const handler = (e: ISubscriptionEvent) => {\n\n      try {\n        const message: IMessage = e.fields.args[0]\n\n        if (!message || !message._id) {\n          callback(new Error('Message handler fired on event without message or meta data'))\n        } else {\n\n          callback(null, message, {} as any)\n        }\n      } catch (err) {\n        this.logger.error(`[driver] Message handler err: ${err.message}`)\n        callback(err)\n      }\n    }\n    this.messages = await this.subscribeToMessages()\n    this.messages.onEvent(handler)\n    // this.logger.info(`[driver] Added event handler for ${this.messages.name} subscription`)\n  }\n/**\n * Applies `reactToMessages` with some filtering of messages based on config.\n * If no rooms are joined at this point, it will attempt to join now based on\n * environment config, otherwise it might not receive any messages. It doesn't\n * matter that this happens asynchronously because joined rooms can change after\n * the subscription is set up.\n *\n * @param callback Function called after filters run on subscription events.\n *  - Uses error-first callback pattern\n *  - Second argument is the changed item\n *  - Third argument is additional attributes, such as `roomType`\n * @param options Sets filters for different event/message types.\n */\n  async respondToMessages (callback: IMessageCallback, options: IRespondOptions = {}) {\n    const config = { ...this.config, ...options }\n\n\t\t// Join configured rooms if they haven't been already, unless listening to all\n\t\t// public rooms, in which case it doesn't matter\n    if (!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0) {\n      try {\n        await this.joinRooms(config.rooms)\n      } catch (err) {\n        this.logger.error(`[driver] Failed to join configured rooms (${config.rooms.join(', ')}): ${err.message}`)\n      }\n    }\n    return this.reactToMessages(async (err, message, meta) => {\n      if (err) {\n        logger.error(`[driver] Unable to receive: ${err.message}`)\n        return callback(err) // bubble errors back to adapter\n      }\n      if (typeof message === 'undefined' /*|| typeof meta === 'undefined'*/) {\n        logger.error(`[driver] Message or meta undefined`)\n        return callback(err)\n      }\n\n\t\t\t// Ignore bot's own messages\n      if (message.u && message.u._id === this.userId) return\n\n\t\t\t// Ignore DMs unless configured not to\n      try {\n\n        const room = await this.rooms.info({ rid: message.rid })\n\n        const isDM = room.t === 'd'\n        if (isDM && !config.dm) return\n\n\t\t\t\t// Ignore Livechat unless configured not to\n        const isLC = room.t === 'l'\n\n        if (isLC && !config.livechat) return\n      } catch (error) {\n        console.log(error)\n      }\n\n\t\t\t// Ignore messages in un-joined public rooms unless configured not to\n      // if (!config.allPublic && !isDM && !meta.roomParticipant) return\n\n\t\t\t// Set current time for comparison to incoming\n      let currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date()\n\n\t\t\t// Ignore edited messages if configured to\n      if (!config.edited && message.editedAt) return\n\n\t\t\t// Ignore messages in stream that aren't new\n\n      if (currentReadTime < this.lastReadTime) return\n\t\t\t// At this point, message has passed checks and can be responded to\n      // const username = (message.u) ? message.u.username : 'unknown'\n      // this.logger.info(`[driver] Message ${message._id} from ${username}`)\n      this.lastReadTime = currentReadTime\n\n      callback(null, message, meta)\n    })\n  }\n\n\t/** Get ID for a room by name (or ID). */\n  getRoomId (name: string): Promise < RID > {\n    return this.getRoomIdByNameOrId(name)\n  }\n\n\t/** Join the bot into a room by its name or ID */\n  async joinRoom ({ rid }: any): Promise < RID > {\n    const roomId = await this.getRoomId(rid)\n    const joinedIndex = this.joinedIds.indexOf(rid)\n    if (joinedIndex !== -1) {\n      logger.error(`[driver] Join room failed, already joined`)\n      throw new Error(`[driver] Join room failed, already joined`)\n    }\n    await super.joinRoom({ rid: roomId })\n    this.joinedIds.push(roomId)\n    return roomId\n  }\n\n\t/** Exit a room the bot has joined */\n  async leaveRoom (room: string): Promise < RID > {\n    let roomId = await this.getRoomId(room)\n    let joinedIndex = this.joinedIds.indexOf(room)\n    if (joinedIndex === -1) {\n      this.logger.error(`[driver] Leave room failed, bot has not joined ${room}`)\n      throw new Error(`[driver] Leave room failed, bot has not joined ${room}`)\n    }\n    await this.leaveRoom(roomId)\n    delete this.joinedIds[joinedIndex]\n    return roomId\n  }\n\n\t/** Join a set of rooms by array of names or IDs */\n  joinRooms (rooms: string[]): Promise < RID[] > {\n    return Promise.all(rooms.map((rid) => this.joinRoom({ rid })))\n  }\n\t/**\n\t * Prepare and send string/s to specified room ID.\n\t * @param content Accepts message text string or array of strings.\n\t * @param roomId  ID of the target room to use in send.\n\t * @todo Returning one or many gets complicated with type checking not allowing\n\t *       use of a property because result may be array, when you know it's not.\n\t *       Solution would probably be to always return an array, even for single\n\t *       send. This would be a breaking change, should hold until major version.\n\t */\n  sendToRoomId (content: IMessage | string | string[], roomId: string): Promise<IMessageReceipt[] | IMessageReceipt > {\n    if (Array.isArray(content)) {\n      return Promise.all(content.map((text) => {\n        return this.sendMessage(text, roomId)\n      }))\n    }\n    return this.sendMessage(content, roomId)\n  }\n\t/**\n\t * Prepare and send string/s to specified room name (or ID).\n\t * @param content Accepts message text string or array of strings.\n\t * @param room    A name (or ID) to resolve as ID to use in send.\n\t */\n  sendToRoom (content: IMessage | string | string[], room: string): Promise<IMessageReceipt[] | IMessageReceipt > {\n    return this.getRoomId(room)\n\t\t.then((roomId) => this.sendToRoomId(content, roomId))\n  }\n\n\t/**\n\t * Prepare and send string/s to a user in a DM.\n\t * @param content   Accepts message text string or array of strings.\n\t * @param username  Name to create (or get) DM for room ID to use in send.\n\t */\n  sendDirectToUser (content: IMessage | string | string[], username: string): Promise<IMessageReceipt[] | IMessageReceipt > {\n    return this.getDirectMessageRoomId(username)\n\t\t.then((rid) => this.sendToRoomId(content, rid))\n  }\n\t/**\n\t * Get ID for a DM room by its recipient's name.\n\t * Will create a DM (with the bot) if it doesn't exist already.\n\t * @todo test why create resolves with object instead of simply ID\n\t */\n  getDirectMessageRoomId (username: string): Promise < RID > {\n    return this.createDirectMessage(username).then((DM: any) => {\n      return DM._id\n    })\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Bot.spec.ts b/node_modules/@rocket.chat/sdk/lib/clients/Bot.spec.ts
new file mode 100644
index 0000000..a20b37d
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/clients/Bot.spec.ts
@@ -0,0 +1,370 @@
+import 'mocha'
+import { apiUser, botUser, mockUser } from '../../utils/config'
+import sinon from 'sinon'
+import { expect } from 'chai'
+import { silence } from '../log'
+import * as settings from '../settings'
+import { testChannelName, testPrivateName } from '../../utils/testing'
+import BotDriver from './Bot'
+import { ISocketOptions, IMessageReceipt, ILogger } from '../../interfaces'
+
+import { Socket } from '../drivers/ddp'
+global.fetch = require('node-fetch-polyfill')
+
+const delay = (ms: number) => new Promise((resolve, reject) => setTimeout(resolve, ms))
+let clock: any
+let PUBLIC_ROOM: string
+let PRIVATE_ROOM: string
+class L implements ILogger {
+  debug (...args: any[]) {
+    // console.log(...args)
+  }
+  info (...args: any[]) {
+    // console.log(...args)
+  }
+  warning (...args: any[]) {
+    // console.warn(...args)
+  }
+  warn (...args: any[]) { // legacy method
+    // return this.warning(...args)
+  }
+  error (...args: any[]) {
+    // console.error(...args)
+  }
+}
+const mockuser = new BotDriver({})
+const botuser = new BotDriver({ logger : new L() })
+const adminuser = new BotDriver({})
+
+const getLastmessage = async () => {
+  return (await adminuser.loadHistory(PUBLIC_ROOM, new Date(new Date().setMinutes(new Date().getMinutes() - 10)))).updated[0]
+}
+describe('Bot Driver', () => {
+  before(async () => {
+    try {
+      await Promise.all([
+        mockuser.login({ password: mockUser.password, username: mockUser.username }),
+        adminuser.login({ password: apiUser.password, username: apiUser.username })
+      ])
+      await botuser.login({ password: botUser.password, username: botUser.username })
+      const testChannel = await adminuser.channelInfo({ roomName: testChannelName })
+      PUBLIC_ROOM = testChannel._id
+      const testPrivate = await adminuser.privateInfo({ roomName: testPrivateName })
+      PRIVATE_ROOM = testPrivate._id
+    } catch (e) { console.log(e) }
+  })
+  after(async () => {
+    await Promise.all([
+      mockuser.logout(),
+      botuser.logout(),
+      adminuser.logout()
+    ])
+  })
+
+  describe('.reactToMessages', () => {
+    afterEach(() => {
+      botuser.unsubscribeAll()
+    })
+    it('calls callback on every subscription update', async () => {
+      const callback = sinon.spy()
+      botuser.reactToMessages(callback)
+      await adminuser.sendMessage('SDK test `reactToMessages` 1', PUBLIC_ROOM)
+      await delay(100)
+      await adminuser.sendMessage('SDK test `reactToMessages` 2', PUBLIC_ROOM)
+      await delay(100)
+      expect(callback.callCount).to.equal(2)
+    })
+    it('calls callback with sent message object', async () => {
+      const callback = sinon.spy()
+      await botuser.reactToMessages(callback)
+      await adminuser.sendMessage('SDK test `reactToMessages` 3', PUBLIC_ROOM)
+      await delay(300)
+      const { args = [] } = callback.getCall(0) || {}
+      const messageArgs = args[1]
+      expect(messageArgs.msg).to.equal('SDK test `reactToMessages` 3')
+    })
+  })
+  describe('.setupMethodCache', () => {
+    // @todo needs better testing (maybe use `getServerInfo` as test call without requiring login/connect)
+    // stub instance class to make sure it's only calling on instance first time, instead of hacky timers
+    it('returns subsequent cached method results from cache', async () => {
+      await botuser.login({ username: settings.username, password: settings.password }) // calls setupMethodCache with DDP once connected
+      const now = Date.now()
+      const liveId = await botuser.getRoomNameById('GENERAL')
+      const after = Date.now()
+      const cacheId = await botuser.getRoomNameById('GENERAL')
+      const final = Date.now()
+      const firstCall = after - now
+      const cacheCall = final - after
+      expect(liveId).to.equal(cacheId)
+      expect(firstCall).to.be.gt(cacheCall)
+      expect(cacheCall).to.be.lte(10)
+    })
+  })
+  describe('.sendMessage', () => {
+    it('sends a custom message', async () => {
+      const reactions = { ':thumbsup:': { usernames: [botUser.username] } }
+      await botuser.sendMessage({
+        msg: ':point_down:',
+        emoji: ':point_right:',
+        reactions,
+        groupable: false
+      }, PUBLIC_ROOM)
+      const lastmessage = await getLastmessage()
+
+      expect(lastmessage).to.have.deep.property('reactions', reactions)
+      expect(lastmessage).to.have.property('emoji', ':point_right:')
+      expect(lastmessage).to.have.property('msg', ':point_down:')
+    })
+    it('sends a message with actions', async () => {
+
+      const attachments = [{
+        actions: [
+          { type: 'button', text: 'Action 1', msg: 'Testing Action 1', msg_in_chat_window: true },
+          { type: 'button', text: 'Action 2', msg: 'Testing Action 2', msg_in_chat_window: true }
+        ]
+      }]
+      await botuser.sendMessage({
+        msg: 'SDK test `prepareMessage` actions',
+        attachments
+      } as any, PUBLIC_ROOM)
+      const lastmessage = await getLastmessage()
+      expect(lastmessage.attachments && lastmessage.attachments[0].actions).to.eql(attachments[0].actions)
+    })
+  })
+  describe('.editMessage', () => {
+    it('edits the last sent message', async () => {
+      const original = await botuser.sendMessage({
+        msg: ':point_down:',
+        emoji: ':point_right:',
+        groupable: false
+      }, PUBLIC_ROOM)
+      const messageSent = await getLastmessage()
+      const update = {
+        ...original,
+        _id: messageSent._id,
+        msg: ':point_up:'
+      }
+
+      await delay(100)
+      await botuser.editMessage(update as any)
+      const edited = await getLastmessage()
+      expect(edited).to.have.property('msg', ':point_up:')
+      expect(edited).to.have.deep.property('editedBy', {
+        _id: botuser.userId, username: botUser.username
+      })
+    })
+  })
+  describe('.sendToRoomId', () => {
+    it('sends string to the given room id', async () => {
+      const result = await botuser.sendToRoomId('SDK test `sendToRoomId`', PUBLIC_ROOM)
+      expect(result).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+    it('sends array of strings to the given room id', async () => {
+      const result = await botuser.sendToRoomId([
+        'SDK test `sendToRoomId` A',
+        'SDK test `sendToRoomId` B'
+      ], PUBLIC_ROOM) as IMessageReceipt[]
+      expect(result).to.be.an('array')
+      expect(result[0]).to.include.all.keys(['msg', 'rid', '_id'])
+      expect(result[1]).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+  })
+  describe('.sendToRoom', () => {
+    it('sends string to the given room name', async () => {
+      const result = await botuser.sendToRoom('SDK test `sendToRoom`', testChannelName)
+      expect(result).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+    it('sends array of strings to the given room name', async () => {
+      const result = await botuser.sendToRoom([
+        'SDK test `sendToRoom` A',
+        'SDK test `sendToRoom` B'
+      ], testChannelName) as IMessageReceipt[]
+      expect(result).to.be.an('array')
+      expect(result[0]).to.include.all.keys(['msg', 'rid', '_id'])
+      expect(result[1]).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+  })
+  describe('.sendDirectToUser', () => {
+    it('sends string to the given room name', async () => {
+      const result = await botuser.sendDirectToUser('SDK test `sendDirectToUser`', mockUser.username)
+      expect(result).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+    it('sends array of strings to the given room name', async () => {
+      const result = await botuser.sendDirectToUser([
+        'SDK test `sendDirectToUser` A',
+        'SDK test `sendDirectToUser` B'
+      ], mockUser.username) as IMessageReceipt[]
+      expect(result).to.be.an('array')
+      expect(result[0]).to.include.all.keys(['msg', 'rid', '_id'])
+      expect(result[1]).to.include.all.keys(['msg', 'rid', '_id'])
+    })
+  })
+  describe('.setReaction', () => {
+    it('adds emoji reaction to message', async () => {
+      let sent = await botuser.sendToRoomId('test reactions', PUBLIC_ROOM)
+      if (Array.isArray(sent)) sent = sent[0] // see todo on `sendToRoomId`
+      await botuser.setReaction(':thumbsup:', sent._id)
+      const lastmessage = await getLastmessage()
+      expect(lastmessage.reactions).to.have.deep.property(':thumbsup:', {
+        usernames: [ botUser.username ]
+      })
+    })
+    it('removes if used when emoji reaction exists', async () => {
+      const sent = await botuser.sendMessage({
+        msg: 'test reactions -',
+        reactions: { ':thumbsup:': { usernames: [botUser.username] } }
+      } as any, PUBLIC_ROOM) as any
+      await botuser.setReaction(':thumbsup:', sent._id)
+      const lastmessage = await getLastmessage()
+      expect(lastmessage).to.not.have.property('reactions')
+    })
+  })
+  describe('.respondToMessages', () => {
+    it('joins rooms if not already joined', async () => {
+      expect(botuser.joinedIds).to.have.lengthOf(0)
+      await botuser.respondToMessages(() => { return null }, { rooms: ['general', testChannelName] })
+      expect(botuser.joinedIds).to.have.lengthOf(2)
+    })
+    it('ignores messages sent from bot', async () => {
+      const callback = sinon.spy()
+      botuser.respondToMessages(callback)
+      await botuser.sendToRoomId('SDK test `respondToMessages`', PUBLIC_ROOM)
+      await delay(300)
+      sinon.assert.notCalled(callback)
+    })
+    it('fires callback on messages in joined rooms', async () => {
+      const callback = sinon.spy()
+      botuser.respondToMessages(callback, { rooms: [testChannelName] })
+      await adminuser.sendMessage('SDK test `respondToMessages` 1', PUBLIC_ROOM)
+      await delay(300)
+      sinon.assert.calledOnce(callback)
+    })
+    it('by default ignores edited messages', async () => {
+      const callback = sinon.spy()
+      const sentMessage = await adminuser.sendMessage('SDK test `respondToMessages` sent', PUBLIC_ROOM)
+      await delay(300)
+      await botuser.respondToMessages(callback, { rooms: [testChannelName] })
+      await adminuser.editMessage({
+        rid: PUBLIC_ROOM,
+        _id: sentMessage._id,
+        msg: 'SDK test `respondToMessages` edited'
+      } as any)
+      await delay(300)
+      sinon.assert.notCalled(callback)
+    })
+    it('ignores edited messages, after receiving original', async () => {
+      const callback = sinon.spy()
+      await botuser.respondToMessages(callback, { rooms: [testChannelName] })
+      await delay(300)
+      const sentMessage = await adminuser.sendMessage('SDK test `respondToMessages` sent', PUBLIC_ROOM)
+      await delay(300)
+      await adminuser.editMessage({
+        rid: PUBLIC_ROOM,
+        _id: sentMessage._id,
+        msg: 'SDK test `respondToMessages` edited'
+      } as any)
+
+      await delay(300)
+      sinon.assert.calledOnce(callback)
+    })
+    it('fires callback on edited message if configured', async () => {
+      const callback = sinon.spy()
+      const sentMessage = await adminuser.sendMessage('SDK test `respondToMessages` sent', PUBLIC_ROOM)
+      await delay(300)
+      await botuser.respondToMessages(callback, { edited: true, rooms: [testChannelName] })
+      await delay(300)
+      await adminuser.editMessage({
+        rid: PUBLIC_ROOM,
+        _id: sentMessage._id,
+        msg: 'SDK test `respondToMessages` edited'
+      } as any)
+
+      await delay(300)
+      sinon.assert.calledOnce(callback)
+    })
+    it('by default ignores DMs', async () => {
+      const room = await adminuser.createDirectMessage(botUser.username)
+      const callback = sinon.spy()
+      await botuser.respondToMessages(callback, { rooms: [testChannelName] })
+      await adminuser.sendMessage('SDK test `respondToMessages` DM', room._id)
+      await delay(300)
+      sinon.assert.notCalled(callback)
+    })
+    it('fires callback on DMs if configured', async () => {
+      const room = await adminuser.createDirectMessage(botUser.username)
+      const callback = sinon.spy()
+      await botuser.respondToMessages(callback, { dm: true, rooms: [testChannelName] })
+      await adminuser.sendMessage('SDK test `respondToMessages` DM', room._id)
+      await delay(300)
+      sinon.assert.calledOnce(callback)
+    })
+    // it.skip('fires callback on ul (user leave) message types', async () => {
+    //   const callback = sinon.spy()
+    //   botuser.respondToMessages(callback, { rooms: [testChannelName] })
+    //   await utils.leaveUser()
+    //   await(300)
+    //   await utils.inviteUser()
+    //   sinon.assert.calledWithMatch(callback, null, sinon.match({ t: 'ul' }))
+    // })
+    // it.skip('fires callback on au (user added) message types', async () => {
+    //   const callback = sinon.spy()
+    //   await utils.leaveUser()
+    //   botuser.respondToMessages(callback, { rooms: [testChannelName] })
+    //   await utils.inviteUser()
+    //   await (300)
+    //   sinon.assert.calledWithMatch(callback, null, sinon.match({ t: 'au' }))
+    // })
+    it.skip('appends room name to event meta in channels', async () => {
+      const callback = sinon.spy()
+      botuser.respondToMessages(callback, { dm: true, rooms: [testChannelName] })
+      await adminuser.sendMessage('SDK test `respondToMessages` DM', PUBLIC_ROOM)
+      await (300)
+      expect(callback.firstCall.args[2].roomName).to.equal(testChannelName)
+    })
+    it('room name is undefined in direct messages', async () => {
+      const room = await adminuser.createDirectMessage(botUser.username)
+      const callback = sinon.spy()
+      await new Promise(async resolve => {
+        await botuser.respondToMessages((...args: any[]) => {
+          resolve()
+          callback(...args)
+        }, { dm: true })
+        adminuser.sendMessage('SDK test `respondToMessages` DM', room._id)
+      })
+      await (500)
+      expect(callback.getCall(0).args[1].roomName).to.equal(undefined)
+    })
+  })
+  describe('.getRoomId', () => {
+    it('returns the ID for a channel by ID', async () => {
+      const room = await botuser.getRoomId(testChannelName)
+      expect(room).to.equal(PUBLIC_ROOM)
+    })
+    it('returns the ID for a private room name', async () => {
+      const room = await botuser.getRoomId(testPrivateName)
+      expect(room).to.equal(PRIVATE_ROOM)
+    })
+  })
+  describe('.getRoomName', () => {
+    it('returns the name for a channel by ID', async () => {
+      const room = await botuser.getRoomName(PUBLIC_ROOM)
+      expect(room).to.equal(testChannelName)
+    })
+    it('returns the name for a private group by ID', async () => {
+      const room = await botuser.getRoomName(PRIVATE_ROOM)
+      expect(room).to.equal(testPrivateName)
+    })
+    it('returns undefined for a DM room', async () => {
+      const room = await adminuser.createDirectMessage(botUser.username)
+      expect(await botuser.getRoomName(room._id)).to.equal(undefined)
+    })
+  })
+  describe('.joinRooms', () => {
+    it('joins all the rooms in array, keeping IDs', async () => {
+      botuser.joinedIds.splice(0, botuser.joinedIds.length) // clear const array
+      await botuser.joinRooms(['general', testChannelName])
+      expect(botuser.joinedIds).to.have.members(['GENERAL', PUBLIC_ROOM])
+    })
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Bot.ts b/node_modules/@rocket.chat/sdk/lib/clients/Bot.ts
new file mode 100644
index 0000000..5105495
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/clients/Bot.ts
@@ -0,0 +1,266 @@
+import { logger } from '../log'
+import Rocketchat from './Rocketchat'
+import mem from 'mem'
+import {
+	ISocketOptions,
+	IRespondOptions,
+	ICallback,
+	IMessageCallback,
+	ISubscriptionEvent,
+	IMessage,
+	ISubscription,
+	IMessageReceipt
+} from '../../interfaces'
+import { RID } from '../api/RocketChat'
+
+const MY_MESSAGES = '__my_messages__'
+const TOPIC_MESSAGES = 'stream-room-messages'
+
+export default class BotClient extends Rocketchat {
+  integrationId: string
+  lastReadTime: Date = new Date(-8640000000000000)
+  joinedIds: string[] = []
+  messages: ISubscription | null = null
+
+  constructor ({ allPublic = false, integrationId, cachedMethods = ['channelInfo','privateInfo','getRoomIdByNameOrId', 'getRoomId', 'getRoomName','getRoomNameById','getDirectMessageRoomId' ], ...config }: any) {
+    super({ ...config, allPublic })
+    this.integrationId = integrationId
+
+    cachedMethods.forEach((name: string) => {
+      if ((this as any)[name]) {
+        (this as any)[name] = mem((this as any)[name].bind(this), { maxAge: 60 * 60 * 1000 }).bind(this)
+      }
+    })
+  }
+	/**
+	 * Initialise socket instance with given options or defaults.
+	 * Proxies the DDP module socket connection. Resolves with socket when open.
+	 * Accepts callback following error-first-pattern.
+	 * Error returned or promise rejected on timeout.
+	 * @example <caption>Use with callback</caption>
+	 *  import driver from '@rocket.chat/sdk/bot'
+	 *  driver.connect({}, (err) => {
+	 *    if (err) throw err
+	 *    else console.log('connected')
+	 *  })
+	 * @example <caption>Using promise</caption>
+	 *  import driver from '@rocket.chat/sdk/bot'
+	 *  driver.connect()
+	 *    .then(() => console.log('connected'))
+	 *    .catch((err) => console.error(err))
+	 */
+  async connect (options: ISocketOptions, callback?: ICallback): Promise<any> {
+    try {
+      const result = await super.connect(options)
+      if (callback) {
+        callback(null, (await this.socket))
+      }
+      return result
+
+    } catch (error) {
+      if (callback) {
+        callback(error, this)
+      }
+      return Promise.reject(error)
+    }
+  }
+  async unsubscribeAll () {
+    delete this.messages
+    return super.unsubscribeAll()
+  }
+/** Begin subscription to user's "global" message stream. Will only allow one. */
+  async subscribeToMessages () {
+    if (!this.messages) {
+      this.messages = await this.subscribe(TOPIC_MESSAGES, MY_MESSAGES)
+    }
+    return this.messages
+  }
+/**
+ * Add callback for changes in the message stream, subscribing if not already.
+ * This can be called directly for custom extensions, but for most usage (e.g.
+ * for bots) the respondToMessages is more useful to only receive messages
+ * matching configuration.
+ *
+ * @param callback Function called with every change in subscriptions.
+ *  - Uses error-first callback pattern
+ *  - Second argument is the changed message
+ *  - Third argument is additional attributes, such as `roomType`
+ */
+  async reactToMessages (callback: IMessageCallback, debug?: string) {
+    const handler = (e: ISubscriptionEvent) => {
+
+      try {
+        const message: IMessage = e.fields.args[0]
+
+        if (!message || !message._id) {
+          callback(new Error('Message handler fired on event without message or meta data'))
+        } else {
+
+          callback(null, message, {} as any)
+        }
+      } catch (err) {
+        this.logger.error(`[driver] Message handler err: ${err.message}`)
+        callback(err)
+      }
+    }
+    this.messages = await this.subscribeToMessages()
+    this.messages.onEvent(handler)
+    // this.logger.info(`[driver] Added event handler for ${this.messages.name} subscription`)
+  }
+/**
+ * Applies `reactToMessages` with some filtering of messages based on config.
+ * If no rooms are joined at this point, it will attempt to join now based on
+ * environment config, otherwise it might not receive any messages. It doesn't
+ * matter that this happens asynchronously because joined rooms can change after
+ * the subscription is set up.
+ *
+ * @param callback Function called after filters run on subscription events.
+ *  - Uses error-first callback pattern
+ *  - Second argument is the changed item
+ *  - Third argument is additional attributes, such as `roomType`
+ * @param options Sets filters for different event/message types.
+ */
+  async respondToMessages (callback: IMessageCallback, options: IRespondOptions = {}) {
+    const config = { ...this.config, ...options }
+
+		// Join configured rooms if they haven't been already, unless listening to all
+		// public rooms, in which case it doesn't matter
+    if (!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0) {
+      try {
+        await this.joinRooms(config.rooms)
+      } catch (err) {
+        this.logger.error(`[driver] Failed to join configured rooms (${config.rooms.join(', ')}): ${err.message}`)
+      }
+    }
+    return this.reactToMessages(async (err, message, meta) => {
+      if (err) {
+        logger.error(`[driver] Unable to receive: ${err.message}`)
+        return callback(err) // bubble errors back to adapter
+      }
+      if (typeof message === 'undefined' /*|| typeof meta === 'undefined'*/) {
+        logger.error(`[driver] Message or meta undefined`)
+        return callback(err)
+      }
+
+			// Ignore bot's own messages
+      if (message.u && message.u._id === this.userId) return
+
+			// Ignore DMs unless configured not to
+      try {
+
+        const room = await this.rooms.info({ rid: message.rid })
+
+        const isDM = room.t === 'd'
+        if (isDM && !config.dm) return
+
+				// Ignore Livechat unless configured not to
+        const isLC = room.t === 'l'
+
+        if (isLC && !config.livechat) return
+      } catch (error) {
+        console.log(error)
+      }
+
+			// Ignore messages in un-joined public rooms unless configured not to
+      // if (!config.allPublic && !isDM && !meta.roomParticipant) return
+
+			// Set current time for comparison to incoming
+      let currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date()
+
+			// Ignore edited messages if configured to
+      if (!config.edited && message.editedAt) return
+
+			// Ignore messages in stream that aren't new
+
+      if (currentReadTime < this.lastReadTime) return
+			// At this point, message has passed checks and can be responded to
+      // const username = (message.u) ? message.u.username : 'unknown'
+      // this.logger.info(`[driver] Message ${message._id} from ${username}`)
+      this.lastReadTime = currentReadTime
+
+      callback(null, message, meta)
+    })
+  }
+
+	/** Get ID for a room by name (or ID). */
+  getRoomId (name: string): Promise < RID > {
+    return this.getRoomIdByNameOrId(name)
+  }
+
+	/** Join the bot into a room by its name or ID */
+  async joinRoom ({ rid }: any): Promise < RID > {
+    const roomId = await this.getRoomId(rid)
+    const joinedIndex = this.joinedIds.indexOf(rid)
+    if (joinedIndex !== -1) {
+      logger.error(`[driver] Join room failed, already joined`)
+      throw new Error(`[driver] Join room failed, already joined`)
+    }
+    await super.joinRoom({ rid: roomId })
+    this.joinedIds.push(roomId)
+    return roomId
+  }
+
+	/** Exit a room the bot has joined */
+  async leaveRoom (room: string): Promise < RID > {
+    let roomId = await this.getRoomId(room)
+    let joinedIndex = this.joinedIds.indexOf(room)
+    if (joinedIndex === -1) {
+      this.logger.error(`[driver] Leave room failed, bot has not joined ${room}`)
+      throw new Error(`[driver] Leave room failed, bot has not joined ${room}`)
+    }
+    await this.leaveRoom(roomId)
+    delete this.joinedIds[joinedIndex]
+    return roomId
+  }
+
+	/** Join a set of rooms by array of names or IDs */
+  joinRooms (rooms: string[]): Promise < RID[] > {
+    return Promise.all(rooms.map((rid) => this.joinRoom({ rid })))
+  }
+	/**
+	 * Prepare and send string/s to specified room ID.
+	 * @param content Accepts message text string or array of strings.
+	 * @param roomId  ID of the target room to use in send.
+	 * @todo Returning one or many gets complicated with type checking not allowing
+	 *       use of a property because result may be array, when you know it's not.
+	 *       Solution would probably be to always return an array, even for single
+	 *       send. This would be a breaking change, should hold until major version.
+	 */
+  sendToRoomId (content: IMessage | string | string[], roomId: string): Promise<IMessageReceipt[] | IMessageReceipt > {
+    if (Array.isArray(content)) {
+      return Promise.all(content.map((text) => {
+        return this.sendMessage(text, roomId)
+      }))
+    }
+    return this.sendMessage(content, roomId)
+  }
+	/**
+	 * Prepare and send string/s to specified room name (or ID).
+	 * @param content Accepts message text string or array of strings.
+	 * @param room    A name (or ID) to resolve as ID to use in send.
+	 */
+  sendToRoom (content: IMessage | string | string[], room: string): Promise<IMessageReceipt[] | IMessageReceipt > {
+    return this.getRoomId(room)
+		.then((roomId) => this.sendToRoomId(content, roomId))
+  }
+
+	/**
+	 * Prepare and send string/s to a user in a DM.
+	 * @param content   Accepts message text string or array of strings.
+	 * @param username  Name to create (or get) DM for room ID to use in send.
+	 */
+  sendDirectToUser (content: IMessage | string | string[], username: string): Promise<IMessageReceipt[] | IMessageReceipt > {
+    return this.getDirectMessageRoomId(username)
+		.then((rid) => this.sendToRoomId(content, rid))
+  }
+	/**
+	 * Get ID for a DM room by its recipient's name.
+	 * Will create a DM (with the bot) if it doesn't exist already.
+	 * @todo test why create resolves with object instead of simply ID
+	 */
+  getDirectMessageRoomId (username: string): Promise < RID > {
+    return this.createDirectMessage(username).then((DM: any) => {
+      return DM._id
+    })
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.d.ts b/node_modules/@rocket.chat/sdk/lib/clients/Livechat.d.ts
deleted file mode 100644
index 4ecc19f..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.d.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
-    * @module LivechatDriver
-    * Provides high-level helpers for Livechat connection, method calls, subscriptions.
-    */
-import LivechatRest from '../api/Livechat';
-import { ISocket, Protocols, IDriver } from '../drivers';
-import { ILogger, ISocketOptions, ICallback, ISubscription } from '../../interfaces';
-export default class LivechatClient extends LivechatRest implements ISocket {
-    livechatStream: string;
-    userId: string;
-    logger: ILogger;
-    socket: Promise<ISocket | IDriver>;
-    constructor({ logger, allPublic, rooms, integrationId, protocol, ...config }: any);
-    import(protocol: Protocols, config: any): void;
-    connect(options: ISocketOptions, callback?: ICallback): Promise<any>;
-    disconnect(): Promise<any>;
-    unsubscribe(subscription: ISubscription): Promise<any>;
-    unsubscribeAll(): Promise<any>;
-    subscribeNotifyAll(): Promise<any>;
-    subscribeLoggedNotify(): Promise<any>;
-    subscribeNotifyUser(): Promise<any>;
-    onMessage(cb: ICallback): Promise<any>;
-    onTyping(cb: ICallback): Promise<any>;
-    onAgentChange(rid: string, cb: ICallback): Promise<void>;
-    onAgentStatusChange(rid: string, cb: ICallback): Promise<void>;
-    onQueuePositionChange(rid: string, cb: ICallback): Promise<void>;
-    notifyVisitorTyping(rid: string, username: string, typing: boolean): Promise<any>;
-    subscribe(topic: string, eventName: string): Promise<ISubscription>;
-    subscribeRoom(rid: string): Promise<ISubscription[]>;
-    onStreamData(event: string, cb: ICallback): Promise<any>;
-    setUpConnection(): Promise<any>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js b/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js
deleted file mode 100644
index fd1fa90..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js
+++ /dev/null
@@ -1,329 +0,0 @@
-"use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-var __read = (this && this.__read) || function (o, n) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator];
-    if (!m) return o;
-    var i = m.call(o), r, ar = [], e;
-    try {
-        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
-    }
-    catch (error) { e = { error: error }; }
-    finally {
-        try {
-            if (r && !r.done && (m = i["return"])) m.call(i);
-        }
-        finally { if (e) throw e.error; }
-    }
-    return ar;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-/**
-    * @module LivechatDriver
-    * Provides high-level helpers for Livechat connection, method calls, subscriptions.
-    */
-var Livechat_1 = __importDefault(require("../api/Livechat"));
-var drivers_1 = require("../drivers");
-var log_1 = require("../log");
-var LivechatClient = /** @class */ (function (_super) {
-    __extends(LivechatClient, _super);
-    function LivechatClient(_a) {
-        var logger = _a.logger, allPublic = _a.allPublic, rooms = _a.rooms, integrationId = _a.integrationId, _b = _a.protocol, protocol = _b === void 0 ? drivers_1.Protocols.DDP : _b, config = __rest(_a, ["logger", "allPublic", "rooms", "integrationId", "protocol"]);
-        var _this = _super.call(this, __assign({ logger: logger }, config)) || this;
-        _this.livechatStream = 'stream-livechat-room';
-        _this.userId = '';
-        _this.logger = log_1.logger;
-        _this.socket = Promise.resolve();
-        _this.import(protocol, config);
-        return _this;
-    }
-    LivechatClient.prototype.import = function (protocol, config) {
-        var _this = this;
-        switch (protocol) {
-            // case Protocols.MQTT:
-            //   this.socket = import(/* webpackChunkName: 'mqtttest' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ logger: this.logger, ...config }))
-            //   break
-            case drivers_1.Protocols.DDP:
-                this.socket = Promise.resolve().then(function () { return __importStar(require(/* webpackChunkName: 'ddptest' */ '../drivers/ddp')); }).then(function (_a) {
-                    var DDPDriver = _a.DDPDriver;
-                    return new DDPDriver(__assign({ logger: _this.logger }, config));
-                });
-                break;
-            default:
-                throw new Error("Invalid Protocol: " + protocol + ", valids: " + Object.keys(drivers_1.Protocols).join());
-        }
-    };
-    LivechatClient.prototype.connect = function (options, callback) {
-        return __awaiter(this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).connect(options).then(function () { return (_this.setUpConnection()); })];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.disconnect = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).disconnect()];
-            }
-        }); });
-    };
-    LivechatClient.prototype.unsubscribe = function (subscription) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).unsubscribe(subscription)];
-            }
-        }); });
-    };
-    LivechatClient.prototype.unsubscribeAll = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).unsubscribeAll()];
-            }
-        }); });
-    };
-    LivechatClient.prototype.subscribeNotifyAll = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyAll()];
-            }
-        }); });
-    };
-    LivechatClient.prototype.subscribeLoggedNotify = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeLoggedNotify()];
-            }
-        }); });
-    };
-    LivechatClient.prototype.subscribeNotifyUser = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyUser()];
-            }
-        }); });
-    };
-    LivechatClient.prototype.onMessage = function (cb) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).onMessage(cb)];
-            }
-        }); });
-    };
-    LivechatClient.prototype.onTyping = function (cb) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).onTyping(cb)];
-            }
-        }); });
-    };
-    LivechatClient.prototype.onAgentChange = function (rid, cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
-                    case 1:
-                        _a.sent();
-                        return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
-                                var _b = __read(_a.fields.args, 1), _c = _b[0], type = _c.type, data = _c.data;
-                                if (type === 'agentData') {
-                                    cb(data);
-                                }
-                            })];
-                    case 2:
-                        _a.sent();
-                        return [2 /*return*/];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.onAgentStatusChange = function (rid, cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
-                    case 1:
-                        _a.sent();
-                        return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
-                                var _b = __read(_a.fields.args, 1), _c = _b[0], type = _c.type, status = _c.status;
-                                if (type === 'agentStatus') {
-                                    cb(status);
-                                }
-                            })];
-                    case 2:
-                        _a.sent();
-                        return [2 /*return*/];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.onQueuePositionChange = function (rid, cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.subscribe(this.livechatStream, rid)];
-                    case 1:
-                        _a.sent();
-                        return [4 /*yield*/, this.onStreamData(this.livechatStream, function (_a) {
-                                var _b = __read(_a.fields.args, 1), _c = _b[0], type = _c.type, data = _c.data;
-                                if (type === 'queueData') {
-                                    cb(data);
-                                }
-                            })];
-                    case 2:
-                        _a.sent();
-                        return [2 /*return*/];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.notifyVisitorTyping = function (rid, username, typing) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).notifyVisitorTyping(rid, username, typing, this.credentials.token)];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.subscribe = function (topic, eventName) {
-        return __awaiter(this, void 0, void 0, function () {
-            var token;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        token = this.credentials.token;
-                        return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).subscribe(topic, eventName, { token: token, visitorToken: token })];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.subscribeRoom = function (rid) {
-        return __awaiter(this, void 0, void 0, function () {
-            var token;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        token = this.credentials.token;
-                        return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).subscribeRoom(rid, { token: token, visitorToken: token })];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.onStreamData = function (event, cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).onStreamData(event, cb)];
-                }
-            });
-        });
-    };
-    LivechatClient.prototype.setUpConnection = function () {
-        return __awaiter(this, void 0, void 0, function () {
-            var token;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        token = this.credentials.token;
-                        return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).methodCall('livechat:setUpConnection', { token: token })];
-                }
-            });
-        });
-    };
-    return LivechatClient;
-}(Livechat_1.default));
-exports.default = LivechatClient;
-//# sourceMappingURL=Livechat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js.map b/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js.map
deleted file mode 100644
index 631fdd2..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Livechat.js","sourceRoot":"","sources":["../../../src/lib/clients/Livechat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n\t* @module LivechatDriver\n\t* Provides high-level helpers for Livechat connection, method calls, subscriptions.\n\t*/\nimport LivechatRest from '../api/Livechat'\nimport { ISocket, Protocols, IDriver } from '../drivers'\nimport { logger as Logger } from '../log'\nimport {\n\tILogger,\n\tISocketOptions,\n\tICallback,\n\tISubscription\n} from '../../interfaces'\n\nexport default class LivechatClient extends LivechatRest implements ISocket {\n  livechatStream: string = 'stream-livechat-room'\n  userId: string = ''\n  logger: ILogger = Logger\n  socket: Promise<ISocket | IDriver> = Promise.resolve() as any\n  constructor ({ logger, allPublic, rooms, integrationId, protocol = Protocols.DDP, ...config }: any) {\n    super({ logger, ...config })\n    this.import(protocol, config)\n  }\n  import (protocol: Protocols, config: any) {\n    switch (protocol) {\n      // case Protocols.MQTT:\n      //   this.socket = import(/* webpackChunkName: 'mqtttest' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ logger: this.logger, ...config }))\n      //   break\n      case Protocols.DDP:\n        this.socket = import(/* webpackChunkName: 'ddptest' */ '../drivers/ddp').then(({ DDPDriver }) => new DDPDriver({ logger: this.logger, ...config }))\n        break\n      default:\n        throw new Error(`Invalid Protocol: ${protocol}, valids: ${Object.keys(Protocols).join()}`)\n    }\n  }\n  async connect (options: ISocketOptions, callback?: ICallback): Promise <any> {\n    return (await this.socket as ISocket).connect(options).then(() => (this.setUpConnection()))\n  }\n  async disconnect (): Promise<any> { return (await this.socket as ISocket).disconnect() }\n  async unsubscribe (subscription: ISubscription): Promise<any> { return (await this.socket as ISocket).unsubscribe(subscription) }\n  async unsubscribeAll (): Promise<any> { return (await this.socket as ISocket).unsubscribeAll() }\n  async subscribeNotifyAll (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyAll() }\n  async subscribeLoggedNotify (): Promise<any> { return (await this.socket as IDriver) .subscribeLoggedNotify() }\n  async subscribeNotifyUser (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyUser() }\n  async onMessage (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onMessage(cb) }\n  async onTyping (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onTyping(cb) }\n  async onAgentChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {\n      if (type === 'agentData') {\n        cb(data)\n      }\n    })\n  }\n  async onAgentStatusChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, status }] } }: any) => {\n      if (type === 'agentStatus') {\n        cb(status)\n      }\n    })\n  }\n\n  async onQueuePositionChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {\n      if (type === 'queueData') {\n        cb(data)\n      }\n    })\n  }\n\n  async notifyVisitorTyping (rid: string, username: string, typing: boolean) {\n    return (await this.socket as IDriver).notifyVisitorTyping(rid, username, typing, this.credentials.token)\n  }\n\n  async subscribe (topic: string, eventName: string) {\n    const { token } = this.credentials\n    return (await this.socket as ISocket).subscribe(topic, eventName, { token, visitorToken: token })\n  }\n\n  async subscribeRoom (rid: string) {\n    const { token } = this.credentials\n    return (await this.socket as IDriver).subscribeRoom(rid, { token, visitorToken: token })\n  }\n\n  async onStreamData (event: string, cb: ICallback): Promise<any> {\n    return (await this.socket as ISocket).onStreamData(event, cb)\n  }\n\n  async setUpConnection () {\n    const { token } = this.credentials\n    return (await this.socket as IDriver).methodCall('livechat:setUpConnection', { token })\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Livechat.ts b/node_modules/@rocket.chat/sdk/lib/clients/Livechat.ts
new file mode 100644
index 0000000..aab6008
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/clients/Livechat.ts
@@ -0,0 +1,95 @@
+/**
+	* @module LivechatDriver
+	* Provides high-level helpers for Livechat connection, method calls, subscriptions.
+	*/
+import LivechatRest from '../api/Livechat'
+import { ISocket, Protocols, IDriver } from '../drivers'
+import { logger as Logger } from '../log'
+import {
+	ILogger,
+	ISocketOptions,
+	ICallback,
+	ISubscription
+} from '../../interfaces'
+
+export default class LivechatClient extends LivechatRest implements ISocket {
+  livechatStream: string = 'stream-livechat-room'
+  userId: string = ''
+  logger: ILogger = Logger
+  socket: Promise<ISocket | IDriver> = Promise.resolve() as any
+  constructor ({ logger, allPublic, rooms, integrationId, protocol = Protocols.DDP, ...config }: any) {
+    super({ logger, ...config })
+    this.import(protocol, config)
+  }
+  import (protocol: Protocols, config: any) {
+    switch (protocol) {
+      // case Protocols.MQTT:
+      //   this.socket = import(/* webpackChunkName: 'mqtttest' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ logger: this.logger, ...config }))
+      //   break
+      case Protocols.DDP:
+        this.socket = import(/* webpackChunkName: 'ddptest' */ '../drivers/ddp').then(({ DDPDriver }) => new DDPDriver({ logger: this.logger, ...config }))
+        break
+      default:
+        throw new Error(`Invalid Protocol: ${protocol}, valids: ${Object.keys(Protocols).join()}`)
+    }
+  }
+  async connect (options: ISocketOptions, callback?: ICallback): Promise <any> {
+    return (await this.socket as ISocket).connect(options).then(() => (this.setUpConnection()))
+  }
+  async disconnect (): Promise<any> { return (await this.socket as ISocket).disconnect() }
+  async unsubscribe (subscription: ISubscription): Promise<any> { return (await this.socket as ISocket).unsubscribe(subscription) }
+  async unsubscribeAll (): Promise<any> { return (await this.socket as ISocket).unsubscribeAll() }
+  async subscribeNotifyAll (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyAll() }
+  async subscribeLoggedNotify (): Promise<any> { return (await this.socket as IDriver) .subscribeLoggedNotify() }
+  async subscribeNotifyUser (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyUser() }
+  async onMessage (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onMessage(cb) }
+  async onTyping (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onTyping(cb) }
+  async onAgentChange (rid: string, cb: ICallback) {
+    await this.subscribe(this.livechatStream, rid)
+    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {
+      if (type === 'agentData') {
+        cb(data)
+      }
+    })
+  }
+  async onAgentStatusChange (rid: string, cb: ICallback) {
+    await this.subscribe(this.livechatStream, rid)
+    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, status }] } }: any) => {
+      if (type === 'agentStatus') {
+        cb(status)
+      }
+    })
+  }
+
+  async onQueuePositionChange (rid: string, cb: ICallback) {
+    await this.subscribe(this.livechatStream, rid)
+    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {
+      if (type === 'queueData') {
+        cb(data)
+      }
+    })
+  }
+
+  async notifyVisitorTyping (rid: string, username: string, typing: boolean) {
+    return (await this.socket as IDriver).notifyVisitorTyping(rid, username, typing, this.credentials.token)
+  }
+
+  async subscribe (topic: string, eventName: string) {
+    const { token } = this.credentials
+    return (await this.socket as ISocket).subscribe(topic, eventName, { token, visitorToken: token })
+  }
+
+  async subscribeRoom (rid: string) {
+    const { token } = this.credentials
+    return (await this.socket as IDriver).subscribeRoom(rid, { token, visitorToken: token })
+  }
+
+  async onStreamData (event: string, cb: ICallback): Promise<any> {
+    return (await this.socket as ISocket).onStreamData(event, cb)
+  }
+
+  async setUpConnection () {
+    const { token } = this.credentials
+    return (await this.socket as IDriver).methodCall('livechat:setUpConnection', { token })
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.d.ts b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.d.ts
deleted file mode 100644
index c65e8b7..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.d.ts
+++ /dev/null
@@ -1,27 +0,0 @@
-import { ISocket, IDriver } from '../drivers';
-import ClientRest from '../api/RocketChat';
-import { ILogger, ISocketOptions, ICallback, ISubscription, ICredentials } from '../../interfaces';
-export default class RocketChatClient extends ClientRest implements ISocket {
-    userId: string;
-    logger: ILogger;
-    socket: Promise<ISocket | IDriver>;
-    config: any;
-    constructor({ logger, allPublic, rooms, integrationId, protocol, ...config }: any);
-    resume({ token }: {
-        token: string;
-    }): Promise<any>;
-    login(credentials: ICredentials): Promise<any>;
-    connect(options: ISocketOptions): Promise<any>;
-    disconnect(): Promise<any>;
-    onStreamData(event: string, cb: ICallback): Promise<any>;
-    subscribe(topic: string, ...args: any[]): Promise<ISubscription>;
-    unsubscribe(subscription: ISubscription): Promise<any>;
-    unsubscribeAll(): Promise<any>;
-    subscribeRoom(rid: string, ...args: any[]): Promise<ISubscription[]>;
-    subscribeNotifyAll(): Promise<any>;
-    subscribeLoggedNotify(): Promise<any>;
-    subscribeNotifyUser(): Promise<any>;
-    readonly url: Promise<any>;
-    onMessage(cb: ICallback): Promise<any>;
-    methodCall(method: string, ...args: any[]): Promise<ISubscription>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js
deleted file mode 100644
index fbbd519..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js
+++ /dev/null
@@ -1,279 +0,0 @@
-"use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-var __read = (this && this.__read) || function (o, n) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator];
-    if (!m) return o;
-    var i = m.call(o), r, ar = [], e;
-    try {
-        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
-    }
-    catch (error) { e = { error: error }; }
-    finally {
-        try {
-            if (r && !r.done && (m = i["return"])) m.call(i);
-        }
-        finally { if (e) throw e.error; }
-    }
-    return ar;
-};
-var __spread = (this && this.__spread) || function () {
-    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
-    return ar;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var drivers_1 = require("../drivers");
-var RocketChat_1 = __importDefault(require("../api/RocketChat"));
-var log_1 = require("../log");
-var RocketChatClient = /** @class */ (function (_super) {
-    __extends(RocketChatClient, _super);
-    function RocketChatClient(_a) {
-        var logger = _a.logger, allPublic = _a.allPublic, rooms = _a.rooms, integrationId = _a.integrationId, _b = _a.protocol, protocol = _b === void 0 ? drivers_1.Protocols.DDP : _b, config = __rest(_a, ["logger", "allPublic", "rooms", "integrationId", "protocol"]);
-        var _this = _super.call(this, __assign({}, config, { logger: logger })) || this;
-        _this.userId = '';
-        _this.logger = log_1.logger;
-        _this.logger = logger;
-        switch (protocol) {
-            // case Protocols.MQTT:
-            //   this.socket = import(/* webpackChunkName: 'mqtt' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ ...config, logger }))
-            //   break
-            case drivers_1.Protocols.DDP:
-                _this.socket = Promise.resolve().then(function () { return __importStar(require(/* webpackChunkName: 'ddp' */ '../drivers/ddp')); }).then(function (_a) {
-                    var DDPDriver = _a.DDPDriver;
-                    return new DDPDriver(__assign({}, config, { logger: logger }));
-                });
-                break;
-            default:
-                throw new Error("Invalid Protocol: " + protocol + ", valids: " + Object.keys(drivers_1.Protocols).join());
-        }
-        return _this;
-    }
-    RocketChatClient.prototype.resume = function (_a) {
-        var token = _a.token;
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_b.sent()).login({ token: token }, {})];
-                }
-            });
-        });
-    };
-    RocketChatClient.prototype.login = function (credentials) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, _super.prototype.login.call(this, credentials)];
-                    case 1:
-                        _a.sent();
-                        return [2 /*return*/, this.currentLogin && this.resume({ token: this.currentLogin.authToken })];
-                }
-            });
-        });
-    };
-    RocketChatClient.prototype.connect = function (options) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).connect(options)];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.disconnect = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).disconnect()];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.onStreamData = function (event, cb) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).onStreamData(event, cb)];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.subscribe = function (topic) {
-        var args = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            args[_i - 1] = arguments[_i];
-        }
-        return __awaiter(this, void 0, void 0, function () {
-            var _a;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a = (_b.sent())).subscribe.apply(_a, __spread([topic], args))];
-                }
-            });
-        });
-    };
-    RocketChatClient.prototype.unsubscribe = function (subscription) {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).unsubscribe(subscription)];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.unsubscribeAll = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).unsubscribeAll()];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.subscribeRoom = function (rid) {
-        var args = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            args[_i - 1] = arguments[_i];
-        }
-        return __awaiter(this, void 0, void 0, function () {
-            var _a;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a = (_b.sent())).subscribeRoom.apply(_a, __spread([rid], args))];
-                }
-            });
-        });
-    };
-    RocketChatClient.prototype.subscribeNotifyAll = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyAll()];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.subscribeLoggedNotify = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeLoggedNotify()];
-            }
-        }); });
-    };
-    RocketChatClient.prototype.subscribeNotifyUser = function () {
-        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, this.socket];
-                case 1: return [2 /*return*/, (_a.sent()).subscribeNotifyUser()];
-            }
-        }); });
-    };
-    Object.defineProperty(RocketChatClient.prototype, "url", {
-        get: function () {
-            return this.socket.then(function (socket) { return socket.config.host; });
-        },
-        enumerable: true,
-        configurable: true
-    });
-    RocketChatClient.prototype.onMessage = function (cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a.sent()).onMessage(cb)];
-                }
-            });
-        });
-    };
-    RocketChatClient.prototype.methodCall = function (method) {
-        var args = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            args[_i - 1] = arguments[_i];
-        }
-        return __awaiter(this, void 0, void 0, function () {
-            var _a;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0: return [4 /*yield*/, this.socket];
-                    case 1: return [2 /*return*/, (_a = (_b.sent())).methodCall.apply(_a, __spread([method], args))];
-                }
-            });
-        });
-    };
-    return RocketChatClient;
-}(RocketChat_1.default));
-exports.default = RocketChatClient;
-//# sourceMappingURL=Rocketchat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js.map b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js.map
deleted file mode 100644
index 602a146..0000000
--- a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"Rocketchat.js","sourceRoot":"","sources":["../../../src/lib/clients/Rocketchat.ts"],"names":[],"mappings":"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","sourcesContent":["import { ISocket, IDriver, Protocols } from '../drivers'\nimport ClientRest from '../api/RocketChat'\nimport { ILogger, ISocketOptions, ICallback, ISubscription, ICredentials } from '../../interfaces'\nimport { logger as Logger } from '../log'\nexport default class RocketChatClient extends ClientRest implements ISocket {\n  userId: string = ''\n  logger: ILogger = Logger\n  socket: Promise<ISocket | IDriver>\n  config: any\n\n  constructor ({ logger, allPublic, rooms, integrationId, protocol = Protocols.DDP, ...config }: any) {\n    super({ ...config, logger })\n    this.logger = logger\n    switch (protocol) {\n      // case Protocols.MQTT:\n      //   this.socket = import(/* webpackChunkName: 'mqtt' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ ...config, logger }))\n      //   break\n      case Protocols.DDP:\n        this.socket = import(/* webpackChunkName: 'ddp' */ '../drivers/ddp').then(({ DDPDriver }) => new DDPDriver({ ...config, logger }))\n        break\n      default:\n        throw new Error(`Invalid Protocol: ${protocol}, valids: ${Object.keys(Protocols).join()}`)\n    }\n  }\n\n  async resume ({ token }: { token: string }) {\n    return (await this.socket as IDriver).login({ token } as any, {})\n  }\n\n  async login (credentials: ICredentials) {\n    await super.login(credentials)\n    return this.currentLogin && this.resume({ token: this.currentLogin.authToken })\n  }\n\n  async connect (options: ISocketOptions): Promise<any> { return (await this.socket as ISocket).connect(options) }\n  async disconnect (): Promise<any> { return (await this.socket as ISocket).disconnect() }\n  async onStreamData (event: string, cb: ICallback): Promise<any> { return (await this.socket as ISocket).onStreamData(event, cb) }\n  async subscribe (topic: string, ...args: any[]): Promise<ISubscription> { return (await this.socket as ISocket).subscribe(topic, ...args) }\n  async unsubscribe (subscription: ISubscription): Promise<any> { return (await this.socket as ISocket).unsubscribe(subscription) }\n  async unsubscribeAll (): Promise<any> { return (await this.socket as ISocket).unsubscribeAll() }\n  async subscribeRoom (rid: string, ...args: any[]): Promise<ISubscription[]> { return (await this.socket as IDriver).subscribeRoom(rid, ...args) }\n  async subscribeNotifyAll (): Promise<any> { return (await this.socket as IDriver).subscribeNotifyAll() }\n  async subscribeLoggedNotify (): Promise<any> { return (await this.socket as IDriver).subscribeLoggedNotify() }\n  async subscribeNotifyUser (): Promise<any> { return (await this.socket as IDriver).subscribeNotifyUser() }\n  get url () {\n    return this.socket.then((socket) => (socket as IDriver).config.host)\n  }\n  async onMessage (cb: ICallback): Promise<any> {\n    return (await this.socket as IDriver).onMessage(cb)\n  }\n  async methodCall (method: string, ...args: any[]): Promise<ISubscription> { return (await this.socket as IDriver).methodCall(method, ...args) }\n\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.spec.ts b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.spec.ts
new file mode 100644
index 0000000..921b609
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.spec.ts
@@ -0,0 +1,142 @@
+import 'mocha'
+import { apiUser, botUser, mockUser } from '../../utils/config'
+import sinon from 'sinon'
+import { expect } from 'chai'
+import { silence } from '../log'
+import * as settings from '../settings'
+import { testChannelName, testPrivateName } from '../../utils/testing'
+import BotDriver from './Bot'
+import { ISocketOptions, IMessageReceipt, ILogger } from '../../interfaces'
+
+import { Socket } from '../drivers/ddp'
+global.fetch = require('node-fetch-polyfill')
+
+const delay = (ms: number) => new Promise((resolve, reject) => setTimeout(resolve, ms))
+let clock: any
+let PUBLIC_ROOM: string
+let PRIVATE_ROOM: string
+class L implements ILogger {
+  debug (...args: any[]) {
+		// console.log(...args)
+  }
+  info (...args: any[]) {
+		// console.log(...args)
+  }
+  warning (...args: any[]) {
+		// console.warn(...args)
+  }
+  warn (...args: any[]) { // legacy method
+		// return this.warning(...args)
+  }
+  error (...args: any[]) {
+		// console.error(...args)
+  }
+}
+const mockuser = new BotDriver({})
+const botuser = new BotDriver({ logger: new L() })
+const adminuser = new BotDriver({})
+
+describe('RocketChat Client', () => {
+  before(async () => {
+    try {
+      await Promise.all([
+        adminuser.login({ password: apiUser.password, username: apiUser.username })
+      ])
+    } catch (e) { console.log(e) }
+  })
+  describe('connect', () => {
+    context('with localhost connection', () => {
+      it('without args, returns a promise', () => {
+        const promise = botuser.connect({ ...settings } as ISocketOptions)
+        expect(promise.then).to.be.a('function')
+        promise.catch((err) => console.error(err))
+        return promise
+      })
+      it('accepts an error-first callback, providing socket', async () => {
+        return new Promise(resolve => {
+          botuser.connect({ ...settings } as ISocketOptions, (err, socket) => {
+            expect(err).to.equal(null)
+            expect(socket).to.be.an('object')
+            resolve()
+          })
+        })
+      })
+      it('without url takes localhost as default', () => {
+
+        return new Promise(resolve => {
+          botuser.connect({ } as ISocketOptions, (err, socket) => {
+            expect(err).to.eql(null)
+            expect(socket.config.host).to.contain('localhost:3000')
+            resolve()
+          })
+
+        })
+      })
+      it('promise resolves with socket in successful state', () => {
+        return botuser.connect({}).then((socket: any) => {
+          expect(true).to.equal(socket.connected)
+        })
+      })
+    })
+
+    context('with timeout, on expiry', () => {
+      before(async () => {
+        clock = sinon.useFakeTimers(0)
+      })
+      after(() => clock.restore())
+      it('with url, attempts connection at URL', () => {
+        const botuser = new BotDriver({ host: 'localhost:9999', timeout: 100 })
+        return new Promise(resolve => {
+          botuser.connect({}, (err, socket) => {
+			  expect(err).to.be.an('error')
+            resolve()
+          }).catch(() => null)
+          clock.tick(200)
+        })
+      })
+      it('returns error', (done) => {
+        const botuser = new BotDriver({ host: 'localhost:9999', timeout: 100 })
+        let opts = { }
+        botuser.connect(opts, (err, socket: Socket) => {
+          expect(err).to.be.an('error')
+          done()
+        }).catch(() => null)
+        clock.tick(200)
+      })
+      it('without callback, triggers promise catch', () => {
+        const botuser = new BotDriver({ host: 'localhost:9999', timeout: 100 })
+        const promise = botuser.connect({ host: 'localhost:9999', timeout: 100 })
+				.catch((err) => expect(err).to.be.an('error'))
+        clock.tick(200)
+        return promise
+      })
+      it('with callback, provides error to callback', (done) => {
+        const botuser = new BotDriver({ host: 'localhost:9999', timeout: 100 })
+        botuser.connect({ host: 'localhost:9999', timeout: 100 }, (err) => {
+          expect(err).to.be.an('error')
+          done()
+        }).catch(() => null)
+        clock.tick(200)
+      })
+    })
+  })
+  describe('.login', () => {
+    afterEach(() => botuser.logout())
+    it('sets the bot user status to online', async () => {
+      const botuser = new BotDriver({})
+	  await botuser.login({ username: settings.username, password: settings.password })
+	  await delay(1000)
+	  const user = await adminuser.users.info(botUser.username)
+      expect(user.status).to.equal('online')
+    })
+  })
+  describe('.subscribeToMessages', () => {
+    it('resolves with subscription object', async () => {
+      const botuser = new BotDriver({ })
+      await botuser.login({ username: settings.username, password: settings.password })
+      const subscription = await botuser.subscribeToMessages()
+      expect(subscription).to.include.keys(['id', 'name', 'unsubscribe', 'onEvent'])
+    })
+    after(() => botuser.unsubscribeAll())
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.ts b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.ts
new file mode 100644
index 0000000..b5f09ad
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/clients/Rocketchat.ts
@@ -0,0 +1,53 @@
+import { ISocket, IDriver, Protocols } from '../drivers'
+import ClientRest from '../api/RocketChat'
+import { ILogger, ISocketOptions, ICallback, ISubscription, ICredentials } from '../../interfaces'
+import { logger as Logger } from '../log'
+export default class RocketChatClient extends ClientRest implements ISocket {
+  userId: string = ''
+  logger: ILogger = Logger
+  socket: Promise<ISocket | IDriver>
+  config: any
+
+  constructor ({ logger, allPublic, rooms, integrationId, protocol = Protocols.DDP, ...config }: any) {
+    super({ ...config, logger })
+    this.logger = logger
+    switch (protocol) {
+      // case Protocols.MQTT:
+      //   this.socket = import(/* webpackChunkName: 'mqtt' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ ...config, logger }))
+      //   break
+      case Protocols.DDP:
+        this.socket = import(/* webpackChunkName: 'ddp' */ '../drivers/ddp').then(({ DDPDriver }) => new DDPDriver({ ...config, logger }))
+        break
+      default:
+        throw new Error(`Invalid Protocol: ${protocol}, valids: ${Object.keys(Protocols).join()}`)
+    }
+  }
+
+  async resume ({ token }: { token: string }) {
+    return (await this.socket as IDriver).login({ token } as any, {})
+  }
+
+  async login (credentials: ICredentials) {
+    await super.login(credentials)
+    return this.currentLogin && this.resume({ token: this.currentLogin.authToken })
+  }
+
+  async connect (options: ISocketOptions): Promise<any> { return (await this.socket as ISocket).connect(options) }
+  async disconnect (): Promise<any> { return (await this.socket as ISocket).disconnect() }
+  async onStreamData (event: string, cb: ICallback): Promise<any> { return (await this.socket as ISocket).onStreamData(event, cb) }
+  async subscribe (topic: string, ...args: any[]): Promise<ISubscription> { return (await this.socket as ISocket).subscribe(topic, ...args) }
+  async unsubscribe (subscription: ISubscription): Promise<any> { return (await this.socket as ISocket).unsubscribe(subscription) }
+  async unsubscribeAll (): Promise<any> { return (await this.socket as ISocket).unsubscribeAll() }
+  async subscribeRoom (rid: string, ...args: any[]): Promise<ISubscription[]> { return (await this.socket as IDriver).subscribeRoom(rid, ...args) }
+  async subscribeNotifyAll (): Promise<any> { return (await this.socket as IDriver).subscribeNotifyAll() }
+  async subscribeLoggedNotify (): Promise<any> { return (await this.socket as IDriver).subscribeLoggedNotify() }
+  async subscribeNotifyUser (): Promise<any> { return (await this.socket as IDriver).subscribeNotifyUser() }
+  get url () {
+    return this.socket.then((socket) => (socket as IDriver).config.host)
+  }
+  async onMessage (cb: ICallback): Promise<any> {
+    return (await this.socket as IDriver).onMessage(cb)
+  }
+  async methodCall (method: string, ...args: any[]): Promise<ISubscription> { return (await this.socket as IDriver).methodCall(method, ...args) }
+
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.d.ts b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.d.ts
deleted file mode 100644
index 4a2cc4d..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.d.ts
+++ /dev/null
@@ -1,175 +0,0 @@
-/**
- * @module DDPDriver
- * Handles low-level websocket ddp connections and event subscriptions
- */
-/// <reference types="node" />
-import { EventEmitter } from 'tiny-events';
-import { ISocket, IDriver } from './index';
-import { ISocketOptions, ISocketMessageHandler, ISubscription, ICredentials, ILoginResult, ICredentialsPass, ICredentialsOAuth, ICredentialsAuthenticated, ISocketMessageCallback, ICallback, ILogger } from '../../interfaces';
-/** Websocket handler class, manages connections and subscriptions by DDP */
-export declare class Socket extends EventEmitter {
-    resume: ILoginResult | null;
-    sent: number;
-    host: string;
-    lastPing: number;
-    subscriptions: {
-        [id: string]: ISubscription;
-    };
-    handlers: ISocketMessageHandler[];
-    config: ISocketOptions | any;
-    openTimeout?: NodeJS.Timer | number;
-    reopenInterval?: NodeJS.Timer;
-    pingTimeout?: NodeJS.Timer | number;
-    connection?: WebSocket;
-    session?: string;
-    logger: ILogger;
-    /** Create a websocket handler */
-    constructor(options?: ISocketOptions | any, resume?: ILoginResult | null);
-    /**
-     * Open websocket connection, with optional retry interval.
-     * Stores connection, setting up handlers for open/close/message events.
-     * Resumes login if given token.
-     */
-    open: (ms?: number) => Promise<{}>;
-    /** Send handshake message to confirm connection, start pinging. */
-    onOpen: (callback: Function) => Promise<any>;
-    /** Emit close event so it can be used for promise resolve in close() */
-    onClose: (e: any) => Promise<void> | undefined;
-    /**
-     * Find and call matching handlers for incoming message data.
-     * Handlers match on collection, id and/or msg attribute in that order.
-     * Any matched handlers are removed once called.
-     * All collection events are emitted with their `msg` as the event name.
-     */
-    onMessage: (e: any) => void;
-    /** Disconnect the DDP from server and clear all subscriptions. */
-    close: () => Promise<void>;
-    /** Clear connection and try to connect again. */
-    reopen: () => Promise<void>;
-    /** Check if websocket connected and ready. */
-    readonly connected: boolean;
-    /** Check if connected and logged in */
-    readonly loggedIn: boolean;
-    /**
-     * Send an object to the server via Socket. Adds handler to collection to
-     * allow awaiting response matching an expected object. Most responses are
-     * identified by their message event name and the ID they were sent with, but
-     * some responses don't return the ID fallback to just matching on event name.
-     * Data often includes an error attribute if something went wrong, but certain
-     * types of calls send back a different `msg` value instead, e.g. `nosub`.
-     * @param obj       Object to be sent
-     * @param msg       The `data.msg` value to wait for in response
-     * @param errorMsg  An alternate `data.msg` value indicating an error response
-     */
-    send: (obj: any) => Promise<any>;
-    /** Send ping, record time, re-open if nothing comes back, repeat */
-    ping: () => Promise<void>;
-    /** Check if ping-pong to server is within tolerance of 1 missed ping */
-    alive: () => boolean;
-    /**
-     * Calls a method on the server and returns a promise resolved
-     * with the result of the method.
-     * @param method    The name of the method to be called
-     * @param params    An array with the parameters to be sent
-     */
-    call: (method: string, ...params: any[]) => Promise<any>;
-    /**
-     * Login to server and resubscribe to all subs, resolve with user information.
-     * @param credentials User credentials (username/password, oauth or token)
-     */
-    login: (credentials: any) => Promise<ILoginResult>;
-    /** Take variety of login credentials object types for accepted params */
-    loginParams: (credentials: ICredentials | ICredentialsPass | ICredentialsOAuth | ICredentialsAuthenticated | ILoginResult) => ICredentialsPass | ICredentialsOAuth | ICredentialsAuthenticated;
-    /** Logout the current User from the server via Socket. */
-    logout: () => Promise<any>;
-    /** Register a callback to trigger on message events in subscription */
-    onEvent: (id: string, callback: ISocketMessageCallback) => void;
-    /**
-     * Subscribe to a stream on server via socket and returns a promise resolved
-     * with the subscription object when the subscription is ready.
-     * @param name      Stream name to subscribe to
-     * @param params    Params sent to the subscription request
-     */
-    subscribe: (name: string, params: any[], callback?: ISocketMessageCallback | undefined) => Promise<{
-        id: any;
-        name: string;
-        params: any[];
-        unsubscribe: () => Promise<any>;
-        onEvent: (callback: ISocketMessageCallback) => void;
-    }>;
-    /** Subscribe to all pre-configured streams (e.g. on login resume) */
-    subscribeAll: () => Promise<{
-        id: any;
-        name: string;
-        params: any[];
-        unsubscribe: () => Promise<any>;
-        onEvent: (callback: ISocketMessageCallback) => void;
-    }[]>;
-    /** Unsubscribe to server stream, resolve with unsubscribe request result */
-    unsubscribe: (id: any) => Promise<any>;
-    /** Unsubscribe from all active subscriptions and reset collection */
-    unsubscribeAll: () => Promise<{}>;
-}
-export declare class DDPDriver extends EventEmitter implements ISocket, IDriver {
-    logger: ILogger;
-    config: ISocketOptions;
-    /**
-     * Event Emitter for listening to connection (echoes selection of DDP events)
-     * @example
-     *  import { driver } from '@rocket.chat/sdk'
-     *  driver.connect()
-     *  driver.events.on('connected', () => console.log('driver connected'))
-     */
-    /**
-     * An Websocket instance for interacting with Rocket.Chat.
-     * Variable not initialised until `connect` called.
-     */
-    ddp: Socket;
-    /**
-     * Websocket subscriptions, exported for direct polling by adapters
-     * Variable not initialised until `prepMeteorSubscriptions` called.
-     * @deprecated Use `ddp.Socket` instance subscriptions instead.
-     */
-    subscriptions: {
-        [id: string]: ISubscription;
-    };
-    /** Save messages subscription to ensure only one created */
-    messages: ISubscription | undefined;
-    /** Current user object populated from resolved login */
-    userId: string;
-    /** Array of joined room IDs (for reactive queries) */
-    joinedIds: string[];
-    constructor({ host, integrationId, config, logger, ...moreConfigs }?: any);
-    /**
-     * Initialise socket instance with given options or defaults.
-     * Proxies the DDP module socket connection. Resolves with socket when open.
-     * Accepts callback following error-first-pattern.
-     * Error returned or promise rejected on timeout.
-     * @example <caption>Using promise</caption>
-     *  import { driver } from '@rocket.chat/sdk'
-     *  driver.connect()
-     *    .then(() => console.log('connected'))
-     *    .catch((err) => console.error(err))
-     */
-    connect: (c?: any) => Promise<any>;
-    readonly connected: boolean;
-    disconnect: () => Promise<any>;
-    subscribe: (topic: string, eventname: string, ...args: any[]) => Promise<ISubscription>;
-    subscribeNotifyAll: () => Promise<any>;
-    subscribeLoggedNotify: () => Promise<any>;
-    subscribeNotifyUser: () => Promise<any>;
-    subscribeRoom: (rid: string, ...args: any[]) => Promise<ISubscription[]>;
-    /** Login to Rocket.Chat via DDP */
-    login: (credentials: ICredentials, args: any) => Promise<any>;
-    logout: () => Promise<void>;
-    /** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */
-    unsubscribe: (subscription: ISubscription) => Promise<any>;
-    /** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */
-    unsubscribeAll: () => Promise<any>;
-    onStreamData: (event: string, cb: ICallback) => Promise<any>;
-    onMessage: (cb: ICallback) => void;
-    onTyping: (cb: ICallback) => Promise<any>;
-    notifyVisitorTyping: (rid: string, username: string, typing: boolean, token: string) => Promise<any>;
-    ejsonMessage: (message: any) => any;
-    methodCall: (method: string, ...args: any[]) => Promise<any>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js
deleted file mode 100644
index 8f04ff1..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js
+++ /dev/null
@@ -1,722 +0,0 @@
-"use strict";
-/**
- * @module DDPDriver
- * Handles low-level websocket ddp connections and event subscriptions
- */
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-var __read = (this && this.__read) || function (o, n) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator];
-    if (!m) return o;
-    var i = m.call(o), r, ar = [], e;
-    try {
-        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
-    }
-    catch (error) { e = { error: error }; }
-    finally {
-        try {
-            if (r && !r.done && (m = i["return"])) m.call(i);
-        }
-        finally { if (e) throw e.error; }
-    }
-    return ar;
-};
-var __spread = (this && this.__spread) || function () {
-    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
-    return ar;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var universal_websocket_client_1 = __importDefault(require("universal-websocket-client"));
-var tiny_events_1 = require("tiny-events");
-var log_1 = require("../log");
-tiny_events_1.EventEmitter.prototype.removeAllListeners = function (event) {
-    if (event) {
-        this._listeners[event] = [];
-    }
-    else {
-        this._listeners = {};
-    }
-    return [];
-};
-var interfaces_1 = require("../../interfaces");
-var util_1 = require("../util");
-var js_sha256_1 = require("js-sha256");
-/** Websocket handler class, manages connections and subscriptions by DDP */
-var Socket = /** @class */ (function (_super) {
-    __extends(Socket, _super);
-    /** Create a websocket handler */
-    function Socket(options, resume) {
-        if (resume === void 0) { resume = null; }
-        var _this = _super.call(this) || this;
-        _this.resume = resume;
-        _this.sent = 0;
-        _this.lastPing = Date.now();
-        _this.subscriptions = {};
-        _this.handlers = [];
-        /**
-         * Open websocket connection, with optional retry interval.
-         * Stores connection, setting up handlers for open/close/message events.
-         * Resumes login if given token.
-         */
-        _this.open = function (ms) {
-            if (ms === void 0) { ms = _this.config.reopen; }
-            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
-                var connection;
-                var _this = this;
-                return __generator(this, function (_a) {
-                    switch (_a.label) {
-                        case 0:
-                            this.lastPing = Date.now();
-                            return [4 /*yield*/, this.close()];
-                        case 1:
-                            _a.sent();
-                            if (this.reopenInterval)
-                                clearInterval(this.reopenInterval);
-                            this.reopenInterval = setInterval(function () {
-                                return !_this.alive() && _this.reopen();
-                            }, ms);
-                            try {
-                                connection = new universal_websocket_client_1.default(this.host);
-                                connection.onerror = reject;
-                            }
-                            catch (err) {
-                                this.logger.error(err);
-                                return [2 /*return*/, reject(err)];
-                            }
-                            this.connection = connection;
-                            this.connection.onmessage = this.onMessage.bind(this);
-                            this.connection.onclose = this.onClose.bind(this);
-                            this.connection.onopen = this.onOpen.bind(this, resolve);
-                            return [2 /*return*/];
-                    }
-                });
-            }); });
-        };
-        /** Send handshake message to confirm connection, start pinging. */
-        _this.onOpen = function (callback) { return __awaiter(_this, void 0, void 0, function () {
-            var connected;
-            var _this = this;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0: return [4 /*yield*/, this.send({
-                            msg: 'connect',
-                            version: '1',
-                            support: ['1', 'pre2', 'pre1']
-                        })];
-                    case 1:
-                        connected = _a.sent();
-                        this.session = connected.session;
-                        this.ping().catch(function (err) { return _this.logger.error("[ddp] Unable to ping server: " + err.message); });
-                        this.emit('open');
-                        if (!this.resume) return [3 /*break*/, 3];
-                        return [4 /*yield*/, this.login(this.resume)];
-                    case 2:
-                        _a.sent();
-                        _a.label = 3;
-                    case 3: return [2 /*return*/, callback(this.connection)];
-                }
-            });
-        }); };
-        /** Emit close event so it can be used for promise resolve in close() */
-        _this.onClose = function (e) {
-            try {
-                _this.emit('close', e);
-                if (e.code !== 1000) {
-                    return _this.reopen();
-                }
-                else {
-                    if (_this.reopenInterval)
-                        clearInterval(_this.reopenInterval);
-                    _this.openTimeout && clearTimeout(_this.openTimeout);
-                    _this.pingTimeout && clearTimeout(_this.pingTimeout);
-                    delete _this.connection;
-                }
-                _this.logger.info("[ddp] Close (" + e.code + ") " + e.reason);
-            }
-            catch (error) {
-                _this.logger.error(error);
-            }
-        };
-        /**
-         * Find and call matching handlers for incoming message data.
-         * Handlers match on collection, id and/or msg attribute in that order.
-         * Any matched handlers are removed once called.
-         * All collection events are emitted with their `msg` as the event name.
-         */
-        _this.onMessage = function (e) {
-            _this.lastPing = Date.now();
-            void _this.ping();
-            var data = (e.data) ? JSON.parse(e.data) : undefined;
-            _this.logger.debug(data); // 👈  very useful for debugging missing responses
-            if (!data)
-                return _this.logger.error("[ddp] JSON parse error: " + e.message);
-            _this.logger.debug("[ddp] messages received: " + e.data);
-            if (data.collection)
-                _this.emit(data.collection, data);
-            if (data.msg)
-                _this.emit(data.msg, data);
-        };
-        /** Disconnect the DDP from server and clear all subscriptions. */
-        _this.close = function () { return __awaiter(_this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        if (!this.connected) return [3 /*break*/, 2];
-                        this.unsubscribeAll().catch(function (e) { return _this.logger.debug(e); });
-                        return [4 /*yield*/, new Promise(function (resolve) {
-                                if (_this.connection) {
-                                    _this.once('close', resolve);
-                                    _this.connection.close(1000, 'disconnect');
-                                    return;
-                                }
-                            })
-                                .catch(this.logger.error)];
-                    case 1:
-                        _a.sent();
-                        _a.label = 2;
-                    case 2: return [2 /*return*/, Promise.resolve()];
-                }
-            });
-        }); };
-        /** Clear connection and try to connect again. */
-        _this.reopen = function () { return __awaiter(_this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        if (this.openTimeout)
-                            return [2 /*return*/];
-                        return [4 /*yield*/, this.close()];
-                    case 1:
-                        _a.sent();
-                        this.openTimeout = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
-                            var _this = this;
-                            return __generator(this, function (_a) {
-                                switch (_a.label) {
-                                    case 0:
-                                        delete this.openTimeout;
-                                        return [4 /*yield*/, this.open()
-                                                .catch(function (err) { return _this.logger.error("[ddp] Reopen error: " + err.message); })];
-                                    case 1:
-                                        _a.sent();
-                                        return [2 /*return*/];
-                                }
-                            });
-                        }); }, this.config.reopen);
-                        return [2 /*return*/];
-                }
-            });
-        }); };
-        /**
-         * Send an object to the server via Socket. Adds handler to collection to
-         * allow awaiting response matching an expected object. Most responses are
-         * identified by their message event name and the ID they were sent with, but
-         * some responses don't return the ID fallback to just matching on event name.
-         * Data often includes an error attribute if something went wrong, but certain
-         * types of calls send back a different `msg` value instead, e.g. `nosub`.
-         * @param obj       Object to be sent
-         * @param msg       The `data.msg` value to wait for in response
-         * @param errorMsg  An alternate `data.msg` value indicating an error response
-         */
-        _this.send = function (obj) { return __awaiter(_this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                return [2 /*return*/, new Promise(function (resolve, reject) {
-                        if (!_this.connection)
-                            throw new Error('[ddp] sending without open connection');
-                        var id = obj.id || "ddp-" + _this.sent;
-                        _this.sent += 1;
-                        var data = __assign({}, obj, (/connect|ping|pong/.test(obj.msg) ? {} : { id: id }));
-                        var stringdata = JSON.stringify(data);
-                        _this.logger.debug("[ddp] sending message: " + stringdata);
-                        _this.connection.send(stringdata);
-                        _this.once('disconnected', reject);
-                        var listener = (data.msg === 'ping' && 'pong') || (data.msg === 'connect' && 'connected') || data.id;
-                        if (!listener) {
-                            return resolve();
-                        }
-                        _this.once(listener, function (result) {
-                            _this.off('disconnect', reject);
-                            return (result.error ? reject(result.error) : resolve(__assign({}, (/connect|ping|pong/.test(obj.msg) ? {} : { id: id }), result)));
-                        });
-                    })];
-            });
-        }); };
-        /** Send ping, record time, re-open if nothing comes back, repeat */
-        _this.ping = function () { return __awaiter(_this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                this.pingTimeout && clearTimeout(this.pingTimeout);
-                this.pingTimeout = setTimeout(function () {
-                    _this.send({ msg: 'ping' })
-                        .then(function () {
-                        return _this.ping();
-                    })
-                        .catch(function () { return _this.reopen(); });
-                }, this.config.ping);
-                return [2 /*return*/];
-            });
-        }); };
-        /** Check if ping-pong to server is within tolerance of 1 missed ping */
-        _this.alive = function () {
-            if (!_this.lastPing)
-                return false;
-            return (Date.now() - _this.lastPing <= _this.config.ping * 2);
-        };
-        /**
-         * Calls a method on the server and returns a promise resolved
-         * with the result of the method.
-         * @param method    The name of the method to be called
-         * @param params    An array with the parameters to be sent
-         */
-        _this.call = function (method) {
-            var params = [];
-            for (var _i = 1; _i < arguments.length; _i++) {
-                params[_i - 1] = arguments[_i];
-            }
-            return __awaiter(_this, void 0, void 0, function () {
-                var response;
-                var _this = this;
-                return __generator(this, function (_a) {
-                    switch (_a.label) {
-                        case 0: return [4 /*yield*/, this.send({ msg: 'method', method: method, params: params })
-                                .catch(function (err) {
-                                _this.logger.error("[ddp] Call error: " + err.message);
-                                throw err;
-                            })];
-                        case 1:
-                            response = _a.sent();
-                            return [2 /*return*/, (response.result) ? response.result : response];
-                    }
-                });
-            });
-        };
-        /**
-         * Login to server and resubscribe to all subs, resolve with user information.
-         * @param credentials User credentials (username/password, oauth or token)
-         */
-        _this.login = function (credentials) { return __awaiter(_this, void 0, void 0, function () {
-            var params, _a;
-            return __generator(this, function (_b) {
-                switch (_b.label) {
-                    case 0:
-                        params = this.loginParams(credentials);
-                        _a = this;
-                        return [4 /*yield*/, this.call('login', params)];
-                    case 1:
-                        _a.resume = (_b.sent());
-                        return [4 /*yield*/, this.subscribeAll()];
-                    case 2:
-                        _b.sent();
-                        this.emit('login', this.resume);
-                        return [2 /*return*/, this.resume];
-                }
-            });
-        }); };
-        /** Take variety of login credentials object types for accepted params */
-        _this.loginParams = function (credentials) {
-            if (interfaces_1.isLoginPass(credentials) ||
-                interfaces_1.isLoginOAuth(credentials) ||
-                interfaces_1.isLoginAuthenticated(credentials)) {
-                return credentials;
-            }
-            if (interfaces_1.isLoginResult(credentials)) {
-                var params_1 = {
-                    resume: credentials.token
-                };
-                return params_1;
-            }
-            var params = {
-                user: { username: credentials.username },
-                password: {
-                    digest: js_sha256_1.sha256(credentials.password),
-                    algorithm: 'sha-256'
-                }
-            };
-            return params;
-        };
-        /** Logout the current User from the server via Socket. */
-        _this.logout = function () {
-            _this.resume = null;
-            return _this.unsubscribeAll()
-                .then(function () { return _this.call('logout'); });
-        };
-        /** Register a callback to trigger on message events in subscription */
-        _this.onEvent = function (id, callback) {
-            _this.on(id, callback);
-        };
-        /**
-         * Subscribe to a stream on server via socket and returns a promise resolved
-         * with the subscription object when the subscription is ready.
-         * @param name      Stream name to subscribe to
-         * @param params    Params sent to the subscription request
-         */
-        _this.subscribe = function (name, params, callback) {
-            _this.logger.info("[ddp] Subscribe to " + name + ", param: " + JSON.stringify(params));
-            return _this.send({ msg: 'sub', name: name, params: params })
-                .then(function (result) {
-                var id = (result.subs) ? result.subs[0] : undefined;
-                var unsubscribe = _this.unsubscribe.bind(_this, id);
-                var onEvent = _this.onEvent.bind(_this, name);
-                var subscription = { id: id, name: name, params: params, unsubscribe: unsubscribe, onEvent: onEvent };
-                if (callback)
-                    subscription.onEvent(callback);
-                _this.subscriptions[id] = subscription;
-                return subscription;
-            })
-                .catch(function (err) {
-                _this.logger.error("[ddp] Subscribe error: " + err.message);
-                throw err;
-            });
-        };
-        /** Subscribe to all pre-configured streams (e.g. on login resume) */
-        _this.subscribeAll = function () {
-            var subscriptions = Object.keys(_this.subscriptions || {}).map(function (key) {
-                var _a = _this.subscriptions[key], name = _a.name, params = _a.params;
-                return _this.subscribe(name, params);
-            });
-            return Promise.all(subscriptions);
-        };
-        /** Unsubscribe to server stream, resolve with unsubscribe request result */
-        _this.unsubscribe = function (id) {
-            if (!_this.subscriptions[id])
-                return Promise.reject(id);
-            delete _this.subscriptions[id];
-            return _this.send({ msg: 'unsub', id: id })
-                .then(function (data) { return data.result || data.subs; })
-                .catch(function (err) {
-                if (!err.msg && err.msg !== 'nosub') {
-                    _this.logger.error("[ddp] Unsubscribe error: " + err.message);
-                    throw err;
-                }
-            });
-        };
-        /** Unsubscribe from all active subscriptions and reset collection */
-        _this.unsubscribeAll = function () {
-            var unsubAll = Object.keys(_this.subscriptions).map(function (id) {
-                return _this.subscriptions[id].unsubscribe();
-            });
-            return Promise.all(unsubAll)
-                .then(function () { return _this.subscriptions = {}; });
-        };
-        _this.logger = options.logger || log_1.logger;
-        _this.config = {
-            host: options.host || 'http://localhost:3000',
-            useSsl: options.useSsl || false,
-            reopen: options.reopen || 10000,
-            ping: options.timeout || 30000
-        };
-        _this.host = util_1.hostToWS(_this.config.host, _this.config.useSsl) + "/websocket";
-        _this.on('ping', function () {
-            _this.send({ msg: 'pong' }).then(_this.logger.debug, _this.logger.error);
-        });
-        _this.on('result', function (data) { return _this.emit(data.id, { id: data.id, result: data.result, error: data.error }); });
-        _this.on('ready', function (data) { return _this.emit(data.subs[0], data); });
-        return _this;
-    }
-    Object.defineProperty(Socket.prototype, "connected", {
-        /** Check if websocket connected and ready. */
-        get: function () {
-            return !!(this.connection &&
-                this.connection.readyState === 1 &&
-                this.alive());
-        },
-        enumerable: true,
-        configurable: true
-    });
-    Object.defineProperty(Socket.prototype, "loggedIn", {
-        /** Check if connected and logged in */
-        get: function () {
-            return (this.connected && !!this.resume);
-        },
-        enumerable: true,
-        configurable: true
-    });
-    return Socket;
-}(tiny_events_1.EventEmitter));
-exports.Socket = Socket;
-var DDPDriver = /** @class */ (function (_super) {
-    __extends(DDPDriver, _super);
-    function DDPDriver(_a) {
-        if (_a === void 0) { _a = {}; }
-        var _b = _a.host, host = _b === void 0 ? 'localhost:3000' : _b, integrationId = _a.integrationId, config = _a.config, _c = _a.logger, logger = _c === void 0 ? log_1.logger : _c, moreConfigs = __rest(_a, ["host", "integrationId", "config", "logger"]);
-        var _this = _super.call(this) || this;
-        /**
-         * Websocket subscriptions, exported for direct polling by adapters
-         * Variable not initialised until `prepMeteorSubscriptions` called.
-         * @deprecated Use `ddp.Socket` instance subscriptions instead.
-         */
-        _this.subscriptions = {};
-        /** Current user object populated from resolved login */
-        _this.userId = '';
-        /** Array of joined room IDs (for reactive queries) */
-        _this.joinedIds = [];
-        /**
-         * Initialise socket instance with given options or defaults.
-         * Proxies the DDP module socket connection. Resolves with socket when open.
-         * Accepts callback following error-first-pattern.
-         * Error returned or promise rejected on timeout.
-         * @example <caption>Using promise</caption>
-         *  import { driver } from '@rocket.chat/sdk'
-         *  driver.connect()
-         *    .then(() => console.log('connected'))
-         *    .catch((err) => console.error(err))
-         */
-        _this.connect = function (c) {
-            if (c === void 0) { c = {}; }
-            if (_this.connected) {
-                return Promise.resolve(_this);
-            }
-            var config = __assign({}, _this.config, c); // override defaults
-            return new Promise(function (resolve, reject) {
-                _this.logger.info('[driver] Connecting', config);
-                _this.subscriptions = _this.ddp.subscriptions;
-                _this.ddp.open().catch(function (err) {
-                    _this.logger.error("[driver] Failed to connect: " + err.message);
-                    reject(err);
-                });
-                _this.ddp.on('open', function () { return _this.emit('connected'); }); // echo ddp event
-                var cancelled = false;
-                var rejectionTimeout = setTimeout(function () {
-                    _this.logger.info("[driver] Timeout (" + config.timeout + ")");
-                    var err = new Error('Socket connection timeout');
-                    cancelled = true;
-                    _this.ddp.removeAllListeners('connected');
-                    reject(err);
-                }, config.timeout);
-                // if to avoid condition where timeout happens before listener to 'connected' is added
-                // and this listener is not removed (because it was added after the removal)
-                if (!cancelled) {
-                    _this.once('connected', function () {
-                        _this.logger.info('[driver] Connected');
-                        if (cancelled)
-                            return _this.ddp.close(); // cancel if already rejected
-                        clearTimeout(rejectionTimeout);
-                        resolve(_this);
-                    });
-                }
-            });
-        };
-        _this.disconnect = function () {
-            return _this.ddp.close();
-        };
-        _this.subscribe = function (topic, eventname) {
-            var args = [];
-            for (var _i = 2; _i < arguments.length; _i++) {
-                args[_i - 2] = arguments[_i];
-            }
-            _this.logger.info("[DDP driver] Subscribing to " + topic + " | " + JSON.stringify(args));
-            return _this.ddp.subscribe(topic, [eventname, { 'useCollection': false, 'args': args }]);
-        };
-        _this.subscribeNotifyAll = function () {
-            var topic = 'stream-notify-all';
-            return Promise.all([
-                'roles-change',
-                'updateEmojiCustom',
-                'deleteEmojiCustom',
-                'updateAvatar',
-                'public-settings-changed',
-                'permissions-changed'
-            ].map(function (event) { return _this.subscribe(topic, event, false); }));
-        };
-        _this.subscribeLoggedNotify = function () {
-            var topic = 'stream-notify-logged';
-            return Promise.all([
-                'Users:NameChanged',
-                'Users:Deleted',
-                'updateAvatar',
-                'updateEmojiCustom',
-                'deleteEmojiCustom',
-                'roles-change'
-            ].map(function (event) { return _this.subscribe(topic, event, false); }));
-        };
-        _this.subscribeNotifyUser = function () {
-            var topic = 'stream-notify-user';
-            return Promise.all([
-                'message',
-                'otr',
-                'webrtc',
-                'notification',
-                'rooms-changed',
-                'subscriptions-changed',
-                'uiInteraction'
-            ].map(function (event) { return _this.subscribe(topic, _this.userId + "/" + event, false); }));
-        };
-        _this.subscribeRoom = function (rid) {
-            var args = [];
-            for (var _i = 1; _i < arguments.length; _i++) {
-                args[_i - 1] = arguments[_i];
-            }
-            var topic = 'stream-notify-room';
-            return Promise.all([
-                _this.subscribe.apply(_this, __spread(['stream-room-messages', rid], args)),
-                _this.subscribe.apply(_this, __spread([topic, rid + "/typing"], args)),
-                _this.subscribe.apply(_this, __spread([topic, rid + "/deleteMessage"], args))
-            ]);
-        };
-        /** Login to Rocket.Chat via DDP */
-        _this.login = function (credentials, args) { return __awaiter(_this, void 0, void 0, function () {
-            var login;
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        if (!(!this.ddp || !this.ddp.connected)) return [3 /*break*/, 2];
-                        return [4 /*yield*/, this.connect()];
-                    case 1:
-                        _a.sent();
-                        _a.label = 2;
-                    case 2:
-                        this.logger.info("[DDP driver] Login with " + JSON.stringify(credentials));
-                        return [4 /*yield*/, this.ddp.login(credentials)];
-                    case 3:
-                        login = _a.sent();
-                        this.userId = login.id;
-                        return [2 /*return*/, login];
-                }
-            });
-        }); };
-        _this.logout = function () { return __awaiter(_this, void 0, void 0, function () {
-            return __generator(this, function (_a) {
-                switch (_a.label) {
-                    case 0:
-                        if (!(this.ddp && this.ddp.connected)) return [3 /*break*/, 2];
-                        return [4 /*yield*/, this.ddp.logout()];
-                    case 1:
-                        _a.sent();
-                        _a.label = 2;
-                    case 2: return [2 /*return*/];
-                }
-            });
-        }); };
-        /** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */
-        _this.unsubscribe = function (subscription) {
-            return _this.ddp.unsubscribe(subscription.id);
-        };
-        /** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */
-        _this.unsubscribeAll = function () {
-            return _this.ddp.unsubscribeAll();
-        };
-        _this.onStreamData = function (event, cb) {
-            function listener(message) {
-                cb((message));
-            }
-            return Promise.resolve(_this.ddp.on(event, listener))
-                .then(function () { return ({
-                stop: function () { return _this.ddp.off(event, listener); }
-            }); });
-        };
-        _this.onMessage = function (cb) {
-            _this.ddp.on('stream-room-messages', function (_a) {
-                var _b = __read(_a.fields.args, 1), message = _b[0];
-                return cb(_this.ejsonMessage(message));
-            });
-        };
-        _this.onTyping = function (cb) {
-            return _this.ddp.on('stream-notify-room', function (_a) {
-                var _b = __read(_a.fields.args, 2), username = _b[0], isTyping = _b[1];
-                cb(username, isTyping);
-            });
-        };
-        _this.notifyVisitorTyping = function (rid, username, typing, token) {
-            return _this.ddp.call('stream-notify-room', rid + "/typing", username, typing, { token: token });
-        };
-        _this.ejsonMessage = function (message) {
-            if (message.ts) {
-                message.ts = new Date(message.ts.$date);
-            }
-            return message;
-        };
-        _this.methodCall = function (method) {
-            var _a;
-            var args = [];
-            for (var _i = 1; _i < arguments.length; _i++) {
-                args[_i - 1] = arguments[_i];
-            }
-            return (_a = _this.ddp).call.apply(_a, __spread([method], args));
-        };
-        _this.config = __assign({}, config, moreConfigs, { host: host.replace(/(^\w+:|^)\/\//, ''), timeout: 20000 });
-        _this.ddp = new Socket(__assign({}, _this.config, { logger: logger }));
-        _this.logger = logger;
-        return _this;
-    }
-    Object.defineProperty(DDPDriver.prototype, "connected", {
-        get: function () {
-            return !!this.ddp.connected;
-        },
-        enumerable: true,
-        configurable: true
-    });
-    return DDPDriver;
-}(tiny_events_1.EventEmitter));
-exports.DDPDriver = DDPDriver;
-//# sourceMappingURL=ddp.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js.map b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js.map
deleted file mode 100644
index b8339d7..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"ddp.js","sourceRoot":"","sources":["../../../src/lib/drivers/ddp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @module DDPDriver\n * Handles low-level websocket ddp connections and event subscriptions\n */\n\nimport WebSocket from 'universal-websocket-client'\nimport { EventEmitter } from 'tiny-events'\n\nimport { logger as Logger } from '../log'\nimport { ISocket, IDriver } from './index'\n\nEventEmitter.prototype.removeAllListeners = function (event?: string | any): any {\n  if (event) {\n    this._listeners[event] = []\n  } else {\n    this._listeners = {}\n  }\n  return [] as any\n}\n\nimport {\n  ISocketOptions,\n  ISocketMessageHandler,\n  ISubscription,\n  ICredentials,\n  ILoginResult,\n  ICredentialsPass,\n  isLoginPass,\n  ICredentialsOAuth,\n  isLoginOAuth,\n  ICredentialsAuthenticated,\n  isLoginAuthenticated,\n  isLoginResult,\n  ISocketMessageCallback,\n\tICallback,\n\tILogger\n} from '../../interfaces'\n\nimport { hostToWS } from '../util'\nimport { sha256 } from 'js-sha256'\n\n/** Websocket handler class, manages connections and subscriptions by DDP */\nexport class Socket extends EventEmitter {\n  sent = 0\n  host: string\n  lastPing = Date.now()\n  subscriptions: { [id: string]: ISubscription } = {}\n  handlers: ISocketMessageHandler[] = []\n  config: ISocketOptions | any\n  openTimeout?: NodeJS.Timer | number\n  reopenInterval?: NodeJS.Timer\n  pingTimeout?: NodeJS.Timer | number\n  connection?: WebSocket\n  session?: string\n  logger: ILogger\n\n  /** Create a websocket handler */\n  constructor (\n    options?: ISocketOptions | any,\n    public resume: ILoginResult | null = null\n  ) {\n    super()\n    this.logger = options.logger || Logger\n    this.config = {\n      host: options.host || 'http://localhost:3000',\n      useSsl: options.useSsl || false,\n      reopen: options.reopen || 10000,\n      ping: options.timeout || 30000\n    }\n\n    this.host = `${hostToWS(this.config.host, this.config.useSsl)}/websocket`\n\n    this.on('ping', () => {\n      this.send({ msg: 'pong' }).then(this.logger.debug, this.logger.error)\n    })\n\n    this.on('result', (data: any) => this.emit(data.id, { id: data.id, result: data.result, error: data.error }))\n    this.on('ready', (data: any) => this.emit(data.subs[0], data))\n  }\n\n  /**\n   * Open websocket connection, with optional retry interval.\n   * Stores connection, setting up handlers for open/close/message events.\n   * Resumes login if given token.\n   */\n  open = (ms: number = this.config.reopen) => {\n    return new Promise(async (resolve, reject) => {\n      let connection: WebSocket\n      this.lastPing = Date.now()\n      await this.close()\n      if (this.reopenInterval) clearInterval(this.reopenInterval)\n      this.reopenInterval = setInterval(() => {\n        return !this.alive() && this.reopen()\n      }, ms)\n      try {\n        connection = new WebSocket(this.host)\n        connection.onerror = reject\n      } catch (err) {\n        this.logger.error(err)\n        return reject(err)\n      }\n      this.connection = connection\n      this.connection.onmessage = this.onMessage.bind(this)\n      this.connection.onclose = this.onClose.bind(this)\n      this.connection.onopen = this.onOpen.bind(this, resolve)\n    })\n  }\n\n  /** Send handshake message to confirm connection, start pinging. */\n  onOpen = async (callback: Function) => {\n    const connected = await this.send({\n      msg: 'connect',\n      version: '1',\n      support: ['1', 'pre2', 'pre1']\n    })\n    this.session = connected.session\n    this.ping().catch((err) => this.logger.error(`[ddp] Unable to ping server: ${err.message}`))\n    this.emit('open')\n    if (this.resume) await this.login(this.resume)\n    return callback(this.connection)\n  }\n\n  /** Emit close event so it can be used for promise resolve in close() */\n  onClose = (e: any) => {\n    try {\n      this.emit('close', e)\n      if (e.code !== 1000) {\n        return this.reopen()\n      } else {\n        if (this.reopenInterval) clearInterval(this.reopenInterval)\n        this.openTimeout && clearTimeout(this.openTimeout as any)\n        this.pingTimeout && clearTimeout(this.pingTimeout as any)\n        delete this.connection\n      }\n      this.logger.info(`[ddp] Close (${e.code}) ${e.reason}`)\n\n    } catch (error) {\n      this.logger.error(error)\n    }\n  }\n\n  /**\n   * Find and call matching handlers for incoming message data.\n   * Handlers match on collection, id and/or msg attribute in that order.\n   * Any matched handlers are removed once called.\n   * All collection events are emitted with their `msg` as the event name.\n   */\n  onMessage = (e: any) => {\n    this.lastPing = Date.now()\n    void this.ping()\n    const data = (e.data) ? JSON.parse(e.data) : undefined\n    this.logger.debug(data) // 👈  very useful for debugging missing responses\n    if (!data) return this.logger.error(`[ddp] JSON parse error: ${e.message}`)\n    this.logger.debug(`[ddp] messages received: ${e.data}`)\n    if (data.collection) this.emit(data.collection, data)\n    if (data.msg) this.emit(data.msg, data)\n  }\n\n  /** Disconnect the DDP from server and clear all subscriptions. */\n  close = async () => {\n    if (this.connected) {\n      this.unsubscribeAll().catch(e => this.logger.debug(e))\n      await new Promise((resolve) => {\n        if (this.connection) {\n          this.once('close', resolve)\n          this.connection.close(1000, 'disconnect')\n          return\n        }\n      })\n      .catch(this.logger.error)\n    }\n    return Promise.resolve()\n  }\n\n  /** Clear connection and try to connect again. */\n  reopen = async () => {\n    if (this.openTimeout) return\n    await this.close()\n    this.openTimeout = setTimeout(async () => {\n      delete this.openTimeout\n      await this.open()\n        .catch((err) => this.logger.error(`[ddp] Reopen error: ${err.message}`))\n    }, this.config.reopen)\n  }\n\n  /** Check if websocket connected and ready. */\n  get connected () {\n    return !!(\n      this.connection &&\n      this.connection.readyState === 1 &&\n      this.alive()\n    )\n  }\n\n  /** Check if connected and logged in */\n  get loggedIn () {\n    return (this.connected && !!this.resume)\n  }\n\n  /**\n   * Send an object to the server via Socket. Adds handler to collection to\n   * allow awaiting response matching an expected object. Most responses are\n   * identified by their message event name and the ID they were sent with, but\n   * some responses don't return the ID fallback to just matching on event name.\n   * Data often includes an error attribute if something went wrong, but certain\n   * types of calls send back a different `msg` value instead, e.g. `nosub`.\n   * @param obj       Object to be sent\n   * @param msg       The `data.msg` value to wait for in response\n   * @param errorMsg  An alternate `data.msg` value indicating an error response\n   */\n  send = async (obj: any): Promise<any> => {\n    return new Promise((resolve, reject) => {\n      if (!this.connection) throw new Error('[ddp] sending without open connection')\n      const id = obj.id || `ddp-${ this.sent }`\n      this.sent += 1\n      const data = { ...obj, ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) }\n      const stringdata = JSON.stringify(data)\n      this.logger.debug(`[ddp] sending message: ${stringdata}`)\n      this.connection.send(stringdata)\n\n      this.once('disconnected', reject)\n      const listener = (data.msg === 'ping' && 'pong') || (data.msg === 'connect' && 'connected') || data.id\n      if (!listener) {\n        return resolve()\n      }\n      this.once(listener, (result: any) => {\n        this.off('disconnect', reject)\n        return (result.error ? reject(result.error) : resolve({ ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) , ...result }))\n      })\n    })\n  }\n\n  /** Send ping, record time, re-open if nothing comes back, repeat */\n  ping = async () => {\n    this.pingTimeout && clearTimeout(this.pingTimeout as any)\n    this.pingTimeout = setTimeout(() => {\n      this.send({ msg: 'ping' })\n        .then(() => {\n          return this.ping()\n        })\n        .catch(() => this.reopen())\n    }, this.config.ping)\n  }\n  /** Check if ping-pong to server is within tolerance of 1 missed ping */\n  alive = () => {\n    if (!this.lastPing) return false\n    return (Date.now() - this.lastPing <= this.config.ping * 2)\n  }\n\n  /**\n   * Calls a method on the server and returns a promise resolved\n   * with the result of the method.\n   * @param method    The name of the method to be called\n   * @param params    An array with the parameters to be sent\n   */\n  call = async (method: string, ...params: any[]) => {\n    const response = await this.send({ msg: 'method', method, params })\n      .catch((err) => {\n        this.logger.error(`[ddp] Call error: ${err.message}`)\n        throw err\n      })\n    return (response.result) ? response.result : response\n  }\n\n  /**\n   * Login to server and resubscribe to all subs, resolve with user information.\n   * @param credentials User credentials (username/password, oauth or token)\n   */\n  login = async (credentials: any) => {\n    const params = this.loginParams(credentials)\n    this.resume = (await this.call('login', params) as ILoginResult)\n    await this.subscribeAll()\n    this.emit('login', this.resume)\n    return this.resume\n  }\n\n  /** Take variety of login credentials object types for accepted params */\n  loginParams = (\n    credentials:\n      ICredentialsPass |\n      ICredentialsOAuth |\n      ICredentialsAuthenticated |\n      ILoginResult |\n      ICredentials\n  ) => {\n    if (\n      isLoginPass(credentials) ||\n      isLoginOAuth(credentials) ||\n      isLoginAuthenticated(credentials)\n    ) {\n      return credentials\n    }\n    if (isLoginResult(credentials)) {\n      const params: ICredentialsAuthenticated = {\n        resume: credentials.token\n      }\n      return params\n    }\n    const params: ICredentialsPass = {\n      user: { username: credentials.username },\n      password: {\n        digest: sha256(credentials.password),\n        algorithm: 'sha-256'\n      }\n    }\n    return params\n  }\n\n  /** Logout the current User from the server via Socket. */\n  logout = () => {\n    this.resume = null\n    return this.unsubscribeAll()\n\t\t\t.then(() => this.call('logout'))\n  }\n\n  /** Register a callback to trigger on message events in subscription */\n  onEvent = (id: string, callback: ISocketMessageCallback) => {\n    this.on(id, callback)\n  }\n\n  /**\n   * Subscribe to a stream on server via socket and returns a promise resolved\n   * with the subscription object when the subscription is ready.\n   * @param name      Stream name to subscribe to\n   * @param params    Params sent to the subscription request\n   */\n  subscribe = (name: string, params: any[], callback ?: ISocketMessageCallback) => {\n    this.logger.info(`[ddp] Subscribe to ${name}, param: ${JSON.stringify(params)}`)\n    return this.send({ msg: 'sub', name, params })\n      .then((result) => {\n        const id = (result.subs) ? result.subs[0] : undefined\n        const unsubscribe = this.unsubscribe.bind(this, id)\n        const onEvent = this.onEvent.bind(this, name)\n        const subscription = { id, name, params, unsubscribe, onEvent }\n        if (callback) subscription.onEvent(callback)\n        this.subscriptions[id] = subscription\n        return subscription\n      })\n      .catch((err) => {\n        this.logger.error(`[ddp] Subscribe error: ${err.message}`)\n        throw err\n      })\n  }\n\n  /** Subscribe to all pre-configured streams (e.g. on login resume) */\n  subscribeAll = () => {\n    const subscriptions = Object.keys(this.subscriptions || {}).map((key) => {\n      const { name, params } = this.subscriptions[key]\n      return this.subscribe(name, params)\n    })\n    return Promise.all(subscriptions)\n  }\n\n  /** Unsubscribe to server stream, resolve with unsubscribe request result */\n  unsubscribe = (id: any) => {\n    if (!this.subscriptions[id]) return Promise.reject(id)\n    delete this.subscriptions[id]\n    return this.send({ msg: 'unsub', id })\n      .then((data: any) => data.result || data.subs)\n      .catch((err) => {\n        if (!err.msg && err.msg !== 'nosub') {\n          this.logger.error(`[ddp] Unsubscribe error: ${err.message}`)\n          throw err\n        }\n      })\n  }\n\n  /** Unsubscribe from all active subscriptions and reset collection */\n  unsubscribeAll = () => {\n    const unsubAll = Object.keys(this.subscriptions).map((id) => {\n      return this.subscriptions[id].unsubscribe()\n    })\n    return Promise.all(unsubAll)\n      .then(() => this.subscriptions = {})\n  }\n}\n\nexport class DDPDriver extends EventEmitter implements ISocket, IDriver {\n  logger: ILogger\n  config: ISocketOptions\n\t/**\n\t * Event Emitter for listening to connection (echoes selection of DDP events)\n\t * @example\n\t *  import { driver } from '@rocket.chat/sdk'\n\t *  driver.connect()\n\t *  driver.events.on('connected', () => console.log('driver connected'))\n\t */\n\t// events = new EventEmitter()\n\n\t/**\n\t * An Websocket instance for interacting with Rocket.Chat.\n\t * Variable not initialised until `connect` called.\n\t */\n  ddp: Socket\n\n\t/**\n\t * Websocket subscriptions, exported for direct polling by adapters\n\t * Variable not initialised until `prepMeteorSubscriptions` called.\n\t * @deprecated Use `ddp.Socket` instance subscriptions instead.\n\t */\n  subscriptions: { [id: string]: ISubscription } = {}\n\n\t/** Save messages subscription to ensure only one created */\n  messages: ISubscription | undefined\n\n\t/** Current user object populated from resolved login */\n  userId: string = ''\n\n\t/** Array of joined room IDs (for reactive queries) */\n  joinedIds: string[] = []\n\n  constructor ({ host = 'localhost:3000', integrationId, config, logger = Logger, ...moreConfigs }: any = {}) {\n    super()\n\n    this.config = {\n      ...config,\n      ...moreConfigs,\n      host: host.replace(/(^\\w+:|^)\\/\\//, ''),\n      timeout: 20000\n\t\t\t// reopen: number\n\t\t\t// ping: number\n\t\t\t// close: number\n\t\t\t// integration: string\n    }\n    this.ddp = new Socket({ ...this.config, logger })\n    this.logger = logger\n  }\n\n\t/**\n\t * Initialise socket instance with given options or defaults.\n\t * Proxies the DDP module socket connection. Resolves with socket when open.\n\t * Accepts callback following error-first-pattern.\n\t * Error returned or promise rejected on timeout.\n\t * @example <caption>Using promise</caption>\n\t *  import { driver } from '@rocket.chat/sdk'\n\t *  driver.connect()\n\t *    .then(() => console.log('connected'))\n\t *    .catch((err) => console.error(err))\n\t */\n  connect = (c: any = {}): Promise<any> => {\n    if (this.connected) {\n      return Promise.resolve(this)\n    }\n    const config: ISocketOptions = { ...this.config, ...c } // override defaults\n\n    return new Promise((resolve, reject) => {\n      this.logger.info('[driver] Connecting', config)\n      this.subscriptions = this.ddp.subscriptions\n      this.ddp.open().catch((err: Error) => {\n        this.logger.error(`[driver] Failed to connect: ${err.message}`)\n        reject(err)\n      })\n\n      this.ddp.on('open', () => this.emit('connected')) // echo ddp event\n\n      let cancelled = false\n      const rejectionTimeout = setTimeout(() => {\n        this.logger.info(`[driver] Timeout (${config.timeout})`)\n        const err = new Error('Socket connection timeout')\n        cancelled = true\n        this.ddp.removeAllListeners('connected')\n        reject(err)\n      }, config.timeout)\n\n\t\t\t// if to avoid condition where timeout happens before listener to 'connected' is added\n\t\t\t// and this listener is not removed (because it was added after the removal)\n      if (!cancelled) {\n        this.once('connected', () => {\n          this.logger.info('[driver] Connected')\n          if (cancelled) return this.ddp.close() // cancel if already rejected\n          clearTimeout(rejectionTimeout)\n          resolve(this as IDriver)\n        })\n      }\n    })\n  }\n\n  get connected (): boolean {\n    return !!this.ddp.connected\n  }\n\n  disconnect = (): Promise<any> => {\n    return this.ddp.close()\n  }\n\n  subscribe = (topic: string, eventname: string, ...args: any[]): Promise<ISubscription> => {\n    this.logger.info(`[DDP driver] Subscribing to ${topic} | ${JSON.stringify(args)}`)\n    return this.ddp.subscribe(topic, [eventname, { 'useCollection': false, 'args': args }])\n  }\n\n  subscribeNotifyAll = (): Promise< any> => {\n    const topic = 'stream-notify-all'\n    return Promise.all([\n      'roles-change',\n      'updateEmojiCustom',\n      'deleteEmojiCustom',\n      'updateAvatar',\n      'public-settings-changed',\n      'permissions-changed'\n    ].map(event => this.subscribe(topic, event, false)))\n  }\n\n  subscribeLoggedNotify = (): Promise<any> => {\n    const topic = 'stream-notify-logged'\n    return Promise.all([\n      'Users:NameChanged',\n      'Users:Deleted',\n      'updateAvatar',\n      'updateEmojiCustom',\n      'deleteEmojiCustom',\n      'roles-change'\n    ].map(event => this.subscribe(topic, event, false)))\n  }\n\n  subscribeNotifyUser = (): Promise<any> => {\n    const topic = 'stream-notify-user'\n    return Promise.all([\n      'message',\n      'otr',\n      'webrtc',\n      'notification',\n      'rooms-changed',\n      'subscriptions-changed',\n      'uiInteraction'\n    ].map(event => this.subscribe(topic, `${this.userId}/${event}`, false)))\n  }\n\n  subscribeRoom = (rid: string, ...args: any[]): Promise<ISubscription[]> => {\n    const topic = 'stream-notify-room'\n    return Promise.all([\n      this.subscribe('stream-room-messages', rid, ...args),\n      this.subscribe(topic, `${rid}/typing`, ...args),\n      this.subscribe(topic, `${rid}/deleteMessage`, ...args)\n    ])\n  }\n\n\t/** Login to Rocket.Chat via DDP */\n  login = async (credentials: ICredentials, args: any): Promise<any> => {\n    if (!this.ddp || !this.ddp.connected) {\n      await this.connect()\n    }\n    this.logger.info(`[DDP driver] Login with ${JSON.stringify(credentials)}`)\n    const login: ILoginResult = await this.ddp.login(credentials)\n    this.userId = login.id\n    return login\n  }\n  logout = async () => {\n    if (this.ddp && this.ddp.connected) {\n      await this.ddp.logout()\n    }\n\n  }\n\t/** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */\n  unsubscribe = (subscription: ISubscription) => {\n    return this.ddp.unsubscribe(subscription.id)\n  }\n\n\t/** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */\n  unsubscribeAll = (): Promise<any> => {\n    return this.ddp.unsubscribeAll()\n  }\n\n  onStreamData = (event: string, cb: ICallback): Promise<any> => {\n    function listener (message: any) {\n      cb((message))\n    }\n    return Promise.resolve(this.ddp.on(event, listener))\n      .then(() => ({\n        stop: () => this.ddp.off(event, listener)\n      }))\n  }\n\n  onMessage = (cb: ICallback): void => {\n    this.ddp.on('stream-room-messages', ({ fields: { args: [message] } }: any) => cb(this.ejsonMessage(message)))\n  }\n\n  onTyping = (cb: ICallback): Promise<any > => {\n    return this.ddp.on('stream-notify-room', ({ fields: { args: [username, isTyping] } }: any) => {\n      cb(username, isTyping)\n    }) as any\n  }\n\n  notifyVisitorTyping = (rid: string, username: string, typing: boolean, token: string) => {\n    return this.ddp.call('stream-notify-room', `${ rid }/typing`, username, typing, { token })\n  }\n\n  ejsonMessage = (message: any) => {\n    if (message.ts) {\n      message.ts = new Date(message.ts.$date)\n    }\n    return message\n  }\n\n  methodCall = (method: string, ...args: any[]): Promise<any> => {\n    return this.ddp.call(method, ...args)\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.spec.ts b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.spec.ts
new file mode 100644
index 0000000..ace207a
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.spec.ts
@@ -0,0 +1,167 @@
+import 'mocha'
+import sinon from 'sinon'
+import { expect } from 'chai'
+import { silence } from '../log'
+import { botUser } from '../../utils/config'
+import { Socket } from './ddp'
+import { isLoginResult } from '../../interfaces'
+const delay = (ms: number) => new Promise(resolve => setTimeout(resolve,ms))
+silence() // suppress logs
+let socket: Socket = new Socket({})
+
+describe('[ddp]', () => {
+  afterEach(async () => {
+    socket = new Socket({})
+  })
+  describe('constructor', () => {
+    it('sets ws host to default host', () => {
+      expect(socket.host).to.equal('ws://localhost:3000/websocket')
+    })
+  })
+  describe('.open', () => {
+    it('opens ws to host without error', async () => {
+      await socket.open()
+      expect(socket.connected).to.equal(true)
+
+    })
+    it('establishes session with connection message', async () => {
+      await socket.open().catch((err) => console.log(err))
+      expect(socket.session).to.have.lengthOf(17)
+    })
+  })
+  describe('.close', () => {
+    it('closes connection', async () => {
+      await socket.open()
+      await socket.close()
+      expect(socket.connected).to.equal(false)
+    })
+  })
+  describe('.send', () => {
+    it('sends websocket message to host', async () => {
+      await socket.open()
+      const sent = await socket.send({ msg: 'ping' })
+      expect(sent).to.have.keys(['msg'])
+    })
+    it('good async methods resolve with data', async () => {
+				// @todo this is the only method to test a webhook without a login
+				//       should add another server method to for some basic public stats
+				//       e.g. version number, then update test to check attributes resolve
+      await socket.open()
+      const data = await socket.send({
+        msg: 'method', method: 'loadLocale', params: ['en-au']
+      })
+      expect(data).to.be.a('object')
+    })
+    it('bad async methods reject with errors', async () => {
+      await socket.open()
+      return socket.send({
+        msg: 'method', method: 'registerUser', params: [{
+          email: 'not-an-email',
+          pass: 'pass',
+          name: 'ddp-test'
+        }]
+      })
+				.then((data) => expect(true).to.equal(false))
+				.catch((err) => expect(err.message).to.match(/invalid email/i))
+    })
+  })
+  describe('.login', () => {
+    it('resolves with login result', async () => {
+      await socket.open()
+      const result = await socket.login(botUser)
+				.catch((err) => expect(typeof err).to.equal('undefined'))
+      expect(isLoginResult(result)).to.equal(true)
+    })
+    it('rejects with unknown user', async () => {
+      await socket.open()
+      return socket.login({
+        username: 'nobody',
+        password: 'nothing'
+      })
+				.then(() => expect(true).to.equal(false))
+				.catch((err) => expect(err.error).to.equal(403))
+    })
+    it('can call restricted methods for user', async () => {
+      await socket.open()
+      const subs = await socket.call('subscriptions/get')
+      expect(subs).to.be.an('array')
+    })
+    it('can use resolved token to resume login', async () => {
+      await socket.open()
+      const result = await socket.login(botUser)
+      await socket.close()
+      socket.resume = null
+      await socket.open()
+      await socket.login(result)
+      const subs = await socket.call('subscriptions/get')
+      expect(subs).to.be.an('array')
+    })
+    it('.open resumes login with existing token', async () => {
+      await socket.open()
+      const result = await socket.login(botUser)
+      await socket.close()
+      await socket.open()
+      const subs = await socket.call('subscriptions/get')
+      expect(subs).to.be.an('array')
+    })
+  })
+  describe('.subscribe', () => {
+    it('resolves with subscription ID', async () => {
+      await socket.open()
+      await socket.login(botUser)
+      const name = 'stream-room-messages'
+      const room = '__my_messages__'
+      const sub = await socket.subscribe(name, [room, true])
+				.catch((err) => expect(typeof err).to.equal('undefined'))
+      expect(sub).to.include.keys('id', 'name', 'unsubscribe')
+    })
+    it('emits stream events with ID', () => {
+      return new Promise(async (resolve) => {
+        await socket.open()
+        await socket.login(botUser)
+        const name = 'stream-room-messages'
+        const room = '__my_messages__'
+        await socket.subscribe(name, [room, true], (data: any) => {
+          expect(data.msg).to.equal('changed')
+          resolve()
+        })
+
+        socket.once(name, (data: any) => {
+          expect(data.msg).to.equal('changed')
+          resolve()
+        })
+        await socket.call('sendMessage', { rid: 'GENERAL', msg: 'testing' })
+      })
+    })
+    it('handler fires callback with event data', () => {
+      return new Promise(async (resolve) => {
+        await socket.open()
+        await socket.login(botUser)
+        const name = 'stream-room-messages'
+        const room = '__my_messages__'
+        await socket.subscribe(name, [room, true], (data) => {
+          expect(data.msg).to.equal('changed')
+          resolve(data)
+        })
+        await socket.call('sendMessage', { rid: 'GENERAL', msg: 'sub test' })
+      })
+    })
+    it('handler fires callback on every event', async function () {
+				// this.timeout(120000) // 2 min timeout for debug onMessage step through
+      await socket.open()
+      await socket.login(botUser)
+      const name = 'stream-room-messages'
+      const room = '__my_messages__'
+      const spy = sinon.spy()
+      await socket.subscribe(name, [room, true], spy)
+      await socket.call('sendMessage', { rid: 'GENERAL', msg: 'sub test 1' })
+      await socket.call('sendMessage', { rid: 'GENERAL', msg: 'sub test 2' })
+      await socket.call('sendMessage', { rid: 'GENERAL', msg: 'sub test 3' })
+      await delay(300)
+      sinon.assert.callCount(spy, 3)
+      expect(spy.args.map((c) => c[0].fields.args[0].msg)).to.eql([
+        'sub test 1', 'sub test 2', 'sub test 3'
+      ])
+    })
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/ddp.ts b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.ts
new file mode 100644
index 0000000..2a2b10d
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/drivers/ddp.ts
@@ -0,0 +1,601 @@
+/**
+ * @module DDPDriver
+ * Handles low-level websocket ddp connections and event subscriptions
+ */
+
+import WebSocket from 'universal-websocket-client'
+import { EventEmitter } from 'tiny-events'
+
+import { logger as Logger } from '../log'
+import { ISocket, IDriver } from './index'
+
+EventEmitter.prototype.removeAllListeners = function (event?: string | any): any {
+  if (event) {
+    this._listeners[event] = []
+  } else {
+    this._listeners = {}
+  }
+  return [] as any
+}
+
+import {
+  ISocketOptions,
+  ISocketMessageHandler,
+  ISubscription,
+  ICredentials,
+  ILoginResult,
+  ICredentialsPass,
+  isLoginPass,
+  ICredentialsOAuth,
+  isLoginOAuth,
+  ICredentialsAuthenticated,
+  isLoginAuthenticated,
+  isLoginResult,
+  ISocketMessageCallback,
+	ICallback,
+	ILogger
+} from '../../interfaces'
+
+import { hostToWS } from '../util'
+import { sha256 } from 'js-sha256'
+
+/** Websocket handler class, manages connections and subscriptions by DDP */
+export class Socket extends EventEmitter {
+  sent = 0
+  host: string
+  lastPing = Date.now()
+  subscriptions: { [id: string]: ISubscription } = {}
+  handlers: ISocketMessageHandler[] = []
+  config: ISocketOptions | any
+  openTimeout?: NodeJS.Timer | number
+  reopenInterval?: NodeJS.Timer
+  pingTimeout?: NodeJS.Timer | number
+  connection?: WebSocket
+  session?: string
+  logger: ILogger
+
+  /** Create a websocket handler */
+  constructor (
+    options?: ISocketOptions | any,
+    public resume: ILoginResult | null = null
+  ) {
+    super()
+    this.logger = options.logger || Logger
+    this.config = {
+      host: options.host || 'http://localhost:3000',
+      useSsl: options.useSsl || false,
+      reopen: options.reopen || 10000,
+      ping: options.timeout || 30000
+    }
+
+    this.host = `${hostToWS(this.config.host, this.config.useSsl)}/websocket`
+
+    this.on('ping', () => {
+      this.send({ msg: 'pong' }).then(this.logger.debug, this.logger.error)
+    })
+
+    this.on('result', (data: any) => this.emit(data.id, { id: data.id, result: data.result, error: data.error }))
+    this.on('ready', (data: any) => this.emit(data.subs[0], data))
+  }
+
+  /**
+   * Open websocket connection, with optional retry interval.
+   * Stores connection, setting up handlers for open/close/message events.
+   * Resumes login if given token.
+   */
+  open = (ms: number = this.config.reopen) => {
+    return new Promise(async (resolve, reject) => {
+      let connection: WebSocket
+      this.lastPing = Date.now()
+      await this.close()
+      if (this.reopenInterval) clearInterval(this.reopenInterval)
+      this.reopenInterval = setInterval(() => {
+        return !this.connected && this.reopen()
+      }, ms)
+      try {
+        connection = new WebSocket(this.host)
+        connection.onerror = reject
+      } catch (err) {
+        this.logger.error(err)
+        return reject(err)
+      }
+      this.connection = connection
+      this.connection.onmessage = this.onMessage.bind(this)
+      this.connection.onclose = this.onClose.bind(this)
+      this.connection.onopen = this.onOpen.bind(this, resolve)
+    })
+  }
+
+  /** Send handshake message to confirm connection, start pinging. */
+  onOpen = async (callback: Function) => {
+    const connected = await this.send({
+      msg: 'connect',
+      version: '1',
+      support: ['1', 'pre2', 'pre1']
+    })
+    this.session = connected.session
+    this.ping().catch((err) => this.logger.error(`[ddp] Unable to ping server: ${err.message}`))
+    this.emit('open')
+    if (this.resume) await this.login(this.resume)
+    return callback(this.connection)
+  }
+
+  /** Emit close event so it can be used for promise resolve in close() */
+  onClose = (e: any) => {
+    try {
+      this.emit('close', e)
+      if (e.code !== 1000) {
+        return this.reopen()
+      } else {
+        if (this.reopenInterval) clearInterval(this.reopenInterval)
+        this.openTimeout && clearTimeout(this.openTimeout as any)
+        this.pingTimeout && clearTimeout(this.pingTimeout as any)
+        delete this.connection
+      }
+      this.logger.info(`[ddp] Close (${e.code}) ${e.reason}`)
+
+    } catch (error) {
+      this.logger.error(error)
+    }
+  }
+
+  /**
+   * Find and call matching handlers for incoming message data.
+   * Handlers match on collection, id and/or msg attribute in that order.
+   * Any matched handlers are removed once called.
+   * All collection events are emitted with their `msg` as the event name.
+   */
+  onMessage = (e: any) => {
+    this.lastPing = Date.now()
+    void this.ping()
+    const data = (e.data) ? JSON.parse(e.data) : undefined
+    this.logger.debug(data) // 👈  very useful for debugging missing responses
+    if (!data) return this.logger.error(`[ddp] JSON parse error: ${e.message}`)
+    this.logger.debug(`[ddp] messages received: ${e.data}`)
+    if (data.collection) this.emit(data.collection, data)
+    if (data.msg) this.emit(data.msg, data)
+    if (data.id) this.emit(data.id, data)
+  }
+
+  /** Disconnect the DDP from server and clear all subscriptions. */
+  close = async () => {
+    if (this.connected) {
+      this.unsubscribeAll().catch(e => this.logger.debug(e))
+      await new Promise((resolve) => {
+        if (this.connection) {
+          this.once('close', resolve)
+          this.connection.close(1000, 'disconnect')
+          return
+        }
+      })
+      .catch(this.logger.error)
+    }
+    return Promise.resolve()
+  }
+
+  /** Clear connection and try to connect again. */
+  reopen = async () => {
+    if (this.openTimeout) return
+
+    try {
+      this.openTimeout = 1;
+      await this.open();
+    } catch (err) {
+      this.logger.error(`[ddp] Reopen error: ${err.message}`)
+    }
+
+    delete this.openTimeout
+  }
+
+  /** Check if websocket connected and ready. */
+  get connected () {
+    return !!(
+      this.connection &&
+      this.connection.readyState === 1 &&
+      this.alive()
+    )
+  }
+
+  /** Check if connected and logged in */
+  get loggedIn () {
+    return (this.connected && !!this.resume)
+  }
+
+  /**
+   * Send an object to the server via Socket. Adds handler to collection to
+   * allow awaiting response matching an expected object. Most responses are
+   * identified by their message event name and the ID they were sent with, but
+   * some responses don't return the ID fallback to just matching on event name.
+   * Data often includes an error attribute if something went wrong, but certain
+   * types of calls send back a different `msg` value instead, e.g. `nosub`.
+   * @param obj       Object to be sent
+   * @param msg       The `data.msg` value to wait for in response
+   * @param errorMsg  An alternate `data.msg` value indicating an error response
+   */
+  send = async (obj: any): Promise<any> => {
+    return new Promise((resolve, reject) => {
+      if (!this.connection) throw new Error('[ddp] sending without open connection')
+      const id = obj.id || `ddp-${ this.sent }`
+      this.sent += 1
+      const data = { ...obj, ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) }
+      const stringdata = JSON.stringify(data)
+      this.logger.debug(`[ddp] sending message: ${stringdata}`)
+      this.connection.send(stringdata)
+
+      this.once('disconnected', reject)
+      const listener = (data.msg === 'ping' && 'pong') || (data.msg === 'connect' && 'connected') || data.id
+      if (!listener) {
+        return resolve()
+      }
+      this.once(listener, (result: any) => {
+        this.off('disconnect', reject)
+        return (result.error ? reject(result.error) : resolve({ ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) , ...result }))
+      })
+    })
+  }
+
+  /** Send ping, record time, re-open if nothing comes back, repeat */
+  ping = async () => {
+    this.pingTimeout && clearTimeout(this.pingTimeout as any)
+    this.pingTimeout = setTimeout(() => {
+      this.send({ msg: 'ping' })
+        .then(() => {
+          return this.ping()
+        })
+        .catch(() => this.reopen())
+    }, this.config.ping)
+  }
+  /** Check if ping-pong to server is within tolerance of 1 missed ping */
+  alive = () => {
+    if (!this.lastPing) return false
+    return (Date.now() - this.lastPing <= this.config.ping * 2)
+  }
+
+  /**
+   * Calls a method on the server and returns a promise resolved
+   * with the result of the method.
+   * @param method    The name of the method to be called
+   * @param params    An array with the parameters to be sent
+   */
+  call = async (method: string, ...params: any[]) => {
+    const response = await this.send({ msg: 'method', method, params })
+      .catch((err) => {
+        this.logger.error(`[ddp] Call error: ${err.message}`)
+        throw err
+      })
+    return (response.result) ? response.result : response
+  }
+
+  /**
+   * Login to server and resubscribe to all subs, resolve with user information.
+   * @param credentials User credentials (username/password, oauth or token)
+   */
+  login = async (credentials: any) => {
+    const params = this.loginParams(credentials)
+    this.resume = (await this.call('login', params) as ILoginResult)
+    await this.subscribeAll()
+    this.emit('login', this.resume)
+    return this.resume
+  }
+
+  /** Take variety of login credentials object types for accepted params */
+  loginParams = (
+    credentials:
+      ICredentialsPass |
+      ICredentialsOAuth |
+      ICredentialsAuthenticated |
+      ILoginResult |
+      ICredentials
+  ) => {
+    if (
+      isLoginPass(credentials) ||
+      isLoginOAuth(credentials) ||
+      isLoginAuthenticated(credentials)
+    ) {
+      return credentials
+    }
+    if (isLoginResult(credentials)) {
+      const params: ICredentialsAuthenticated = {
+        resume: credentials.token
+      }
+      return params
+    }
+    const params: ICredentialsPass = {
+      user: { username: credentials.username },
+      password: {
+        digest: sha256(credentials.password),
+        algorithm: 'sha-256'
+      }
+    }
+    return params
+  }
+
+  /** Logout the current User from the server via Socket. */
+  logout = () => {
+    this.resume = null
+    return this.unsubscribeAll()
+			.then(() => this.call('logout'))
+  }
+
+  /** Register a callback to trigger on message events in subscription */
+  onEvent = (id: string, callback: ISocketMessageCallback) => {
+    this.on(id, callback)
+  }
+
+  /**
+   * Subscribe to a stream on server via socket and returns a promise resolved
+   * with the subscription object when the subscription is ready.
+   * @param name      Stream name to subscribe to
+   * @param params    Params sent to the subscription request
+   */
+  subscribe = (name: string, params: any[], callback ?: ISocketMessageCallback) => {
+    this.logger.info(`[ddp] Subscribe to ${name}, param: ${JSON.stringify(params)}`)
+    return this.send({ msg: 'sub', name, params })
+      .then((result) => {
+        const id = (result.subs) ? result.subs[0] : undefined
+        const unsubscribe = this.unsubscribe.bind(this, id)
+        const onEvent = this.onEvent.bind(this, name)
+        const subscription = { id, name, params, unsubscribe, onEvent }
+        if (callback) subscription.onEvent(callback)
+        this.subscriptions[id] = subscription
+        return subscription
+      })
+      .catch((err) => {
+        this.logger.error(`[ddp] Subscribe error: ${err.message}`)
+        throw err
+      })
+  }
+
+  /** Subscribe to all pre-configured streams (e.g. on login resume) */
+  subscribeAll = () => {
+    const subscriptions = Object.keys(this.subscriptions || {}).map((key) => {
+      const { name, params } = this.subscriptions[key]
+      return this.subscribe(name, params)
+    })
+    return Promise.all(subscriptions)
+  }
+
+  /** Unsubscribe to server stream, resolve with unsubscribe request result */
+  unsubscribe = (id: any) => {
+    if (!this.subscriptions[id]) return Promise.reject(id)
+    delete this.subscriptions[id]
+    return this.send({ msg: 'unsub', id })
+      .then((data: any) => data.result || data.subs)
+      .catch((err) => {
+        if (!err.msg && err.msg !== 'nosub') {
+          this.logger.error(`[ddp] Unsubscribe error: ${err.message}`)
+          throw err
+        }
+      })
+  }
+
+  /** Unsubscribe from all active subscriptions and reset collection */
+  unsubscribeAll = () => {
+    const unsubAll = Object.keys(this.subscriptions).map((id) => {
+      return this.subscriptions[id].unsubscribe()
+    })
+    return Promise.all(unsubAll)
+      .then(() => this.subscriptions = {})
+  }
+}
+
+export class DDPDriver extends EventEmitter implements ISocket, IDriver {
+  logger: ILogger
+  config: ISocketOptions
+	/**
+	 * Event Emitter for listening to connection (echoes selection of DDP events)
+	 * @example
+	 *  import { driver } from '@rocket.chat/sdk'
+	 *  driver.connect()
+	 *  driver.events.on('connected', () => console.log('driver connected'))
+	 */
+	// events = new EventEmitter()
+
+	/**
+	 * An Websocket instance for interacting with Rocket.Chat.
+	 * Variable not initialised until `connect` called.
+	 */
+  ddp: Socket
+
+	/**
+	 * Websocket subscriptions, exported for direct polling by adapters
+	 * Variable not initialised until `prepMeteorSubscriptions` called.
+	 * @deprecated Use `ddp.Socket` instance subscriptions instead.
+	 */
+  subscriptions: { [id: string]: ISubscription } = {}
+
+	/** Save messages subscription to ensure only one created */
+  messages: ISubscription | undefined
+
+	/** Current user object populated from resolved login */
+  userId: string = ''
+
+	/** Array of joined room IDs (for reactive queries) */
+  joinedIds: string[] = []
+
+  constructor ({ host = 'localhost:3000', integrationId, config, logger = Logger, ...moreConfigs }: any = {}) {
+    super()
+
+    this.config = {
+      ...config,
+      ...moreConfigs,
+      host: host.replace(/(^\w+:|^)\/\//, ''),
+      timeout: 20000
+			// reopen: number
+			// ping: number
+			// close: number
+			// integration: string
+    }
+    this.ddp = new Socket({ ...this.config, logger })
+    this.logger = logger
+  }
+
+	/**
+	 * Initialise socket instance with given options or defaults.
+	 * Proxies the DDP module socket connection. Resolves with socket when open.
+	 * Accepts callback following error-first-pattern.
+	 * Error returned or promise rejected on timeout.
+	 * @example <caption>Using promise</caption>
+	 *  import { driver } from '@rocket.chat/sdk'
+	 *  driver.connect()
+	 *    .then(() => console.log('connected'))
+	 *    .catch((err) => console.error(err))
+	 */
+  connect = (c: any = {}): Promise<any> => {
+    if (this.connected) {
+      return Promise.resolve(this)
+    }
+    const config: ISocketOptions = { ...this.config, ...c } // override defaults
+
+    return new Promise((resolve, reject) => {
+      this.logger.info('[driver] Connecting', config)
+      this.subscriptions = this.ddp.subscriptions
+      this.ddp.open().catch((err: Error) => {
+        this.logger.error(`[driver] Failed to connect: ${err.message}`)
+        reject(err)
+      })
+
+      this.ddp.on('open', () => this.emit('connected')) // echo ddp event
+
+      let cancelled = false
+      const rejectionTimeout = setTimeout(() => {
+        this.logger.info(`[driver] Timeout (${config.timeout})`)
+        const err = new Error('Socket connection timeout')
+        cancelled = true
+        this.ddp.removeAllListeners('connected')
+        reject(err)
+      }, config.timeout)
+
+			// if to avoid condition where timeout happens before listener to 'connected' is added
+			// and this listener is not removed (because it was added after the removal)
+      if (!cancelled) {
+        this.once('connected', () => {
+          this.logger.info('[driver] Connected')
+          if (cancelled) return this.ddp.close() // cancel if already rejected
+          clearTimeout(rejectionTimeout)
+          resolve(this as IDriver)
+        })
+      }
+    })
+  }
+
+  get connected (): boolean {
+    return !!this.ddp.connected
+  }
+
+  disconnect = (): Promise<any> => {
+    return this.ddp.close()
+  }
+
+  subscribe = (topic: string, eventname: string, ...args: any[]): Promise<ISubscription> => {
+    this.logger.info(`[DDP driver] Subscribing to ${topic} | ${JSON.stringify(args)}`)
+    return this.ddp.subscribe(topic, [eventname, { 'useCollection': false, 'args': args }])
+  }
+
+  subscribeNotifyAll = (): Promise< any> => {
+    const topic = 'stream-notify-all'
+    return Promise.all([
+      'roles-change',
+      'updateEmojiCustom',
+      'deleteEmojiCustom',
+      'updateAvatar',
+      'public-settings-changed',
+      'permissions-changed'
+    ].map(event => this.subscribe(topic, event, false)))
+  }
+
+  subscribeLoggedNotify = (): Promise<any> => {
+    const topic = 'stream-notify-logged'
+    return Promise.all([
+      'Users:NameChanged',
+      'Users:Deleted',
+      'updateAvatar',
+      'updateEmojiCustom',
+      'deleteEmojiCustom',
+      'roles-change'
+    ].map(event => this.subscribe(topic, event, false)))
+  }
+
+  subscribeNotifyUser = (): Promise<any> => {
+    const topic = 'stream-notify-user'
+    return Promise.all([
+      'message',
+      'otr',
+      'webrtc',
+      'notification',
+      'rooms-changed',
+      'subscriptions-changed',
+      'uiInteraction'
+    ].map(event => this.subscribe(topic, `${this.userId}/${event}`, false)))
+  }
+
+  subscribeRoom = (rid: string, ...args: any[]): Promise<ISubscription[]> => {
+    const topic = 'stream-notify-room'
+    return Promise.all([
+      this.subscribe('stream-room-messages', rid, ...args),
+      this.subscribe(topic, `${rid}/typing`, ...args),
+      this.subscribe(topic, `${rid}/deleteMessage`, ...args)
+    ])
+  }
+
+	/** Login to Rocket.Chat via DDP */
+  login = async (credentials: ICredentials, args: any): Promise<any> => {
+    if (!this.ddp || !this.ddp.connected) {
+      await this.connect()
+    }
+    this.logger.info(`[DDP driver] Login with ${JSON.stringify(credentials)}`)
+    const login: ILoginResult = await this.ddp.login(credentials)
+    this.userId = login.id
+    return login
+  }
+  logout = async () => {
+    if (this.ddp && this.ddp.connected) {
+      await this.ddp.logout()
+    }
+
+  }
+	/** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */
+  unsubscribe = (subscription: ISubscription) => {
+    return this.ddp.unsubscribe(subscription.id)
+  }
+
+	/** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */
+  unsubscribeAll = (): Promise<any> => {
+    return this.ddp.unsubscribeAll()
+  }
+
+  onStreamData = (event: string, cb: ICallback): Promise<any> => {
+    function listener (message: any) {
+      cb((message))
+    }
+    return Promise.resolve(this.ddp.on(event, listener))
+      .then(() => ({
+        stop: () => this.ddp.off(event, listener)
+      }))
+  }
+
+  onMessage = (cb: ICallback): void => {
+    this.ddp.on('stream-room-messages', ({ fields: { args: [message] } }: any) => cb(this.ejsonMessage(message)))
+  }
+
+  onTyping = (cb: ICallback): Promise<any > => {
+    return this.ddp.on('stream-notify-room', ({ fields: { args: [username, isTyping] } }: any) => {
+      cb(username, isTyping)
+    }) as any
+  }
+
+  notifyVisitorTyping = (rid: string, username: string, typing: boolean, token: string) => {
+    return this.ddp.call('stream-notify-room', `${ rid }/typing`, username, typing, { token })
+  }
+
+  ejsonMessage = (message: any) => {
+    if (message.ts) {
+      message.ts = new Date(message.ts.$date)
+    }
+    return message
+  }
+
+  methodCall = (method: string, ...args: any[]): Promise<any> => {
+    return this.ddp.call(method, ...args)
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/index.d.ts b/node_modules/@rocket.chat/sdk/lib/drivers/index.d.ts
deleted file mode 100644
index 7297df1..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/index.d.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * @module Socket
- * Provides high-level helpers for DDP connection, method calls, subscriptions.
- */
-import { EventEmitter } from 'tiny-events';
-import { ILogger, ISocketOptions, ICallback, ISubscription, ICredentials } from '../../interfaces';
-export interface ISocket {
-    logger: ILogger;
-    connect(options: ISocketOptions): Promise<ISocket | IDriver>;
-    disconnect(): Promise<ISocket>;
-    subscribe(topic: string, ...args: any[]): Promise<ISubscription>;
-    unsubscribe(subscription: ISubscription): Promise<ISocket>;
-    unsubscribeAll(): Promise<ISocket>;
-    onStreamData(event: string, cb: ICallback): Promise<any>;
-    on(event: string, listener: Function): EventEmitter;
-    once(event: string, listener: Function): EventEmitter;
-    off(event?: string, listener?: Function): EventEmitter;
-    emit(event: string, ...args: any[]): boolean;
-    listeners(event: string): Function[];
-    removeAllListeners(event?: string): Function[];
-    hasListeners(event: string): boolean;
-}
-export interface IDriver {
-    config: any;
-    login(credentials: ICredentials, args: any): Promise<any>;
-    subscribeRoom(rid: string, ...args: any[]): Promise<ISubscription[]>;
-    onMessage(cb: ICallback): void;
-    subscribeNotifyAll(): Promise<any>;
-    subscribeLoggedNotify(): Promise<any>;
-    subscribeNotifyUser(): Promise<any>;
-    subscribeNotifyUser(): Promise<IDriver>;
-    onTyping(cb: ICallback): Promise<any>;
-    notifyVisitorTyping(rid: string, username: string, typing: boolean, token: string): Promise<any>;
-    methodCall(method: string, ...args: any[]): Promise<any>;
-}
-export declare enum Protocols {
-    MQTT = "mqtt",
-    DDP = "ddp"
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/index.js b/node_modules/@rocket.chat/sdk/lib/drivers/index.js
deleted file mode 100644
index 03e2a91..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/index.js
+++ /dev/null
@@ -1,12 +0,0 @@
-"use strict";
-/**
- * @module Socket
- * Provides high-level helpers for DDP connection, method calls, subscriptions.
- */
-Object.defineProperty(exports, "__esModule", { value: true });
-var Protocols;
-(function (Protocols) {
-    Protocols["MQTT"] = "mqtt";
-    Protocols["DDP"] = "ddp";
-})(Protocols = exports.Protocols || (exports.Protocols = {}));
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/index.js.map b/node_modules/@rocket.chat/sdk/lib/drivers/index.js.map
deleted file mode 100644
index ba56af4..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/lib/drivers/index.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAqDH,IAAY,SAGX;AAHD,WAAY,SAAS;IACpB,0BAAa,CAAA;IACb,wBAAW,CAAA;AACZ,CAAC,EAHW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAGpB","sourcesContent":["/**\n * @module Socket\n * Provides high-level helpers for DDP connection, method calls, subscriptions.\n */\n\nimport { EventEmitter } from 'tiny-events'\nimport {\n  ILogger,\n  ISocketOptions,\n  ICallback,\n  ISubscription,\n  ICredentials\n} from '../../interfaces'\n\nexport interface ISocket {\n  logger: ILogger\n  connect (options: ISocketOptions): Promise<ISocket | IDriver>\n  disconnect (): Promise<ISocket>\n  subscribe (topic: string, ...args: any[]): Promise<ISubscription>\n  unsubscribe (subscription: ISubscription): Promise<ISocket>\n  unsubscribeAll (): Promise<ISocket>\n\n  onStreamData (event: string, cb: ICallback): Promise<any>\n\n  on (event: string, listener: Function): EventEmitter\n  once (event: string, listener: Function): EventEmitter\n  off (event?: string, listener?: Function): EventEmitter\n  emit (event: string, ...args: any[]): boolean\n  listeners (event: string): Function[]\n  removeAllListeners (event?: string): Function[]\n  hasListeners (event: string): boolean\n}\n\nexport interface IDriver {\n  config: any\n  login (credentials: ICredentials, args: any): Promise<any>\n\n  subscribeRoom (rid: string, ...args: any[]): Promise<ISubscription[]>\n\n  onMessage (cb: ICallback): void\n\n  subscribeNotifyAll (): Promise<any>\n\n  subscribeLoggedNotify (): Promise<any>\n\n  subscribeNotifyUser (): Promise<any>\n\n  subscribeNotifyUser (): Promise<IDriver>\n\n  onTyping (cb: ICallback): Promise<any>\n\n  notifyVisitorTyping (rid: string, username: string, typing: boolean, token: string): Promise<any>\n\n  methodCall (method: string, ...args: any[]): Promise<any>\n}\n\nexport enum Protocols {\n\tMQTT = 'mqtt',\n\tDDP = 'ddp'\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/index.ts b/node_modules/@rocket.chat/sdk/lib/drivers/index.ts
new file mode 100644
index 0000000..390accd
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/drivers/index.ts
@@ -0,0 +1,60 @@
+/**
+ * @module Socket
+ * Provides high-level helpers for DDP connection, method calls, subscriptions.
+ */
+
+import { EventEmitter } from 'tiny-events'
+import {
+  ILogger,
+  ISocketOptions,
+  ICallback,
+  ISubscription,
+  ICredentials
+} from '../../interfaces'
+
+export interface ISocket {
+  logger: ILogger
+  connect (options: ISocketOptions): Promise<ISocket | IDriver>
+  disconnect (): Promise<ISocket>
+  subscribe (topic: string, ...args: any[]): Promise<ISubscription>
+  unsubscribe (subscription: ISubscription): Promise<ISocket>
+  unsubscribeAll (): Promise<ISocket>
+
+  onStreamData (event: string, cb: ICallback): Promise<any>
+
+  on (event: string, listener: Function): EventEmitter
+  once (event: string, listener: Function): EventEmitter
+  off (event?: string, listener?: Function): EventEmitter
+  emit (event: string, ...args: any[]): boolean
+  listeners (event: string): Function[]
+  removeAllListeners (event?: string): Function[]
+  hasListeners (event: string): boolean
+}
+
+export interface IDriver {
+  config: any
+  login (credentials: ICredentials, args: any): Promise<any>
+
+  subscribeRoom (rid: string, ...args: any[]): Promise<ISubscription[]>
+
+  onMessage (cb: ICallback): void
+
+  subscribeNotifyAll (): Promise<any>
+
+  subscribeLoggedNotify (): Promise<any>
+
+  subscribeNotifyUser (): Promise<any>
+
+  subscribeNotifyUser (): Promise<IDriver>
+
+  onTyping (cb: ICallback): Promise<any>
+
+  notifyVisitorTyping (rid: string, username: string, typing: boolean, token: string): Promise<any>
+
+  methodCall (method: string, ...args: any[]): Promise<any>
+}
+
+export enum Protocols {
+	MQTT = 'mqtt',
+	DDP = 'ddp'
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.d.ts b/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.d.ts
deleted file mode 100644
index 529dd56..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.d.ts
+++ /dev/null
@@ -1,24 +0,0 @@
-import { EventEmitter } from 'tiny-events';
-import { ISocket, IDriver } from './index';
-import { ILogger, ISocketOptions, ICallback, ISubscription, ICredentials } from '../../interfaces';
-export declare class MQTTDriver extends EventEmitter implements ISocket, IDriver {
-    logger: ILogger;
-    config: ISocketOptions;
-    socket: any;
-    constructor({ host, path, integrationId, config, logger, ...moreConfigs }: any);
-    connect(options: ISocketOptions): Promise<any>;
-    disconnect(): Promise<any>;
-    subscribe(topic: string, { qos }: any): Promise<ISubscription>;
-    unsubscribe(subscription: ISubscription, ...args: any[]): Promise<ISocket>;
-    unsubscribeAll(): Promise<ISocket>;
-    subscribeNotifyAll(): Promise<any>;
-    subscribeLoggedNotify(): Promise<any>;
-    subscribeNotifyUser(): Promise<any>;
-    login(credentials: ICredentials, args?: any): Promise<any>;
-    subscribeRoom(rid: string, ...args: any[]): Promise<ISubscription[]>;
-    onMessage(cb: ICallback): void;
-    onTyping(cb: ICallback): Promise<any>;
-    notifyVisitorTyping(rid: string, username: string, typing: boolean, token: string): Promise<any>;
-    onStreamData(name: string, cb: ICallback): Promise<any>;
-    methodCall: (method: string, ...args: any[]) => Promise<any>;
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js b/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js
deleted file mode 100644
index bad5635..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js
+++ /dev/null
@@ -1,231 +0,0 @@
-"use strict";
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var __assign = (this && this.__assign) || function () {
-    __assign = Object.assign || function(t) {
-        for (var s, i = 1, n = arguments.length; i < n; i++) {
-            s = arguments[i];
-            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
-                t[p] = s[p];
-        }
-        return t;
-    };
-    return __assign.apply(this, arguments);
-};
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-var __read = (this && this.__read) || function (o, n) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator];
-    if (!m) return o;
-    var i = m.call(o), r, ar = [], e;
-    try {
-        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
-    }
-    catch (error) { e = { error: error }; }
-    finally {
-        try {
-            if (r && !r.done && (m = i["return"])) m.call(i);
-        }
-        finally { if (e) throw e.error; }
-    }
-    return ar;
-};
-var __spread = (this && this.__spread) || function () {
-    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
-    return ar;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var paho_mqtt_1 = require("paho-mqtt/src/paho-mqtt");
-var tiny_events_1 = require("tiny-events");
-var log_1 = require("../log");
-var msgpack_lite_1 = __importDefault(require("msgpack-lite"));
-var MQTTDriver = /** @class */ (function (_super) {
-    __extends(MQTTDriver, _super);
-    function MQTTDriver(_a) {
-        var _b = _a.host, host = _b === void 0 ? 'localhost' : _b, _c = _a.path, path = _c === void 0 ? '/' : _c, integrationId = _a.integrationId, config = _a.config, _d = _a.logger, logger = _d === void 0 ? log_1.logger : _d, moreConfigs = __rest(_a, ["host", "path", "integrationId", "config", "logger"]);
-        var _this = _super.call(this) || this;
-        _this.methodCall = function (method) {
-            var args = [];
-            for (var _i = 1; _i < arguments.length; _i++) {
-                args[_i - 1] = arguments[_i];
-            }
-            return Promise.resolve();
-        };
-        host = 'localhost';
-        var _e = __read(new RegExp('(.*?)(:([0-9]+))?$').exec(host || 'localhost:3000') || [], 4), _f = _e[1], _host = _f === void 0 ? host : _f, _g = _e[3], port = _g === void 0 ? 8081 : _g;
-        _this.config = __assign({}, config, moreConfigs, { host: _host.replace(/^http/, 'ws'), timeout: 20000, port: port });
-        _this.logger = logger;
-        if (/https/.test(host)) {
-            _this.socket = new paho_mqtt_1.Client(_this.config.host + path, 'clientId');
-        }
-        else {
-            _this.socket = new paho_mqtt_1.Client((_this.config.host || '').replace('http://', '').replace('ws://', ''), Number(port), path, 'clientId');
-        }
-        _this.socket.onMessageArrived = function (_a) {
-            var destinationName = _a.destinationName, payloadBytes = _a.payloadBytes;
-            if (/room-message/.test(destinationName)) {
-                _this.emit('message', { topic: destinationName, message: msgpack_lite_1.default.decode(payloadBytes) });
-            }
-        };
-        return _this;
-    }
-    MQTTDriver.prototype.connect = function (options) {
-        var _this = this;
-        return new Promise(function (resolve, reject) {
-            _this.socket.connect({ userName: 'livechat-guest', password: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifSwidXNlciI6eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifX0sIm5hbWUiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.RTQz72NTgI6qWgQMCNHHaSNS13sDK3cz--ss2_5vAz8', onSuccess: resolve, onFailure: reject, useSSL: /https/.test(_this.config.host || '') });
-        });
-    };
-    MQTTDriver.prototype.disconnect = function () {
-        this.socket.end();
-        return Promise.resolve(this.socket);
-    };
-    MQTTDriver.prototype.subscribe = function (topic, _a) {
-        var _this = this;
-        var _b = _a.qos, qos = _b === void 0 ? 0 : _b;
-        return new Promise(function (resolve, reject) {
-            _this.socket.subscribe(topic, { qos: qos, onFailure: function () {
-                    var args = [];
-                    for (var _i = 0; _i < arguments.length; _i++) {
-                        args[_i] = arguments[_i];
-                    }
-                    console.log.apply(console, __spread(args));
-                    reject(args);
-                }, onSuccess: function () {
-                    var args = [];
-                    for (var _i = 0; _i < arguments.length; _i++) {
-                        args[_i] = arguments[_i];
-                    }
-                    console.log.apply(console, __spread(args));
-                    resolve(args);
-                }
-            });
-        });
-    };
-    MQTTDriver.prototype.unsubscribe = function (subscription) {
-        var _this = this;
-        var args = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            args[_i - 1] = arguments[_i];
-        }
-        return new Promise(function (resolve, reject) {
-            _this.socket.unsubscribe(subscription.name, __spread(args, [function (err, granted) {
-                    if (err) {
-                        return reject(err);
-                    }
-                    return resolve(granted);
-                }]));
-        });
-    };
-    MQTTDriver.prototype.unsubscribeAll = function () {
-        return Promise.resolve();
-    };
-    MQTTDriver.prototype.subscribeNotifyAll = function () {
-        return Promise.resolve();
-    };
-    MQTTDriver.prototype.subscribeLoggedNotify = function () {
-        return Promise.resolve();
-    };
-    MQTTDriver.prototype.subscribeNotifyUser = function () {
-        return Promise.resolve();
-    };
-    MQTTDriver.prototype.login = function (credentials, args) {
-        return Promise.resolve();
-    };
-    // usertyping room-messages deleted messages
-    MQTTDriver.prototype.subscribeRoom = function (rid) {
-        var args = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            args[_i - 1] = arguments[_i];
-        }
-        return this.subscribe("room-messages/" + rid, { qos: 0 });
-    };
-    MQTTDriver.prototype.onMessage = function (cb) {
-        this.on('message', function (_a) {
-            var topic = _a.topic, message = _a.message;
-            if (/room-messages/.test(topic)) {
-                cb(message); // TODO apply msgpack
-            }
-        });
-    };
-    MQTTDriver.prototype.onTyping = function (cb) {
-        return __awaiter(this, void 0, void 0, function () {
-            var _this = this;
-            return __generator(this, function (_a) {
-                return [2 /*return*/, new Promise(function (resolve) {
-                        resolve(_this.on('notify-room', function (_a) {
-                            var _b = __read(_a.fields.args, 2), username = _b[0], isTyping = _b[1];
-                            cb(username, isTyping);
-                        }));
-                    })];
-            });
-        });
-    };
-    MQTTDriver.prototype.notifyVisitorTyping = function (rid, username, typing, token) {
-        return Promise.resolve();
-    };
-    MQTTDriver.prototype.onStreamData = function (name, cb) {
-        return Promise.resolve(this.on(name, function (_a) {
-            var _b = __read(_a.fields.args, 1), message = _b[0];
-            return cb((message));
-        }));
-    };
-    return MQTTDriver;
-}(tiny_events_1.EventEmitter));
-exports.MQTTDriver = MQTTDriver;
-//# sourceMappingURL=mqtt.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js.map b/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js.map
deleted file mode 100644
index f362c95..0000000
--- a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"mqtt.js","sourceRoot":"","sources":["../../../src/lib/drivers/mqtt.ts"],"names":[],"mappings":"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","sourcesContent":["import { Client } from 'paho-mqtt/src/paho-mqtt'\nimport { EventEmitter } from 'tiny-events'\n\nimport { logger as Logger } from '../log'\nimport { ISocket, IDriver } from './index'\nimport msgpack from 'msgpack-lite'\nimport {\n\tILogger,\n\tISocketOptions,\n\tICallback,\n\tISubscription,\n\tICredentials\n} from '../../interfaces'\n\nexport class MQTTDriver extends EventEmitter implements ISocket, IDriver {\n  logger: ILogger\n  config: ISocketOptions\n  socket: any\n  constructor ({ host = 'localhost', path = '/', integrationId, config, logger = Logger, ...moreConfigs }: any) {\n    super()\n    host = 'localhost'\n    const [, _host = host, , port = 8081] = new RegExp('(.*?)(:([0-9]+))?$').exec(host || 'localhost:3000') || []\n    this.config = {\n      ...config,\n      ...moreConfigs,\n      host: _host.replace(/^http/, 'ws'),\n      timeout: 20000,\n      port: port\n\t\t\t// reopen: number\n\t\t\t// ping: number\n\t\t\t// close: number\n\t\t\t// integration: string\n    }\n\n    this.logger = logger\n\n    if (/https/.test(host)) {\n      this.socket = new Client(this.config.host + path, 'clientId')\n    } else {\n      this.socket = new Client((this.config.host || '').replace('http://', '').replace('ws://', ''), Number(port), path, 'clientId')\n    }\n    this.socket.onMessageArrived = ({ destinationName, payloadBytes }: any) => {\n      if (/room-message/.test(destinationName)) {\n        this.emit('message', { topic: destinationName, message: msgpack.decode(payloadBytes) })\n      }\n    }\n  }\n\n  connect (options: ISocketOptions): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.socket.connect({ userName: 'livechat-guest', password: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifSwidXNlciI6eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifX0sIm5hbWUiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.RTQz72NTgI6qWgQMCNHHaSNS13sDK3cz--ss2_5vAz8'\t, onSuccess: resolve, onFailure: reject, useSSL: /https/.test(this.config.host || '') })\n    })\n  }\n  disconnect (): Promise<any> {\n    this.socket.end()\n    return Promise.resolve(this.socket)\n  }\n\n  subscribe (topic: string, { qos = 0 }: any): Promise<ISubscription> {\n    return new Promise((resolve, reject) => {\n      this.socket.subscribe(topic, { qos, onFailure: (...args: any[]) => {\n        console.log(...args)\n        reject(args)\n      }, onSuccess: (...args: any[]) => {\n        console.log(...args)\n        resolve(args as any)\n\t\t\t }\n      })\n    })\n  }\n\n  unsubscribe (subscription: ISubscription, ...args: any[]): Promise < ISocket > {\n    return new Promise((resolve, reject) => {\n      this.socket.unsubscribe(subscription.name, [...args, (err: any, granted: any) => {\n        if (err) {\n          return reject(err)\n        }\n        return resolve(granted)\n      }])\n    })\n  }\n\n  unsubscribeAll (): Promise < ISocket > {\n    return Promise.resolve() as any\n  }\n  subscribeNotifyAll (): Promise < any > {\n    return Promise.resolve() as any\n  }\n\n  subscribeLoggedNotify (): Promise < any > {\n    return Promise.resolve() as any\n  }\n\n  subscribeNotifyUser (): Promise < any > {\n    return Promise.resolve() as any\n  }\n\n  login (credentials: ICredentials, args ?: any): Promise < any > {\n    return Promise.resolve() as any\n  }\n\t// usertyping room-messages deleted messages\n  subscribeRoom (rid: string, ...args: any[]): Promise < ISubscription[] > {\n    return this.subscribe(`room-messages/${rid}`, { qos: 0 }) as any\n  }\n\n  onMessage (cb: ICallback): void {\n    this.on('message', ({ topic, message }: any) => {\n      if (/room-messages/.test(topic)) {\n        cb(message)// TODO apply msgpack\n      }\n    })\n  }\n  async onTyping (cb: ICallback): Promise < any > {\n    return new Promise((resolve) => {\n      resolve(this.on('notify-room', ({ fields: { args: [username, isTyping] } }: any) => {\n        cb(username, isTyping)\n      }))\n\n    })\n  }\n\n  notifyVisitorTyping (rid: string, username: string, typing: boolean, token: string): Promise<any> {\n    return Promise.resolve() as any\n  }\n\n  onStreamData (name: string, cb: ICallback): Promise<any> {\n    return Promise.resolve(this.on(name, ({ fields: { args: [message] } }: any) => cb((message)))) as any\n  }\n\n  methodCall = (method: string, ...args: any[]): Promise<any> => {\n    return Promise.resolve() as any\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.ts b/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.ts
new file mode 100644
index 0000000..ca00f4c
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/drivers/mqtt.ts
@@ -0,0 +1,133 @@
+import { Client } from 'paho-mqtt/src/paho-mqtt'
+import { EventEmitter } from 'tiny-events'
+
+import { logger as Logger } from '../log'
+import { ISocket, IDriver } from './index'
+import msgpack from 'msgpack-lite'
+import {
+	ILogger,
+	ISocketOptions,
+	ICallback,
+	ISubscription,
+	ICredentials
+} from '../../interfaces'
+
+export class MQTTDriver extends EventEmitter implements ISocket, IDriver {
+  logger: ILogger
+  config: ISocketOptions
+  socket: any
+  constructor ({ host = 'localhost', path = '/', integrationId, config, logger = Logger, ...moreConfigs }: any) {
+    super()
+    host = 'localhost'
+    const [, _host = host, , port = 8081] = new RegExp('(.*?)(:([0-9]+))?$').exec(host || 'localhost:3000') || []
+    this.config = {
+      ...config,
+      ...moreConfigs,
+      host: _host.replace(/^http/, 'ws'),
+      timeout: 20000,
+      port: port
+			// reopen: number
+			// ping: number
+			// close: number
+			// integration: string
+    }
+
+    this.logger = logger
+
+    if (/https/.test(host)) {
+      this.socket = new Client(this.config.host + path, 'clientId')
+    } else {
+      this.socket = new Client((this.config.host || '').replace('http://', '').replace('ws://', ''), Number(port), path, 'clientId')
+    }
+    this.socket.onMessageArrived = ({ destinationName, payloadBytes }: any) => {
+      if (/room-message/.test(destinationName)) {
+        this.emit('message', { topic: destinationName, message: msgpack.decode(payloadBytes) })
+      }
+    }
+  }
+
+  connect (options: ISocketOptions): Promise<any> {
+    return new Promise((resolve, reject) => {
+      this.socket.connect({ userName: 'livechat-guest', password: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifSwidXNlciI6eyJ2Ijp7InZpc2l0b3JUb2tlbiI6ImFqamVvY2N5dXhweXVlOTg3YzJ0NnMifX0sIm5hbWUiOiJKb2huIERvZSIsImlhdCI6MTUxNjIzOTAyMn0.RTQz72NTgI6qWgQMCNHHaSNS13sDK3cz--ss2_5vAz8'	, onSuccess: resolve, onFailure: reject, useSSL: /https/.test(this.config.host || '') })
+    })
+  }
+  disconnect (): Promise<any> {
+    this.socket.end()
+    return Promise.resolve(this.socket)
+  }
+
+  subscribe (topic: string, { qos = 0 }: any): Promise<ISubscription> {
+    return new Promise((resolve, reject) => {
+      this.socket.subscribe(topic, { qos, onFailure: (...args: any[]) => {
+        console.log(...args)
+        reject(args)
+      }, onSuccess: (...args: any[]) => {
+        console.log(...args)
+        resolve(args as any)
+			 }
+      })
+    })
+  }
+
+  unsubscribe (subscription: ISubscription, ...args: any[]): Promise < ISocket > {
+    return new Promise((resolve, reject) => {
+      this.socket.unsubscribe(subscription.name, [...args, (err: any, granted: any) => {
+        if (err) {
+          return reject(err)
+        }
+        return resolve(granted)
+      }])
+    })
+  }
+
+  unsubscribeAll (): Promise < ISocket > {
+    return Promise.resolve() as any
+  }
+  subscribeNotifyAll (): Promise < any > {
+    return Promise.resolve() as any
+  }
+
+  subscribeLoggedNotify (): Promise < any > {
+    return Promise.resolve() as any
+  }
+
+  subscribeNotifyUser (): Promise < any > {
+    return Promise.resolve() as any
+  }
+
+  login (credentials: ICredentials, args ?: any): Promise < any > {
+    return Promise.resolve() as any
+  }
+	// usertyping room-messages deleted messages
+  subscribeRoom (rid: string, ...args: any[]): Promise < ISubscription[] > {
+    return this.subscribe(`room-messages/${rid}`, { qos: 0 }) as any
+  }
+
+  onMessage (cb: ICallback): void {
+    this.on('message', ({ topic, message }: any) => {
+      if (/room-messages/.test(topic)) {
+        cb(message)// TODO apply msgpack
+      }
+    })
+  }
+  async onTyping (cb: ICallback): Promise < any > {
+    return new Promise((resolve) => {
+      resolve(this.on('notify-room', ({ fields: { args: [username, isTyping] } }: any) => {
+        cb(username, isTyping)
+      }))
+
+    })
+  }
+
+  notifyVisitorTyping (rid: string, username: string, typing: boolean, token: string): Promise<any> {
+    return Promise.resolve() as any
+  }
+
+  onStreamData (name: string, cb: ICallback): Promise<any> {
+    return Promise.resolve(this.on(name, ({ fields: { args: [message] } }: any) => cb((message)))) as any
+  }
+
+  methodCall = (method: string, ...args: any[]): Promise<any> => {
+    return Promise.resolve() as any
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/log.d.ts b/node_modules/@rocket.chat/sdk/lib/log.d.ts
deleted file mode 100644
index d3bc442..0000000
--- a/node_modules/@rocket.chat/sdk/lib/log.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-/**
- * @module log
- * Basic log handling with ability to override when used within another module.
- */
-import { ILogger } from '../interfaces';
-/** Default basic console logging */
-export declare let logger: ILogger;
-/** Substitute logging handler */
-export declare function replaceLog(externalLog: ILogger): void;
-/** Null all log outputs */
-export declare function silence(): void;
diff --git a/node_modules/@rocket.chat/sdk/lib/log.js b/node_modules/@rocket.chat/sdk/lib/log.js
deleted file mode 100644
index b42338b..0000000
--- a/node_modules/@rocket.chat/sdk/lib/log.js
+++ /dev/null
@@ -1,86 +0,0 @@
-"use strict";
-/**
- * @module log
- * Basic log handling with ability to override when used within another module.
- */
-var __read = (this && this.__read) || function (o, n) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator];
-    if (!m) return o;
-    var i = m.call(o), r, ar = [], e;
-    try {
-        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
-    }
-    catch (error) { e = { error: error }; }
-    finally {
-        try {
-            if (r && !r.done && (m = i["return"])) m.call(i);
-        }
-        finally { if (e) throw e.error; }
-    }
-    return ar;
-};
-var __spread = (this && this.__spread) || function () {
-    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
-    return ar;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-/** Temp logging, should override form adapter's log */
-var InternalLog = /** @class */ (function () {
-    function InternalLog() {
-    }
-    InternalLog.prototype.debug = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.log(...args)
-    };
-    InternalLog.prototype.info = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.log(...args)
-    };
-    InternalLog.prototype.warning = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.warn(...args)
-    };
-    InternalLog.prototype.warn = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        return this.warning.apply(this, __spread(args));
-    };
-    InternalLog.prototype.error = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.error(...args)
-    };
-    return InternalLog;
-}());
-/** Default basic console logging */
-exports.logger = new InternalLog();
-/** Substitute logging handler */
-function replaceLog(externalLog) {
-    exports.logger = externalLog;
-}
-exports.replaceLog = replaceLog;
-/** Null all log outputs */
-function silence() {
-    replaceLog({
-        debug: function () { return null; },
-        info: function () { return null; },
-        warn: function () { return null; },
-        warning: function () { return null; },
-        error: function () { return null; }
-    });
-}
-exports.silence = silence;
-//# sourceMappingURL=log.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/log.js.map b/node_modules/@rocket.chat/sdk/lib/log.js.map
deleted file mode 100644
index f5fa928..0000000
--- a/node_modules/@rocket.chat/sdk/lib/log.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"log.js","sourceRoot":"","sources":["../../src/lib/log.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;;;;;;;;;;;;AAIH,uDAAuD;AACvD;IAAA;IAgBA,CAAC;IAfC,2BAAK,GAAL;QAAO,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACnB,uBAAuB;IACzB,CAAC;IACD,0BAAI,GAAJ;QAAM,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAClB,uBAAuB;IACzB,CAAC;IACD,6BAAO,GAAP;QAAS,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACrB,wBAAwB;IAC1B,CAAC;IACD,0BAAI,GAAJ;QAAM,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAClB,OAAO,IAAI,CAAC,OAAO,OAAZ,IAAI,WAAY,IAAI,GAAC;IAC9B,CAAC;IACD,2BAAK,GAAL;QAAO,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACnB,yBAAyB;IAC3B,CAAC;IACH,kBAAC;AAAD,CAAC,AAhBD,IAgBC;AAED,oCAAoC;AACzB,QAAA,MAAM,GAAY,IAAI,WAAW,EAAE,CAAA;AAE9C,iCAAiC;AACjC,SAAgB,UAAU,CAAE,WAAoB;IAC9C,cAAM,GAAG,WAAW,CAAA;AACtB,CAAC;AAFD,gCAEC;AAED,2BAA2B;AAC3B,SAAgB,OAAO;IACrB,UAAU,CAAC;QACT,KAAK,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;QACjB,IAAI,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;QAChB,IAAI,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;QAChB,OAAO,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;QACnB,KAAK,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI;KAClB,CAAC,CAAA;AACJ,CAAC;AARD,0BAQC","sourcesContent":["/**\n * @module log\n * Basic log handling with ability to override when used within another module.\n */\n\nimport { ILogger } from '../interfaces'\n\n/** Temp logging, should override form adapter's log */\nclass InternalLog implements ILogger {\n  debug (...args: any[]) {\n    // console.log(...args)\n  }\n  info (...args: any[]) {\n    // console.log(...args)\n  }\n  warning (...args: any[]) {\n    // console.warn(...args)\n  }\n  warn (...args: any[]) { // legacy method\n    return this.warning(...args)\n  }\n  error (...args: any[]) {\n    // console.error(...args)\n  }\n}\n\n/** Default basic console logging */\nexport let logger: ILogger = new InternalLog()\n\n/** Substitute logging handler */\nexport function replaceLog (externalLog: ILogger) {\n  logger = externalLog\n}\n\n/** Null all log outputs */\nexport function silence () {\n  replaceLog({\n    debug: () => null,\n    info: () => null,\n    warn: () => null,\n    warning: () => null,\n    error: () => null\n  })\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/log.ts b/node_modules/@rocket.chat/sdk/lib/log.ts
new file mode 100644
index 0000000..bc3cd96
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/log.ts
@@ -0,0 +1,44 @@
+/**
+ * @module log
+ * Basic log handling with ability to override when used within another module.
+ */
+
+import { ILogger } from '../interfaces'
+
+/** Temp logging, should override form adapter's log */
+class InternalLog implements ILogger {
+  debug (...args: any[]) {
+    // console.log(...args)
+  }
+  info (...args: any[]) {
+    // console.log(...args)
+  }
+  warning (...args: any[]) {
+    // console.warn(...args)
+  }
+  warn (...args: any[]) { // legacy method
+    return this.warning(...args)
+  }
+  error (...args: any[]) {
+    // console.error(...args)
+  }
+}
+
+/** Default basic console logging */
+export let logger: ILogger = new InternalLog()
+
+/** Substitute logging handler */
+export function replaceLog (externalLog: ILogger) {
+  logger = externalLog
+}
+
+/** Null all log outputs */
+export function silence () {
+  replaceLog({
+    debug: () => null,
+    info: () => null,
+    warn: () => null,
+    warning: () => null,
+    error: () => null
+  })
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/message.d.ts b/node_modules/@rocket.chat/sdk/lib/message.d.ts
deleted file mode 100644
index eda63e2..0000000
--- a/node_modules/@rocket.chat/sdk/lib/message.d.ts
+++ /dev/null
@@ -1,12 +0,0 @@
-import { IMessage } from '../interfaces';
-export interface Message extends IMessage {
-}
-/**
- * Rocket.Chat message class.
- * Sets integration param to allow tracing source of automated sends.
- * @param content Accepts message text or a preformed message object
- * @todo Potential for SDK usage that isn't bots, bot prop should be optional?
- */
-export declare class Message implements IMessage {
-    constructor(content: string | IMessage, { integrationId, ...others }: any);
-}
diff --git a/node_modules/@rocket.chat/sdk/lib/message.js b/node_modules/@rocket.chat/sdk/lib/message.js
deleted file mode 100644
index f2b1394..0000000
--- a/node_modules/@rocket.chat/sdk/lib/message.js
+++ /dev/null
@@ -1,34 +0,0 @@
-"use strict";
-var __rest = (this && this.__rest) || function (s, e) {
-    var t = {};
-    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
-        t[p] = s[p];
-    if (s != null && typeof Object.getOwnPropertySymbols === "function")
-        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
-            t[p[i]] = s[p[i]];
-    return t;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-/**
- * Rocket.Chat message class.
- * Sets integration param to allow tracing source of automated sends.
- * @param content Accepts message text or a preformed message object
- * @todo Potential for SDK usage that isn't bots, bot prop should be optional?
- */
-var Message = /** @class */ (function () {
-    function Message(content, _a) {
-        var integrationId = _a.integrationId, others = __rest(_a, ["integrationId"]);
-        if (typeof content === 'string') {
-            Object.assign(this, { msg: content }, others);
-        }
-        else {
-            Object.assign(this, content, others);
-        }
-        if (integrationId) {
-            this.bot = { i: integrationId };
-        }
-    }
-    return Message;
-}());
-exports.Message = Message;
-//# sourceMappingURL=message.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/message.js.map b/node_modules/@rocket.chat/sdk/lib/message.js.map
deleted file mode 100644
index dbce9be..0000000
--- a/node_modules/@rocket.chat/sdk/lib/message.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"message.js","sourceRoot":"","sources":["../../src/lib/message.ts"],"names":[],"mappings":";;;;;;;;;;;AAMA;;;;;GAKG;AACH;IACE,iBAAa,OAA0B,EAAE,EAAiC;QAA/B,IAAA,gCAAa,EAAE,sCAAS;QACjE,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE,MAAM,CAAC,CAAA;SAC9C;aAAM;YACL,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,CAAA;SACrC;QACD,IAAI,aAAa,EAAE;YACjB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,aAAa,EAAE,CAAA;SAChC;IACH,CAAC;IACH,cAAC;AAAD,CAAC,AAXD,IAWC;AAXY,0BAAO","sourcesContent":["import { IMessage } from '../interfaces'\n\n// Message class declaration implicitly implements interface\n// https://github.com/Microsoft/TypeScript/issues/340\nexport interface Message extends IMessage {}\n\n/**\n * Rocket.Chat message class.\n * Sets integration param to allow tracing source of automated sends.\n * @param content Accepts message text or a preformed message object\n * @todo Potential for SDK usage that isn't bots, bot prop should be optional?\n */\nexport class Message implements IMessage {\n  constructor (content: string | IMessage, { integrationId, ...others }: any) {\n    if (typeof content === 'string') {\n      Object.assign(this, { msg: content }, others)\n    } else {\n      Object.assign(this, content, others)\n    }\n    if (integrationId) {\n      this.bot = { i: integrationId }\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/message.spec.ts b/node_modules/@rocket.chat/sdk/lib/message.spec.ts
new file mode 100644
index 0000000..4cdc9af
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/message.spec.ts
@@ -0,0 +1,47 @@
+import 'mocha'
+import sinon from 'sinon'
+import { expect } from 'chai'
+import { Message } from './message'
+
+describe('message', () => {
+  describe('constructor', () => {
+    it('creates message object from content string', () => {
+      let message = new Message('hello world', 'test')
+      expect(message.msg).to.equal('hello world')
+    })
+    it('uses second param as integration ID attribute', () => {
+      let message = new Message('hello world', 'test')
+      expect(message.bot.i).to.equal('test')
+    })
+    it('accepts existing message and assigns new properties', () => {
+      let message = new Message({
+        msg: 'hello world',
+        rid: 'GENERAL'
+      }, 'test')
+      expect(message).to.eql({
+        msg: 'hello world',
+        rid: 'GENERAL',
+        bot: { i: 'test' }
+      })
+    })
+  })
+  describe('.setRoomId', () => {
+    it('sets rid property', () => {
+      let message = new Message('hello world', 'test')
+      message.setRoomId('111')
+      expect(message.rid).to.equal('111')
+    })
+    it('updates rid property', () => {
+      let message = new Message({
+        msg: 'hello world',
+        rid: 'GENERAL'
+      }, 'test')
+      message.setRoomId('111')
+      expect(message.rid).to.equal('111')
+    })
+    it('returns message instance', () => {
+      let message = new Message('hello world', 'test')
+      expect(message.setRoomId('111')).to.eql(message)
+    })
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/message.ts b/node_modules/@rocket.chat/sdk/lib/message.ts
new file mode 100644
index 0000000..4f37f57
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/message.ts
@@ -0,0 +1,24 @@
+import { IMessage } from '../interfaces'
+
+// Message class declaration implicitly implements interface
+// https://github.com/Microsoft/TypeScript/issues/340
+export interface Message extends IMessage {}
+
+/**
+ * Rocket.Chat message class.
+ * Sets integration param to allow tracing source of automated sends.
+ * @param content Accepts message text or a preformed message object
+ * @todo Potential for SDK usage that isn't bots, bot prop should be optional?
+ */
+export class Message implements IMessage {
+  constructor (content: string | IMessage, { integrationId, ...others }: any) {
+    if (typeof content === 'string') {
+      Object.assign(this, { msg: content }, others)
+    } else {
+      Object.assign(this, content, others)
+    }
+    if (integrationId) {
+      this.bot = { i: integrationId }
+    }
+  }
+}
diff --git a/node_modules/@rocket.chat/sdk/lib/settings.d.ts b/node_modules/@rocket.chat/sdk/lib/settings.d.ts
deleted file mode 100644
index 99eb828..0000000
--- a/node_modules/@rocket.chat/sdk/lib/settings.d.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-export declare let username: string;
-export declare let password: string;
-export declare let ldap: boolean;
-export declare let host: string;
-export declare let useSsl: boolean;
-export declare let timeout: number;
-export declare let rooms: string[];
-export declare let allPublic: boolean;
-export declare let dm: boolean;
-export declare let livechat: boolean;
-export declare let edited: boolean;
-export declare let integrationId: string;
-export declare let roomCacheMaxSize: number;
-export declare let roomCacheMaxAge: number;
-export declare let dmCacheMaxSize: number;
-export declare let dmCacheMaxAge: number;
-export declare let token: string;
-export declare let rid: string;
-export declare let department: string;
diff --git a/node_modules/@rocket.chat/sdk/lib/settings.js b/node_modules/@rocket.chat/sdk/lib/settings.js
deleted file mode 100644
index 822c286..0000000
--- a/node_modules/@rocket.chat/sdk/lib/settings.js
+++ /dev/null
@@ -1,32 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-// Login settings - LDAP needs to be explicitly enabled
-exports.username = process.env.ROCKETCHAT_USER || 'bot';
-exports.password = process.env.ROCKETCHAT_PASSWORD || 'pass';
-exports.ldap = (process.env.ROCKETCHAT_AUTH === 'ldap');
-// Connection settings - Enable SSL by default if Rocket.Chat URL contains https
-exports.host = process.env.ROCKETCHAT_URL || 'localhost:3000';
-exports.useSsl = (process.env.ROCKETCHAT_USE_SSL)
-    ? ((process.env.ROCKETCHAT_USE_SSL || '').toString().toLowerCase() === 'true')
-    : ((process.env.ROCKETCHAT_URL || '').toString().toLowerCase().startsWith('https'));
-exports.timeout = 20 * 1000; // 20 seconds
-// Respond settings - reactive callback filters for .respondToMessages
-exports.rooms = (process.env.ROCKETCHAT_ROOM)
-    ? (process.env.ROCKETCHAT_ROOM || '').split(',').map(function (room) { return room.trim(); })
-    : [];
-exports.allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true';
-exports.dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true';
-exports.livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true';
-exports.edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true';
-// Message attribute settings
-exports.integrationId = process.env.INTEGRATION_ID || 'js.SDK';
-// Cache settings
-exports.roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10);
-exports.roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10);
-exports.dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10);
-exports.dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10);
-// Livechat settings
-exports.token = process.env.LIVECHAT_TOKEN || '';
-exports.rid = process.env.LIVECHAT_ROOM || '';
-exports.department = process.env.LIVECHAT_DEPARTMENT || '';
-//# sourceMappingURL=settings.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/settings.js.map b/node_modules/@rocket.chat/sdk/lib/settings.js.map
deleted file mode 100644
index 6c7050b..0000000
--- a/node_modules/@rocket.chat/sdk/lib/settings.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"settings.js","sourceRoot":"","sources":["../../src/lib/settings.ts"],"names":[],"mappings":";;AACA,uDAAuD;AAC5C,QAAA,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,KAAK,CAAA;AAC/C,QAAA,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,MAAM,CAAA;AACpD,QAAA,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,KAAK,MAAM,CAAC,CAAA;AAE1D,gFAAgF;AACrE,QAAA,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,gBAAgB,CAAA;AACrD,QAAA,MAAM,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC;IAClD,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC;IAC9E,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAA;AAC1E,QAAA,OAAO,GAAG,EAAE,GAAG,IAAI,CAAA,CAAC,aAAa;AAE5C,sEAAsE;AAC3D,QAAA,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC;IAC9C,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAC,IAAI,IAAK,OAAA,IAAI,CAAC,IAAI,EAAE,EAAX,CAAW,CAAC;IAC3E,CAAC,CAAC,EAAE,CAAA;AACK,QAAA,SAAS,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI,OAAO,CAAC,CAAC,WAAW,EAAE,KAAK,MAAM,CAAA;AAClF,QAAA,EAAE,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,OAAO,CAAC,CAAC,WAAW,EAAE,KAAK,MAAM,CAAA;AACpE,QAAA,QAAQ,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,OAAO,CAAC,CAAC,WAAW,EAAE,KAAK,MAAM,CAAA;AAChF,QAAA,MAAM,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI,OAAO,CAAC,CAAC,WAAW,EAAE,KAAK,MAAM,CAAA;AAEvF,6BAA6B;AAClB,QAAA,aAAa,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,QAAQ,CAAA;AAEjE,iBAAiB;AACN,QAAA,gBAAgB,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,IAAI,EAAE,EAAE,CAAC,CAAA;AACpE,QAAA,eAAe,GAAG,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,KAAK,EAAE,EAAE,CAAC,CAAA;AAC9E,QAAA,cAAc,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI,IAAI,EAAE,EAAE,CAAC,CAAA;AACrE,QAAA,aAAa,GAAG,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,qBAAqB,IAAI,KAAK,EAAE,EAAE,CAAC,CAAA;AAE1F,oBAAoB;AACT,QAAA,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,EAAE,CAAA;AACxC,QAAA,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,IAAI,EAAE,CAAA;AACrC,QAAA,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,EAAE,CAAA","sourcesContent":["\n// Login settings - LDAP needs to be explicitly enabled\nexport let username = process.env.ROCKETCHAT_USER || 'bot'\nexport let password = process.env.ROCKETCHAT_PASSWORD || 'pass'\nexport let ldap = (process.env.ROCKETCHAT_AUTH === 'ldap')\n\n// Connection settings - Enable SSL by default if Rocket.Chat URL contains https\nexport let host = process.env.ROCKETCHAT_URL || 'localhost:3000'\nexport let useSsl = (process.env.ROCKETCHAT_USE_SSL)\n  ? ((process.env.ROCKETCHAT_USE_SSL || '').toString().toLowerCase() === 'true')\n  : ((process.env.ROCKETCHAT_URL || '').toString().toLowerCase().startsWith('https'))\nexport let timeout = 20 * 1000 // 20 seconds\n\n// Respond settings - reactive callback filters for .respondToMessages\nexport let rooms = (process.env.ROCKETCHAT_ROOM)\n  ? (process.env.ROCKETCHAT_ROOM || '').split(',').map((room) => room.trim())\n  : []\nexport let allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true'\nexport let dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true'\nexport let livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true'\nexport let edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true'\n\n// Message attribute settings\nexport let integrationId = process.env.INTEGRATION_ID || 'js.SDK'\n\n// Cache settings\nexport let roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10)\nexport let roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10)\nexport let dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10)\nexport let dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10)\n\n// Livechat settings\nexport let token = process.env.LIVECHAT_TOKEN || ''\nexport let rid = process.env.LIVECHAT_ROOM || ''\nexport let department = process.env.LIVECHAT_DEPARTMENT || ''\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/settings.spec.ts b/node_modules/@rocket.chat/sdk/lib/settings.spec.ts
new file mode 100644
index 0000000..0c44915
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/settings.spec.ts
@@ -0,0 +1,76 @@
+import 'mocha'
+import { expect } from 'chai'
+const initEnv = process.env // store configs to restore after tests
+
+describe('settings', () => {
+  beforeEach(() => {
+    delete process.env.ROCKETCHAT_URL
+    delete process.env.ROCKETCHAT_USE_SSL
+    delete process.env.ROCKETCHAT_ROOM
+    delete process.env.LISTEN_ON_ALL_PUBLIC
+    delete process.env.RESPOND_TO_DM
+    delete process.env.RESPOND_TO_LIVECHAT
+    delete process.env.RESPOND_TO_EDITED
+    delete require.cache[require.resolve('./settings')] // clear modules memory
+  })
+  afterEach(() => process.env = initEnv)
+  it('uses localhost URL without SSL if env undefined', () => {
+    const settings = require('./settings')
+    expect(settings).to.deep.include({
+      host: 'localhost:3000',
+      useSsl: false,
+      timeout: 20000
+    })
+  })
+  it('sets SSL from env if defined', () => {
+    process.env.ROCKETCHAT_USE_SSL = 'true'
+    const settings = require('./settings')
+    expect(settings.useSsl).to.equal(true)
+  })
+  it('uses SSL if https protocol URL in env', () => {
+    process.env.ROCKETCHAT_URL = 'https://localhost:3000'
+    const settings = require('./settings')
+    expect(settings.useSsl).to.equal(true)
+  })
+  it('does not use SSL if http protocol URL in env', () => {
+    process.env.ROCKETCHAT_URL = 'http://localhost:3000'
+    const settings = require('./settings')
+    expect(settings.useSsl).to.equal(false)
+  })
+  it('SSL overrides protocol detection', () => {
+    process.env.ROCKETCHAT_URL = 'https://localhost:3000'
+    process.env.ROCKETCHAT_USE_SSL = 'false'
+    const settings = require('./settings')
+    expect(settings.useSsl).to.equal(false)
+  })
+  it('all respond configs default to false if env undefined', () => {
+    const settings = require('./settings')
+    expect(settings).to.deep.include({
+      rooms: [],
+      allPublic: false,
+      dm: false,
+      livechat: false,
+      edited: false
+    })
+  })
+  it('inherits config from env settings', () => {
+    process.env.ROCKETCHAT_ROOM = 'GENERAL'
+    process.env.LISTEN_ON_ALL_PUBLIC = 'false'
+    process.env.RESPOND_TO_DM = 'true'
+    process.env.RESPOND_TO_LIVECHAT = 'true'
+    process.env.RESPOND_TO_EDITED = 'true'
+    const settings = require('./settings')
+    expect(settings).to.deep.include({
+      rooms: ['GENERAL'],
+      allPublic: false,
+      dm: true,
+      livechat: true,
+      edited: true
+    })
+  })
+  it('creates room array from csv list', () => {
+    process.env.ROCKETCHAT_ROOM = `general, foo`
+    const settings = require('./settings')
+    expect(settings.rooms).to.eql(['general', 'foo'])
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/settings.ts b/node_modules/@rocket.chat/sdk/lib/settings.ts
new file mode 100644
index 0000000..a0461e8
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/settings.ts
@@ -0,0 +1,35 @@
+
+// Login settings - LDAP needs to be explicitly enabled
+export let username = process.env.ROCKETCHAT_USER || 'bot'
+export let password = process.env.ROCKETCHAT_PASSWORD || 'pass'
+export let ldap = (process.env.ROCKETCHAT_AUTH === 'ldap')
+
+// Connection settings - Enable SSL by default if Rocket.Chat URL contains https
+export let host = process.env.ROCKETCHAT_URL || 'localhost:3000'
+export let useSsl = (process.env.ROCKETCHAT_USE_SSL)
+  ? ((process.env.ROCKETCHAT_USE_SSL || '').toString().toLowerCase() === 'true')
+  : ((process.env.ROCKETCHAT_URL || '').toString().toLowerCase().startsWith('https'))
+export let timeout = 20 * 1000 // 20 seconds
+
+// Respond settings - reactive callback filters for .respondToMessages
+export let rooms = (process.env.ROCKETCHAT_ROOM)
+  ? (process.env.ROCKETCHAT_ROOM || '').split(',').map((room) => room.trim())
+  : []
+export let allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true'
+export let dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true'
+export let livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true'
+export let edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true'
+
+// Message attribute settings
+export let integrationId = process.env.INTEGRATION_ID || 'js.SDK'
+
+// Cache settings
+export let roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10)
+export let roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10)
+export let dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10)
+export let dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10)
+
+// Livechat settings
+export let token = process.env.LIVECHAT_TOKEN || ''
+export let rid = process.env.LIVECHAT_ROOM || ''
+export let department = process.env.LIVECHAT_DEPARTMENT || ''
diff --git a/node_modules/@rocket.chat/sdk/lib/util.d.ts b/node_modules/@rocket.chat/sdk/lib/util.d.ts
deleted file mode 100644
index 3bd5295..0000000
--- a/node_modules/@rocket.chat/sdk/lib/util.d.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-/** A function that emits a side effect and does not return anything. */
-export declare type Procedure = (...args: any[]) => void;
-/** Delay invocation of a function until some time after it was last called */
-export declare function debounce<F extends Procedure>(func: F, waitMilliseconds?: number, immediate?: boolean): F;
-/** Convert a http/s protocol address to a websocket URL */
-export declare function hostToWS(host: string, ssl?: boolean): string;
diff --git a/node_modules/@rocket.chat/sdk/lib/util.js b/node_modules/@rocket.chat/sdk/lib/util.js
deleted file mode 100644
index 4801f96..0000000
--- a/node_modules/@rocket.chat/sdk/lib/util.js
+++ /dev/null
@@ -1,35 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-/** Delay invocation of a function until some time after it was last called */
-function debounce(func, waitMilliseconds, immediate) {
-    if (waitMilliseconds === void 0) { waitMilliseconds = 100; }
-    if (immediate === void 0) { immediate = false; }
-    var timeout;
-    return function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        var self = this;
-        var doLater = function () {
-            timeout = undefined;
-            if (!immediate)
-                func.apply(self, args);
-        };
-        var callNow = immediate && timeout === undefined;
-        if (timeout)
-            clearTimeout(timeout);
-        timeout = setTimeout(doLater, waitMilliseconds);
-        if (callNow)
-            func.apply(self, args);
-    };
-}
-exports.debounce = debounce;
-/** Convert a http/s protocol address to a websocket URL */
-function hostToWS(host, ssl) {
-    if (ssl === void 0) { ssl = false; }
-    host = host.replace(/^(https?:\/\/)?/, '');
-    return "ws" + (ssl ? 's' : '') + "://" + host;
-}
-exports.hostToWS = hostToWS;
-//# sourceMappingURL=util.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/util.js.map b/node_modules/@rocket.chat/sdk/lib/util.js.map
deleted file mode 100644
index 28fa741..0000000
--- a/node_modules/@rocket.chat/sdk/lib/util.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"util.js","sourceRoot":"","sources":["../../src/lib/util.ts"],"names":[],"mappings":";;AAGA,8EAA8E;AAC9E,SAAgB,QAAQ,CACtB,IAAO,EACP,gBAAsB,EACtB,SAAiB;IADjB,iCAAA,EAAA,sBAAsB;IACtB,0BAAA,EAAA,iBAAiB;IAEjB,IAAI,OAAiC,CAAA;IACrC,OAAO;QAAqB,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACxC,IAAM,IAAI,GAAG,IAAI,CAAA;QACjB,IAAM,OAAO,GAAG;YACd,OAAO,GAAG,SAAS,CAAA;YACnB,IAAI,CAAC,SAAS;gBAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;QACxC,CAAC,CAAA;QACD,IAAM,OAAO,GAAG,SAAS,IAAI,OAAO,KAAK,SAAS,CAAA;QAClD,IAAI,OAAO;YAAE,YAAY,CAAC,OAAO,CAAC,CAAA;QAClC,OAAO,GAAG,UAAU,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAA;QAC/C,IAAI,OAAO;YAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;IACrC,CAAQ,CAAA;AACV,CAAC;AAjBD,4BAiBC;AAED,2DAA2D;AAC3D,SAAgB,QAAQ,CAAE,IAAY,EAAE,GAAW;IAAX,oBAAA,EAAA,WAAW;IACjD,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE,EAAE,CAAC,CAAA;IAC1C,OAAO,QAAK,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,YAAM,IAAM,CAAA;AACxC,CAAC;AAHD,4BAGC","sourcesContent":["/** A function that emits a side effect and does not return anything. */\nexport type Procedure = (...args: any[]) => void\n\n/** Delay invocation of a function until some time after it was last called */\nexport function debounce<F extends Procedure> (\n  func: F,\n  waitMilliseconds = 100,\n  immediate = false\n): F {\n  let timeout: NodeJS.Timer | undefined\n  return function (this: any, ...args: any[]) {\n    const self = this\n    const doLater = function () {\n      timeout = undefined\n      if (!immediate) func.apply(self, args)\n    }\n    const callNow = immediate && timeout === undefined\n    if (timeout) clearTimeout(timeout)\n    timeout = setTimeout(doLater, waitMilliseconds)\n    if (callNow) func.apply(self, args)\n  } as any\n}\n\n/** Convert a http/s protocol address to a websocket URL */\nexport function hostToWS (host: string, ssl = false) {\n  host = host.replace(/^(https?:\\/\\/)?/, '')\n  return `ws${ssl ? 's' : ''}://${host}`\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/lib/util.spec.ts b/node_modules/@rocket.chat/sdk/lib/util.spec.ts
new file mode 100644
index 0000000..5895211
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/util.spec.ts
@@ -0,0 +1,54 @@
+import 'mocha'
+import sinon from 'sinon'
+import { expect } from 'chai'
+import { silence } from './log'
+import { botUser } from '../utils/config'
+import * as util from './util'
+
+const delay = (ms: number) => new Promise((resolve, reject) => setTimeout(resolve, ms))
+
+describe('[util]', () => {
+  describe('debounce', () => {
+    it('does not call immediately by default', async () => {
+      const spy = sinon.spy()
+      const debounced = util.debounce(spy, 30)
+      debounced()
+      sinon.assert.callCount(spy, 0)
+      await delay(30)
+      sinon.assert.callCount(spy, 1)
+    })
+    it('can be called immediately with option', async () => {
+      const spy = sinon.spy()
+      const debounced = util.debounce(spy, 30, true)
+      debounced()
+      sinon.assert.callCount(spy, 1)
+    })
+    it('does not call consecutively within time given time', async () => {
+      const spy = sinon.spy()
+      const debounced = util.debounce(spy, 30, true)
+      debounced()
+      debounced()
+      await delay(30)
+      sinon.assert.callCount(spy, 1)
+    })
+    it('can be called again after delay', async () => {
+      const spy = sinon.spy()
+      const debounced = util.debounce(spy, 30, true)
+      debounced()
+      await delay(30)
+      debounced()
+      sinon.assert.callCount(spy, 2)
+    })
+  })
+  describe('hostToWS', () => {
+    it('converts hostname to ws url', () => {
+      expect(util.hostToWS('localhost:3000')).to.equal('ws://localhost:3000')
+    })
+    it('converts http/s path to ws url', () => {
+      expect(util.hostToWS('http://localhost:3000')).to.equal('ws://localhost:3000')
+    })
+    it('converts host to secure ws url', () => {
+      expect(util.hostToWS('localhost:3000', true)).to.equal('wss://localhost:3000')
+    })
+  })
+})
diff --git a/node_modules/@rocket.chat/sdk/lib/util.ts b/node_modules/@rocket.chat/sdk/lib/util.ts
new file mode 100644
index 0000000..8e9e93b
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/lib/util.ts
@@ -0,0 +1,28 @@
+/** A function that emits a side effect and does not return anything. */
+export type Procedure = (...args: any[]) => void
+
+/** Delay invocation of a function until some time after it was last called */
+export function debounce<F extends Procedure> (
+  func: F,
+  waitMilliseconds = 100,
+  immediate = false
+): F {
+  let timeout: NodeJS.Timer | undefined
+  return function (this: any, ...args: any[]) {
+    const self = this
+    const doLater = function () {
+      timeout = undefined
+      if (!immediate) func.apply(self, args)
+    }
+    const callNow = immediate && timeout === undefined
+    if (timeout) clearTimeout(timeout)
+    timeout = setTimeout(doLater, waitMilliseconds)
+    if (callNow) func.apply(self, args)
+  } as any
+}
+
+/** Convert a http/s protocol address to a websocket URL */
+export function hostToWS (host: string, ssl = false) {
+  host = host.replace(/^(https?:\/\/)?/, '')
+  return `ws${ssl ? 's' : ''}://${host}`
+}
diff --git a/node_modules/@rocket.chat/sdk/types/events.d.ts b/node_modules/@rocket.chat/sdk/types/events.d.ts
new file mode 100644
index 0000000..f3fc0c4
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/types/events.d.ts
@@ -0,0 +1,12 @@
+declare module 'tiny-events' {
+	export class EventEmitter {
+		_listeners: any
+		on(event: string, listener: Function): EventEmitter;
+		once(event: string, listener: Function): EventEmitter;
+		off(event?: string, listener?: Function): EventEmitter;
+		emit(event: string, ...args: any[]): boolean;
+		listeners(event: string): Function[];
+		removeAllListeners(event?: string): Function[];
+		hasListeners(event: string): boolean;
+	}
+}
diff --git a/node_modules/@rocket.chat/sdk/types/index.d.ts b/node_modules/@rocket.chat/sdk/types/index.d.ts
new file mode 100644
index 0000000..8d75cc2
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/types/index.d.ts
@@ -0,0 +1,14 @@
+declare module 'universal-websocket-client'
+declare module 'paho-mqtt'
+declare module 'paho-mqtt/src/paho-mqtt'
+declare module 'msgpack-lite'
+declare module 'mem'
+declare module 'js-sha256' {
+	export function sha256( data:string) : string
+}
+
+declare namespace NodeJS {
+	interface Global {
+		fetch: any
+	}
+}
diff --git a/node_modules/@rocket.chat/sdk/utils/.DS_Store b/node_modules/@rocket.chat/sdk/utils/.DS_Store
new file mode 100644
index 0000000..d93b6c0
Binary files /dev/null and b/node_modules/@rocket.chat/sdk/utils/.DS_Store differ
diff --git a/node_modules/@rocket.chat/sdk/utils/config.d.ts b/node_modules/@rocket.chat/sdk/utils/config.d.ts
deleted file mode 100644
index 5937d1f..0000000
--- a/node_modules/@rocket.chat/sdk/utils/config.d.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { INewUserAPI, INewLivechatGuestAPI, ILivechatSurveyAPI, INewLivechatOfflineMessageAPI, INewLivechatNavigationAPI, INewLivechatCustomFieldAPI, INewLivechatCustomFieldsAPI } from '../interfaces';
-export declare const apiUser: INewUserAPI;
-export declare const botUser: INewUserAPI;
-export declare const mockUser: INewUserAPI;
-export declare const mockVisitor: INewLivechatGuestAPI;
-export declare const mockSurvey: ILivechatSurveyAPI[];
-export declare const mockOfflineMessage: INewLivechatOfflineMessageAPI;
-export declare const mockVisitorNavigation: INewLivechatNavigationAPI;
-export declare const mockCustomField: INewLivechatCustomFieldAPI;
-export declare const mockCustomFields: INewLivechatCustomFieldsAPI;
diff --git a/node_modules/@rocket.chat/sdk/utils/config.js b/node_modules/@rocket.chat/sdk/utils/config.js
deleted file mode 100644
index a974b81..0000000
--- a/node_modules/@rocket.chat/sdk/utils/config.js
+++ /dev/null
@@ -1,95 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-// The API user, should be provisioned on build with local Rocket.Chat
-exports.apiUser = {
-    username: process.env.ADMIN_USERNAME || 'admin',
-    password: process.env.ADMIN_PASS || 'pass'
-};
-// The Bot user, will attempt to login and run methods in tests
-exports.botUser = {
-    email: 'bit-bucket+bot@test.smtp.org',
-    name: 'Bot',
-    password: process.env.ROCKETCHAT_PASSWORD || 'pass',
-    username: process.env.ROCKETCHAT_USER || 'bot',
-    active: true,
-    roles: ['bot'],
-    joinDefaultChannels: true,
-    requirePasswordChange: false,
-    sendWelcomeEmail: false,
-    verified: true
-};
-// The Mock user, will send messages via API for the bot to respond to
-exports.mockUser = {
-    email: 'bit-bucket+user@test.smtp.org',
-    name: 'Mock User',
-    password: 'mock',
-    username: 'mock',
-    active: true,
-    roles: ['user'],
-    joinDefaultChannels: false,
-    requirePasswordChange: false,
-    sendWelcomeEmail: false,
-    verified: true
-};
-// @todo fix custom field handling, either by using pre-test script to add
-//       required fields to test instance or by handling error without failing
-exports.mockVisitor = {
-    visitor: {
-        name: 'Livechat Visitor',
-        email: 'visitor@rocket.chat',
-        token: '123456789',
-        phone: '55 51 5555-5555'
-        // customFields: [{
-        //   key: 'address',
-        //   value: 'Rocket.Chat street',
-        //   overwrite: true
-        // }]
-    }
-};
-exports.mockSurvey = [
-    {
-        name: 'satisfaction',
-        value: '3'
-    },
-    {
-        name: 'agentResponsiveness',
-        value: '5'
-    }
-];
-exports.mockOfflineMessage = {
-    name: 'Livechat Visitor',
-    email: 'sample@rocket.chat',
-    message: 'This is a Message!'
-};
-exports.mockVisitorNavigation = {
-    token: '123456789',
-    rid: '',
-    pageInfo: {
-        change: 'url',
-        title: 'Livechat Demo Page',
-        location: {
-            href: 'http://localhost:3000/assets/demo.html#page-1'
-        }
-    }
-};
-exports.mockCustomField = {
-    key: 'address',
-    value: 'Rocket.Chat Avenue',
-    overwrite: true
-};
-exports.mockCustomFields = {
-    token: '123456789',
-    customFields: [
-        {
-            key: 'address',
-            value: 'Rocket.Chat Avenue - Porto Alegre',
-            overwrite: true
-        },
-        {
-            key: 'state',
-            value: 'RS',
-            overwrite: true
-        }
-    ]
-};
-//# sourceMappingURL=config.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/config.js.map b/node_modules/@rocket.chat/sdk/utils/config.js.map
deleted file mode 100644
index d114c9c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/config.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"config.js","sourceRoot":"","sources":["../../src/utils/config.ts"],"names":[],"mappings":";;AAUA,sEAAsE;AACzD,QAAA,OAAO,GAAgB;IAClC,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,cAAc,IAAI,OAAO;IAC/C,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,IAAI,MAAM;CAC3C,CAAA;AAED,+DAA+D;AAClD,QAAA,OAAO,GAAgB;IAClC,KAAK,EAAE,8BAA8B;IACrC,IAAI,EAAE,KAAK;IACX,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,MAAM;IACnD,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,eAAe,IAAI,KAAK;IAC9C,MAAM,EAAE,IAAI;IACZ,KAAK,EAAE,CAAC,KAAK,CAAC;IACd,mBAAmB,EAAE,IAAI;IACzB,qBAAqB,EAAE,KAAK;IAC5B,gBAAgB,EAAE,KAAK;IACvB,QAAQ,EAAE,IAAI;CACf,CAAA;AAED,sEAAsE;AACzD,QAAA,QAAQ,GAAgB;IACnC,KAAK,EAAE,+BAA+B;IACtC,IAAI,EAAE,WAAW;IACjB,QAAQ,EAAE,MAAM;IAChB,QAAQ,EAAE,MAAM;IAChB,MAAM,EAAE,IAAI;IACZ,KAAK,EAAE,CAAC,MAAM,CAAC;IACf,mBAAmB,EAAE,KAAK;IAC1B,qBAAqB,EAAE,KAAK;IAC5B,gBAAgB,EAAE,KAAK;IACvB,QAAQ,EAAE,IAAI;CACf,CAAA;AAED,0EAA0E;AAC1E,8EAA8E;AACjE,QAAA,WAAW,GAAyB;IAC/C,OAAO,EAAE;QACP,IAAI,EAAE,kBAAkB;QACxB,KAAK,EAAE,qBAAqB;QAC5B,KAAK,EAAE,WAAW;QAClB,KAAK,EAAE,iBAAiB;QACxB,mBAAmB;QACnB,oBAAoB;QACpB,iCAAiC;QACjC,oBAAoB;QACpB,KAAK;KACN;CACF,CAAA;AAEY,QAAA,UAAU,GAAyB;IAC9C;QACE,IAAI,EAAE,cAAc;QACpB,KAAK,EAAE,GAAG;KACX;IACD;QACE,IAAI,EAAE,qBAAqB;QAC3B,KAAK,EAAE,GAAG;KACX;CACF,CAAA;AAEY,QAAA,kBAAkB,GAAkC;IAC/D,IAAI,EAAE,kBAAkB;IACxB,KAAK,EAAE,oBAAoB;IAC3B,OAAO,EAAE,oBAAoB;CAC9B,CAAA;AAEY,QAAA,qBAAqB,GAA8B;IAC9D,KAAK,EAAE,WAAW;IAClB,GAAG,EAAE,EAAE;IACP,QAAQ,EAAE;QACR,MAAM,EAAE,KAAK;QACb,KAAK,EAAE,oBAAoB;QAC3B,QAAQ,EAAE;YACR,IAAI,EAAE,+CAA+C;SACtD;KACF;CACF,CAAA;AAEY,QAAA,eAAe,GAA+B;IACzD,GAAG,EAAE,SAAS;IACd,KAAK,EAAE,oBAAoB;IAC3B,SAAS,EAAE,IAAI;CAChB,CAAA;AAEY,QAAA,gBAAgB,GAAgC;IAC3D,KAAK,EAAE,WAAW;IAClB,YAAY,EAAE;QACZ;YACE,GAAG,EAAE,SAAS;YACd,KAAK,EAAE,mCAAmC;YAC1C,SAAS,EAAE,IAAI;SAChB;QACD;YACE,GAAG,EAAE,OAAO;YACZ,KAAK,EAAE,IAAI;YACX,SAAS,EAAE,IAAI;SAChB;KACF;CACF,CAAA","sourcesContent":["import {\n  INewUserAPI,\n  INewLivechatGuestAPI,\n  ILivechatSurveyAPI,\n  INewLivechatOfflineMessageAPI,\n  INewLivechatNavigationAPI,\n  INewLivechatCustomFieldAPI,\n  INewLivechatCustomFieldsAPI\n} from '../interfaces'\n\n// The API user, should be provisioned on build with local Rocket.Chat\nexport const apiUser: INewUserAPI = {\n  username: process.env.ADMIN_USERNAME || 'admin',\n  password: process.env.ADMIN_PASS || 'pass'\n}\n\n// The Bot user, will attempt to login and run methods in tests\nexport const botUser: INewUserAPI = {\n  email: 'bit-bucket+bot@test.smtp.org',\n  name: 'Bot',\n  password: process.env.ROCKETCHAT_PASSWORD || 'pass',\n  username: process.env.ROCKETCHAT_USER || 'bot',\n  active: true,\n  roles: ['bot'],\n  joinDefaultChannels: true,\n  requirePasswordChange: false,\n  sendWelcomeEmail: false,\n  verified: true\n}\n\n// The Mock user, will send messages via API for the bot to respond to\nexport const mockUser: INewUserAPI = {\n  email: 'bit-bucket+user@test.smtp.org',\n  name: 'Mock User',\n  password: 'mock',\n  username: 'mock',\n  active: true,\n  roles: ['user'],\n  joinDefaultChannels: false,\n  requirePasswordChange: false,\n  sendWelcomeEmail: false,\n  verified: true\n}\n\n// @todo fix custom field handling, either by using pre-test script to add\n//       required fields to test instance or by handling error without failing\nexport const mockVisitor: INewLivechatGuestAPI = {\n  visitor: {\n    name: 'Livechat Visitor',\n    email: 'visitor@rocket.chat',\n    token: '123456789',\n    phone: '55 51 5555-5555'\n    // customFields: [{\n    //   key: 'address',\n    //   value: 'Rocket.Chat street',\n    //   overwrite: true\n    // }]\n  }\n}\n\nexport const mockSurvey: ILivechatSurveyAPI[] = [\n  {\n    name: 'satisfaction',\n    value: '3'\n  },\n  {\n    name: 'agentResponsiveness',\n    value: '5'\n  }\n]\n\nexport const mockOfflineMessage: INewLivechatOfflineMessageAPI = {\n  name: 'Livechat Visitor',\n  email: 'sample@rocket.chat',\n  message: 'This is a Message!'\n}\n\nexport const mockVisitorNavigation: INewLivechatNavigationAPI = {\n  token: '123456789',\n  rid: '',\n  pageInfo: {\n    change: 'url',\n    title: 'Livechat Demo Page',\n    location: {\n      href: 'http://localhost:3000/assets/demo.html#page-1'\n    }\n  }\n}\n\nexport const mockCustomField: INewLivechatCustomFieldAPI = {\n  key: 'address',\n  value: 'Rocket.Chat Avenue',\n  overwrite: true\n}\n\nexport const mockCustomFields: INewLivechatCustomFieldsAPI = {\n  token: '123456789',\n  customFields: [\n    {\n      key: 'address',\n      value: 'Rocket.Chat Avenue - Porto Alegre',\n      overwrite: true\n    },\n    {\n      key: 'state',\n      value: 'RS',\n      overwrite: true\n    }\n  ]\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/config.ts b/node_modules/@rocket.chat/sdk/utils/config.ts
new file mode 100644
index 0000000..d206342
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/config.ts
@@ -0,0 +1,110 @@
+import {
+  INewUserAPI,
+  INewLivechatGuestAPI,
+  ILivechatSurveyAPI,
+  INewLivechatOfflineMessageAPI,
+  INewLivechatNavigationAPI,
+  INewLivechatCustomFieldAPI,
+  INewLivechatCustomFieldsAPI
+} from '../interfaces'
+
+// The API user, should be provisioned on build with local Rocket.Chat
+export const apiUser: INewUserAPI = {
+  username: process.env.ADMIN_USERNAME || 'admin',
+  password: process.env.ADMIN_PASS || 'pass'
+}
+
+// The Bot user, will attempt to login and run methods in tests
+export const botUser: INewUserAPI = {
+  email: 'bit-bucket+bot@test.smtp.org',
+  name: 'Bot',
+  password: process.env.ROCKETCHAT_PASSWORD || 'pass',
+  username: process.env.ROCKETCHAT_USER || 'bot',
+  active: true,
+  roles: ['bot'],
+  joinDefaultChannels: true,
+  requirePasswordChange: false,
+  sendWelcomeEmail: false,
+  verified: true
+}
+
+// The Mock user, will send messages via API for the bot to respond to
+export const mockUser: INewUserAPI = {
+  email: 'bit-bucket+user@test.smtp.org',
+  name: 'Mock User',
+  password: 'mock',
+  username: 'mock',
+  active: true,
+  roles: ['user'],
+  joinDefaultChannels: false,
+  requirePasswordChange: false,
+  sendWelcomeEmail: false,
+  verified: true
+}
+
+// @todo fix custom field handling, either by using pre-test script to add
+//       required fields to test instance or by handling error without failing
+export const mockVisitor: INewLivechatGuestAPI = {
+  visitor: {
+    name: 'Livechat Visitor',
+    email: 'visitor@rocket.chat',
+    token: '123456789',
+    phone: '55 51 5555-5555'
+    // customFields: [{
+    //   key: 'address',
+    //   value: 'Rocket.Chat street',
+    //   overwrite: true
+    // }]
+  }
+}
+
+export const mockSurvey: ILivechatSurveyAPI[] = [
+  {
+    name: 'satisfaction',
+    value: '3'
+  },
+  {
+    name: 'agentResponsiveness',
+    value: '5'
+  }
+]
+
+export const mockOfflineMessage: INewLivechatOfflineMessageAPI = {
+  name: 'Livechat Visitor',
+  email: 'sample@rocket.chat',
+  message: 'This is a Message!'
+}
+
+export const mockVisitorNavigation: INewLivechatNavigationAPI = {
+  token: '123456789',
+  rid: '',
+  pageInfo: {
+    change: 'url',
+    title: 'Livechat Demo Page',
+    location: {
+      href: 'http://localhost:3000/assets/demo.html#page-1'
+    }
+  }
+}
+
+export const mockCustomField: INewLivechatCustomFieldAPI = {
+  key: 'address',
+  value: 'Rocket.Chat Avenue',
+  overwrite: true
+}
+
+export const mockCustomFields: INewLivechatCustomFieldsAPI = {
+  token: '123456789',
+  customFields: [
+    {
+      key: 'address',
+      value: 'Rocket.Chat Avenue - Porto Alegre',
+      overwrite: true
+    },
+    {
+      key: 'state',
+      value: 'RS',
+      overwrite: true
+    }
+  ]
+}
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat.js b/node_modules/@rocket.chat/sdk/utils/livechat.js
deleted file mode 100644
index b03762a..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-//# sourceMappingURL=livechat.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat.js.map b/node_modules/@rocket.chat/sdk/utils/livechat.js.map
deleted file mode 100644
index 65c6964..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"livechat.js","sourceRoot":"","sources":["../../src/utils/livechat.ts"],"names":[],"mappings":"","sourcesContent":[""]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat.ts
similarity index 100%
rename from node_modules/@rocket.chat/sdk/utils/livechat.d.ts
rename to node_modules/@rocket.chat/sdk/utils/livechat.ts
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/agents.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat/agents.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/agents.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/agents.js b/node_modules/@rocket.chat/sdk/utils/livechat/agents.js
deleted file mode 100644
index e936b57..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/agents.js
+++ /dev/null
@@ -1,117 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var Livechat_1 = __importDefault(require("../../lib/api/Livechat"));
-var settings = __importStar(require("../../lib/settings"));
-var log_1 = require("../../lib/log");
-var config_1 = require("../config");
-log_1.silence();
-var livechat = new Livechat_1.default({});
-function getVisitorToken() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, visitor;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing visitor token for tests...');
-                    token = settings.token;
-                    if (!(!token || token === '')) return [3 /*break*/, 2];
-                    return [4 /*yield*/, livechat.grantVisitor(config_1.mockVisitor)];
-                case 1:
-                    visitor = (_a.sent()).visitor;
-                    token = visitor && visitor.token;
-                    _a.label = 2;
-                case 2: return [2 /*return*/, token];
-            }
-        });
-    });
-}
-function getRoom(token) {
-    return __awaiter(this, void 0, void 0, function () {
-        var room;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing room for tests...');
-                    return [4 /*yield*/, livechat.room()];
-                case 1:
-                    room = (_a.sent()).room;
-                    return [2 /*return*/, room];
-            }
-        });
-    });
-}
-function agent() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, room, rid, department, _a, _b, _c, _d, _e, _f, _g, _h;
-        return __generator(this, function (_j) {
-            switch (_j.label) {
-                case 0: return [4 /*yield*/, getVisitorToken()];
-                case 1:
-                    token = _j.sent();
-                    return [4 /*yield*/, getRoom(token)];
-                case 2:
-                    room = _j.sent();
-                    rid = room && room._id;
-                    department = settings.department;
-                    _b = (_a = console).log;
-                    _c = "\n\t\tGet Livechat Agent `livechat.agent()`:\n\t\t";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, livechat.agent({ rid: rid, token: token })];
-                case 3:
-                    _f = _c + _e.apply(_d, [_j.sent(), null, '\t']) + "\n\n\t\tGet Livechat Next Agent `livechat.nextAgent()`:\n\t\t";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, livechat.nextAgent(department)];
-                case 4:
-                    _b.apply(_a, [_f + _h.apply(_g, [_j.sent(), null, '\t']) + "\n  "]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-agent().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=agents.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/agents.js.map b/node_modules/@rocket.chat/sdk/utils/livechat/agents.js.map
deleted file mode 100644
index 3739630..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/agents.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"agents.js","sourceRoot":"","sources":["../../../src/utils/livechat/agents.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oEAAwC;AACxC,2DAA8C;AAC9C,qCAAuC;AACvC,oCAAuC;AAEvC,aAAO,EAAE,CAAA;AACT,IAAM,QAAQ,GAAG,IAAI,kBAAG,CAAC,EAAE,CAAC,CAAA;AAC5B,SAAe,eAAe;;;;;;oBAC5B,OAAO,CAAC,GAAG,CAAC,wCAAwC,CAAC,CAAA;oBACjD,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAA;yBACtB,CAAA,CAAC,KAAK,IAAI,KAAK,KAAK,EAAE,CAAA,EAAtB,wBAAsB;oBACL,qBAAM,QAAQ,CAAC,YAAY,CAAC,oBAAW,CAAC,EAAA;;oBAApD,OAAO,GAAK,CAAA,SAAwC,CAAA,QAA7C;oBACf,KAAK,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,CAAA;;wBAGjC,sBAAO,KAAK,EAAA;;;;CACb;AAED,SAAe,OAAO,CAAE,KAAa;;;;;;oBACnC,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAA;oBAC3B,qBAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;oBAA9B,IAAI,GAAK,CAAA,SAAqB,CAAA,KAA1B;oBACZ,sBAAO,IAAI,EAAA;;;;CACZ;AAED,SAAe,KAAK;;;;;wBACJ,qBAAM,eAAe,EAAE,EAAA;;oBAA/B,KAAK,GAAG,SAAuB;oBACxB,qBAAM,OAAO,CAAC,KAAK,CAAC,EAAA;;oBAA3B,IAAI,GAAG,SAAoB;oBAC3B,GAAG,GAAG,IAAI,IAAI,IAAI,CAAC,GAAG,CAAA;oBACtB,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAA;oBAEtC,KAAA,CAAA,KAAA,OAAO,CAAA,CAAC,GAAG,CAAA;;oBAET,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,GAAG,KAAA,EAAE,KAAK,OAAA,EAAE,CAAC,EAAA;;8BAAnD,cAAe,SAAoC,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGhE,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,EAAA;;oBALrD,cAAY,KAKV,cAAe,SAAoC,EAAE,IAAI,EAAE,IAAI,EAAC,SACjE,EAAC,CAAA;;;;;CACH;AAED,KAAK,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["import Api from '../../lib/api/Livechat'\nimport * as settings from '../../lib/settings'\nimport { silence } from '../../lib/log'\nimport { mockVisitor } from '../config'\n\nsilence()\nconst livechat = new Api({})\nasync function getVisitorToken () {\n  console.log('\\nPreparing visitor token for tests...')\n  let token = settings.token\n  if (!token || token === '') {\n\t  const { visitor } = await livechat.grantVisitor(mockVisitor)\n\t  token = visitor && visitor.token\n  }\n\n  return token\n}\n\nasync function getRoom (token: string) {\n  console.log('\\nPreparing room for tests...')\n  const { room } = await livechat.room()\n  return room\n}\n\nasync function agent () {\n  const token = await getVisitorToken()\n  const room = await getRoom(token)\n  const rid = room && room._id\n  const department = settings.department\n\n  console.log(`\n\t\tGet Livechat Agent \\`livechat.agent()\\`:\n\t\t${JSON.stringify(await livechat.agent({ rid, token }), null, '\\t')}\n\n\t\tGet Livechat Next Agent \\`livechat.nextAgent()\\`:\n\t\t${JSON.stringify(await livechat.nextAgent(department), null, '\\t')}\n  `)\n}\n\nagent().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/agents.ts b/node_modules/@rocket.chat/sdk/utils/livechat/agents.ts
new file mode 100644
index 0000000..448cd96
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/livechat/agents.ts
@@ -0,0 +1,40 @@
+import Api from '../../lib/api/Livechat'
+import * as settings from '../../lib/settings'
+import { silence } from '../../lib/log'
+import { mockVisitor } from '../config'
+
+silence()
+const livechat = new Api({})
+async function getVisitorToken () {
+  console.log('\nPreparing visitor token for tests...')
+  let token = settings.token
+  if (!token || token === '') {
+	  const { visitor } = await livechat.grantVisitor(mockVisitor)
+	  token = visitor && visitor.token
+  }
+
+  return token
+}
+
+async function getRoom (token: string) {
+  console.log('\nPreparing room for tests...')
+  const { room } = await livechat.room()
+  return room
+}
+
+async function agent () {
+  const token = await getVisitorToken()
+  const room = await getRoom(token)
+  const rid = room && room._id
+  const department = settings.department
+
+  console.log(`
+		Get Livechat Agent \`livechat.agent()\`:
+		${JSON.stringify(await livechat.agent({ rid, token }), null, '\t')}
+
+		Get Livechat Next Agent \`livechat.nextAgent()\`:
+		${JSON.stringify(await livechat.nextAgent(department), null, '\t')}
+  `)
+}
+
+agent().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/config.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat/config.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/config.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/config.js b/node_modules/@rocket.chat/sdk/utils/livechat/config.js
deleted file mode 100644
index cb8bf7a..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/config.js
+++ /dev/null
@@ -1,69 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var Livechat_1 = __importDefault(require("../../lib/api/Livechat"));
-var log_1 = require("../../lib/log");
-var config_1 = require("../config");
-log_1.silence();
-var token = config_1.mockVisitor.visitor.token;
-var livechat = new Livechat_1.default(({}));
-function config() {
-    return __awaiter(this, void 0, void 0, function () {
-        var _a, _b, _c, _d, _e, _f, _g, _h;
-        return __generator(this, function (_j) {
-            switch (_j.label) {
-                case 0:
-                    _b = (_a = console).log;
-                    _c = "\n\n\t\tGet default Livechat Config `livechat.config()`:\n\t\t";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, livechat.config()];
-                case 1:
-                    _f = _c + _e.apply(_d, [_j.sent(), null, '\t']) + "\n\n\t\tGet Livechat Config with Token `livechat.config({ token })`:\n\t\t";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, livechat.config({ token: token })];
-                case 2:
-                    _b.apply(_a, [_f + _h.apply(_g, [_j.sent(), null, '\t']) + "\n\n\t"]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-config().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=config.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/config.js.map b/node_modules/@rocket.chat/sdk/utils/livechat/config.js.map
deleted file mode 100644
index c890a49..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/config.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"config.js","sourceRoot":"","sources":["../../../src/utils/livechat/config.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oEAAwC;AACxC,qCAAuC;AACvC,oCAAuC;AAEvC,aAAO,EAAE,CAAA;AAED,IAAA,0CAAK,CAAwB;AAErC,IAAM,QAAQ,GAAG,IAAI,kBAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;AAC9B,SAAe,MAAM;;;;;;oBACnB,KAAA,CAAA,KAAA,OAAO,CAAA,CAAC,GAAG,CAAA;;oBAGT,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,MAAM,EAAE,EAAA;;8BAAtC,cAAe,SAAuB,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGnD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,MAAM,CAAC,EAAE,KAAK,OAAA,EAAE,CAAC,EAAA;;oBANjD,cAAY,KAMV,cAAe,SAAgC,EAAE,IAAI,EAAE,IAAI,EAAC,WAE9D,EAAC,CAAA;;;;;CACF;AAED,MAAM,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["import Api from '../../lib/api/Livechat'\nimport { silence } from '../../lib/log'\nimport { mockVisitor } from '../config'\n\nsilence()\n\nconst { token } = mockVisitor.visitor\n\nconst livechat = new Api(({}))\nasync function config () {\n  console.log(`\n\n\t\tGet default Livechat Config \\`livechat.config()\\`:\n\t\t${JSON.stringify(await livechat.config(), null, '\\t')}\n\n\t\tGet Livechat Config with Token \\`livechat.config({ token })\\`:\n\t\t${JSON.stringify(await livechat.config({ token }), null, '\\t')}\n\n\t`)\n}\n\nconfig().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/config.ts b/node_modules/@rocket.chat/sdk/utils/livechat/config.ts
new file mode 100644
index 0000000..da18988
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/livechat/config.ts
@@ -0,0 +1,22 @@
+import Api from '../../lib/api/Livechat'
+import { silence } from '../../lib/log'
+import { mockVisitor } from '../config'
+
+silence()
+
+const { token } = mockVisitor.visitor
+
+const livechat = new Api(({}))
+async function config () {
+  console.log(`
+
+		Get default Livechat Config \`livechat.config()\`:
+		${JSON.stringify(await livechat.config(), null, '\t')}
+
+		Get Livechat Config with Token \`livechat.config({ token })\`:
+		${JSON.stringify(await livechat.config({ token }), null, '\t')}
+
+	`)
+}
+
+config().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/messages.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat/messages.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/messages.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/messages.js b/node_modules/@rocket.chat/sdk/utils/livechat/messages.js
deleted file mode 100644
index 454cf18..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/messages.js
+++ /dev/null
@@ -1,135 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var Livechat_1 = __importDefault(require("../../lib/api/Livechat"));
-var settings = __importStar(require("../../lib/settings"));
-var log_1 = require("../../lib/log");
-var config_1 = require("../config");
-log_1.silence();
-var livechat = new Livechat_1.default({});
-function getVisitorToken() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, visitor;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing visitor token for tests...');
-                    token = settings.token;
-                    if (!(!token || token === '')) return [3 /*break*/, 2];
-                    return [4 /*yield*/, livechat.grantVisitor(config_1.mockVisitor)];
-                case 1:
-                    visitor = (_a.sent()).visitor;
-                    token = visitor && visitor.token;
-                    _a.label = 2;
-                case 2: return [2 /*return*/, token];
-            }
-        });
-    });
-}
-function getRoom(token) {
-    return __awaiter(this, void 0, void 0, function () {
-        var room;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing room for tests...');
-                    return [4 /*yield*/, livechat.room()];
-                case 1:
-                    room = (_a.sent()).room;
-                    return [2 /*return*/, room];
-            }
-        });
-    });
-}
-function messages() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, room, rid, newMessage, editMessage, result, _id, pageInfo, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
-        return __generator(this, function (_t) {
-            switch (_t.label) {
-                case 0: return [4 /*yield*/, getVisitorToken()];
-                case 1:
-                    token = _t.sent();
-                    return [4 /*yield*/, getRoom(token)];
-                case 2:
-                    room = _t.sent();
-                    rid = room && room._id;
-                    newMessage = { token: token, rid: rid, msg: 'sending livechat message..' };
-                    editMessage = { token: token, rid: rid, msg: 'editing livechat message..' };
-                    return [4 /*yield*/, livechat.sendMessage(newMessage)];
-                case 3:
-                    result = _t.sent();
-                    _id = result && result.message && result.message._id;
-                    pageInfo = Object.assign({}, config_1.mockVisitorNavigation, { rid: rid });
-                    _b = (_a = console).log;
-                    _c = "\n\nDemo of API livechat query helpers\n\nSend Livechat Message `livechat.sendMessage()`:\n" + JSON.stringify(result, null, '\t') + "\n\nEdit Livechat Message `livechat.editMessage()`:\n";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, livechat.editMessage(_id, editMessage)];
-                case 4:
-                    _f = _c + _e.apply(_d, [_t.sent(), null, '\t']) + "\n\nLoad Livechat Messages `livechat.loadMessages()`:\n";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, livechat.loadMessages(rid, { token: token })];
-                case 5:
-                    _j = _f + _h.apply(_g, [_t.sent(), null, '\t']) + "\n\nDelete Livechat Message `livechat.deleteMessage()`:\n";
-                    _l = (_k = JSON).stringify;
-                    return [4 /*yield*/, livechat.deleteMessage(_id, { rid: rid })];
-                case 6:
-                    _m = _j + _l.apply(_k, [_t.sent(), null, '\t']) + "\n\nSend Livechat Offline Message `livechat.sendOfflineMessage()`:\n";
-                    _p = (_o = JSON).stringify;
-                    return [4 /*yield*/, livechat.sendOfflineMessage(config_1.mockOfflineMessage)];
-                case 7:
-                    _q = _m + _p.apply(_o, [_t.sent(), null, '\t']) + "\n\nSend Livechat Visitor Navigation `livechat.sendVisitorNavigation()`:\n";
-                    _s = (_r = JSON).stringify;
-                    return [4 /*yield*/, livechat.sendVisitorNavigation(pageInfo)];
-                case 8:
-                    _b.apply(_a, [_q + _s.apply(_r, [_t.sent(), null, '\t']) + "\n\n  "]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-messages().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=messages.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/messages.js.map b/node_modules/@rocket.chat/sdk/utils/livechat/messages.js.map
deleted file mode 100644
index e56ba5d..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/messages.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"messages.js","sourceRoot":"","sources":["../../../src/utils/livechat/messages.ts"],"names":[],"mappings":"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","sourcesContent":["import Api from '../../lib/api/Livechat'\nimport * as settings from '../../lib/settings'\nimport { silence } from '../../lib/log'\nimport { mockVisitor, mockOfflineMessage, mockVisitorNavigation } from '../config'\n\nsilence()\n\nconst livechat = new Api({})\n\nasync function getVisitorToken () {\n  console.log('\\nPreparing visitor token for tests...')\n  let token = settings.token\n  if (!token || token === '') {\n    const { visitor } = await livechat.grantVisitor(mockVisitor)\n    token = visitor && visitor.token\n  }\n\n  return token\n}\n\nasync function getRoom (token: string) {\n  console.log('\\nPreparing room for tests...')\n  const { room } = await livechat.room()\n  return room\n}\n\nasync function messages () {\n  const token = await getVisitorToken()\n  const room = await getRoom(token)\n  const rid = room && room._id\n  const newMessage = { token, rid, msg: 'sending livechat message..' }\n  const editMessage = { token, rid, msg: 'editing livechat message..' }\n  const result = await livechat.sendMessage(newMessage)\n  const _id = result && result.message && result.message._id\n  const pageInfo = Object.assign({}, mockVisitorNavigation, { rid })\n\n  console.log(`\n\nDemo of API livechat query helpers\n\nSend Livechat Message \\`livechat.sendMessage()\\`:\n${JSON.stringify(result, null, '\\t')}\n\nEdit Livechat Message \\`livechat.editMessage()\\`:\n${JSON.stringify(await livechat.editMessage(_id, editMessage), null, '\\t')}\n\nLoad Livechat Messages \\`livechat.loadMessages()\\`:\n${JSON.stringify(await livechat.loadMessages(rid, { token }), null, '\\t')}\n\nDelete Livechat Message \\`livechat.deleteMessage()\\`:\n${JSON.stringify(await livechat.deleteMessage(_id, { rid }), null, '\\t')}\n\nSend Livechat Offline Message \\`livechat.sendOfflineMessage()\\`:\n${JSON.stringify(await livechat.sendOfflineMessage(mockOfflineMessage), null, '\\t')}\n\nSend Livechat Visitor Navigation \\`livechat.sendVisitorNavigation()\\`:\n${JSON.stringify(await livechat.sendVisitorNavigation(pageInfo), null, '\\t')}\n\n  `)\n}\n\nmessages().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/messages.ts b/node_modules/@rocket.chat/sdk/utils/livechat/messages.ts
new file mode 100644
index 0000000..e531255
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/livechat/messages.ts
@@ -0,0 +1,62 @@
+import Api from '../../lib/api/Livechat'
+import * as settings from '../../lib/settings'
+import { silence } from '../../lib/log'
+import { mockVisitor, mockOfflineMessage, mockVisitorNavigation } from '../config'
+
+silence()
+
+const livechat = new Api({})
+
+async function getVisitorToken () {
+  console.log('\nPreparing visitor token for tests...')
+  let token = settings.token
+  if (!token || token === '') {
+    const { visitor } = await livechat.grantVisitor(mockVisitor)
+    token = visitor && visitor.token
+  }
+
+  return token
+}
+
+async function getRoom (token: string) {
+  console.log('\nPreparing room for tests...')
+  const { room } = await livechat.room()
+  return room
+}
+
+async function messages () {
+  const token = await getVisitorToken()
+  const room = await getRoom(token)
+  const rid = room && room._id
+  const newMessage = { token, rid, msg: 'sending livechat message..' }
+  const editMessage = { token, rid, msg: 'editing livechat message..' }
+  const result = await livechat.sendMessage(newMessage)
+  const _id = result && result.message && result.message._id
+  const pageInfo = Object.assign({}, mockVisitorNavigation, { rid })
+
+  console.log(`
+
+Demo of API livechat query helpers
+
+Send Livechat Message \`livechat.sendMessage()\`:
+${JSON.stringify(result, null, '\t')}
+
+Edit Livechat Message \`livechat.editMessage()\`:
+${JSON.stringify(await livechat.editMessage(_id, editMessage), null, '\t')}
+
+Load Livechat Messages \`livechat.loadMessages()\`:
+${JSON.stringify(await livechat.loadMessages(rid, { token }), null, '\t')}
+
+Delete Livechat Message \`livechat.deleteMessage()\`:
+${JSON.stringify(await livechat.deleteMessage(_id, { rid }), null, '\t')}
+
+Send Livechat Offline Message \`livechat.sendOfflineMessage()\`:
+${JSON.stringify(await livechat.sendOfflineMessage(mockOfflineMessage), null, '\t')}
+
+Send Livechat Visitor Navigation \`livechat.sendVisitorNavigation()\`:
+${JSON.stringify(await livechat.sendVisitorNavigation(pageInfo), null, '\t')}
+
+  `)
+}
+
+messages().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat/rooms.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js b/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js
deleted file mode 100644
index 4c8a92f..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js
+++ /dev/null
@@ -1,130 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
-    result["default"] = mod;
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var Livechat_1 = __importDefault(require("../../lib/api/Livechat"));
-var settings = __importStar(require("../../lib/settings"));
-var log_1 = require("../../lib/log");
-var config_1 = require("../config");
-var livechat = new Livechat_1.default({});
-log_1.silence();
-function getVisitorToken() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, visitor;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing visitor token for tests...');
-                    token = settings.token;
-                    if (!(!token || token === '')) return [3 /*break*/, 2];
-                    return [4 /*yield*/, livechat.grantVisitor(config_1.mockVisitor)];
-                case 1:
-                    visitor = (_a.sent()).visitor;
-                    token = visitor && visitor.token;
-                    _a.label = 2;
-                case 2: return [2 /*return*/, token];
-            }
-        });
-    });
-}
-function getRoom(token) {
-    return __awaiter(this, void 0, void 0, function () {
-        var room;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing room for tests...');
-                    return [4 /*yield*/, livechat.room()];
-                case 1:
-                    room = (_a.sent()).room;
-                    return [2 /*return*/, room];
-            }
-        });
-    });
-}
-function rooms() {
-    return __awaiter(this, void 0, void 0, function () {
-        var token, room, rid, department, email, _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
-        return __generator(this, function (_t) {
-            switch (_t.label) {
-                case 0: return [4 /*yield*/, getVisitorToken()];
-                case 1:
-                    token = _t.sent();
-                    return [4 /*yield*/, getRoom(token)];
-                case 2:
-                    room = _t.sent();
-                    rid = room && room._id;
-                    department = settings.department;
-                    email = 'sample@rocket.chat';
-                    _b = (_a = console).log;
-                    _c = "\n\nDemo of API livechat query helpers\n\n`livechat.room()`:\n" + JSON.stringify(room, null, '\t') + "\n\nTransfer Livechat `livechat.tranferChat()`:\n";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, livechat.transferChat({ rid: rid, department: department })];
-                case 3:
-                    _f = _c + _e.apply(_d, [_t.sent(), null, '\t']) + "\n\nLivechat Survey `livechat.chatSurvey()`:\n";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, livechat.chatSurvey({ rid: rid, data: config_1.mockSurvey })];
-                case 4:
-                    _j = _f + _h.apply(_g, [_t.sent(), null, '\t']) + "\n\nRequest Livechat VideoCall `livechat.videoCall()`:\n";
-                    _l = (_k = JSON).stringify;
-                    return [4 /*yield*/, livechat.videoCall({ rid: rid })];
-                case 5:
-                    _m = _j + _l.apply(_k, [_t.sent(), null, '\t']) + "\n\nClose Livechat Room `livechat.closeChat()`:\n";
-                    _p = (_o = JSON).stringify;
-                    return [4 /*yield*/, livechat.closeChat({ rid: rid })];
-                case 6:
-                    _q = _m + _p.apply(_o, [_t.sent(), null, '\t']) + "\n\nRequest Livechat Transcript `livechat.requestTranscript()`:\n";
-                    _s = (_r = JSON).stringify;
-                    return [4 /*yield*/, livechat.requestTranscript(email, { rid: rid })];
-                case 7:
-                    _b.apply(_a, [_q + _s.apply(_r, [_t.sent(), null, '\t']) + "\n\n  "]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-rooms().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=rooms.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js.map b/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js.map
deleted file mode 100644
index 39cf57d..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"rooms.js","sourceRoot":"","sources":["../../../src/utils/livechat/rooms.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oEAAwC;AACxC,2DAA8C;AAC9C,qCAAuC;AACvC,oCAAmD;AACnD,IAAM,QAAQ,GAAG,IAAI,kBAAG,CAAC,EAAE,CAAC,CAAA;AAC5B,aAAO,EAAE,CAAA;AAET,SAAe,eAAe;;;;;;oBAC5B,OAAO,CAAC,GAAG,CAAC,wCAAwC,CAAC,CAAA;oBACjD,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAA;yBACtB,CAAA,CAAC,KAAK,IAAI,KAAK,KAAK,EAAE,CAAA,EAAtB,wBAAsB;oBACJ,qBAAM,QAAQ,CAAC,YAAY,CAAC,oBAAW,CAAC,EAAA;;oBAApD,OAAO,GAAK,CAAA,SAAwC,CAAA,QAA7C;oBACf,KAAK,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,CAAA;;wBAElC,sBAAO,KAAK,EAAA;;;;CACb;AAED,SAAe,OAAO,CAAE,KAAa;;;;;;oBACnC,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAA;oBAC3B,qBAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;oBAA9B,IAAI,GAAK,CAAA,SAAqB,CAAA,KAA1B;oBACZ,sBAAO,IAAI,EAAA;;;;CACZ;AAED,SAAe,KAAK;;;;;wBACJ,qBAAM,eAAe,EAAE,EAAA;;oBAA/B,KAAK,GAAG,SAAuB;oBACxB,qBAAM,OAAO,CAAC,KAAK,CAAC,EAAA;;oBAA3B,IAAI,GAAG,SAAoB;oBAC3B,GAAG,GAAG,IAAI,IAAI,IAAI,CAAC,GAAG,CAAA;oBACtB,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAA;oBAChC,KAAK,GAAG,oBAAoB,CAAA;oBAElC,KAAA,CAAA,KAAA,OAAO,CAAA,CAAC,GAAG,CAAA;4FAKX,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;oBAGhC,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,YAAY,CAAC,EAAE,GAAG,KAAA,EAAE,UAAU,YAAA,EAAE,CAAC,EAAA;;8BAA/D,cAAe,SAAgD,EAAE,IAAI,EAAE,IAAI,EAAC;oBAG5E,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,UAAU,CAAC,EAAE,GAAG,KAAA,EAAE,IAAI,EAAE,mBAAU,EAAE,CAAC,EAAA;;8BAAnE,cAAe,SAAoD,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGhF,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,SAAS,CAAC,EAAE,GAAG,KAAA,EAAE,CAAC,EAAA;;8BAAhD,cAAe,SAAiC,EAAE,IAAI,EAAE,IAAI,EAAC;oBAG7D,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,SAAS,CAAC,EAAE,GAAG,KAAA,EAAE,CAAC,EAAA;;8BAAhD,cAAe,SAAiC,EAAE,IAAI,EAAE,IAAI,EAAC;oBAG7D,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,iBAAiB,CAAC,KAAK,EAAE,EAAE,GAAG,KAAA,EAAE,CAAC,EAAA;;oBApB/D,cAAY,KAoBZ,cAAe,SAAgD,EAAE,IAAI,EAAE,IAAI,EAAC,WAE3E,EAAC,CAAA;;;;;CACH;AAED,KAAK,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["import Api from '../../lib/api/Livechat'\nimport * as settings from '../../lib/settings'\nimport { silence } from '../../lib/log'\nimport { mockVisitor, mockSurvey } from '../config'\nconst livechat = new Api({})\nsilence()\n\nasync function getVisitorToken () {\n  console.log('\\nPreparing visitor token for tests...')\n  let token = settings.token\n  if (!token || token === '') {\n    const { visitor } = await livechat.grantVisitor(mockVisitor)\n    token = visitor && visitor.token\n  }\n  return token\n}\n\nasync function getRoom (token: string) {\n  console.log('\\nPreparing room for tests...')\n  const { room } = await livechat.room()\n  return room\n}\n\nasync function rooms () {\n  const token = await getVisitorToken()\n  const room = await getRoom(token)\n  const rid = room && room._id\n  const department = settings.department\n  const email = 'sample@rocket.chat'\n\n  console.log(`\n\nDemo of API livechat query helpers\n\n\\`livechat.room()\\`:\n${JSON.stringify(room, null, '\\t')}\n\nTransfer Livechat \\`livechat.tranferChat()\\`:\n${JSON.stringify(await livechat.transferChat({ rid, department }), null, '\\t')}\n\nLivechat Survey \\`livechat.chatSurvey()\\`:\n${JSON.stringify(await livechat.chatSurvey({ rid, data: mockSurvey }), null, '\\t')}\n\nRequest Livechat VideoCall \\`livechat.videoCall()\\`:\n${JSON.stringify(await livechat.videoCall({ rid }), null, '\\t')}\n\nClose Livechat Room \\`livechat.closeChat()\\`:\n${JSON.stringify(await livechat.closeChat({ rid }), null, '\\t')}\n\nRequest Livechat Transcript \\`livechat.requestTranscript()\\`:\n${JSON.stringify(await livechat.requestTranscript(email, { rid }), null, '\\t')}\n\n  `)\n}\n\nrooms().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/rooms.ts b/node_modules/@rocket.chat/sdk/utils/livechat/rooms.ts
new file mode 100644
index 0000000..3a6b0b9
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/livechat/rooms.ts
@@ -0,0 +1,56 @@
+import Api from '../../lib/api/Livechat'
+import * as settings from '../../lib/settings'
+import { silence } from '../../lib/log'
+import { mockVisitor, mockSurvey } from '../config'
+const livechat = new Api({})
+silence()
+
+async function getVisitorToken () {
+  console.log('\nPreparing visitor token for tests...')
+  let token = settings.token
+  if (!token || token === '') {
+    const { visitor } = await livechat.grantVisitor(mockVisitor)
+    token = visitor && visitor.token
+  }
+  return token
+}
+
+async function getRoom (token: string) {
+  console.log('\nPreparing room for tests...')
+  const { room } = await livechat.room()
+  return room
+}
+
+async function rooms () {
+  const token = await getVisitorToken()
+  const room = await getRoom(token)
+  const rid = room && room._id
+  const department = settings.department
+  const email = 'sample@rocket.chat'
+
+  console.log(`
+
+Demo of API livechat query helpers
+
+\`livechat.room()\`:
+${JSON.stringify(room, null, '\t')}
+
+Transfer Livechat \`livechat.tranferChat()\`:
+${JSON.stringify(await livechat.transferChat({ rid, department }), null, '\t')}
+
+Livechat Survey \`livechat.chatSurvey()\`:
+${JSON.stringify(await livechat.chatSurvey({ rid, data: mockSurvey }), null, '\t')}
+
+Request Livechat VideoCall \`livechat.videoCall()\`:
+${JSON.stringify(await livechat.videoCall({ rid }), null, '\t')}
+
+Close Livechat Room \`livechat.closeChat()\`:
+${JSON.stringify(await livechat.closeChat({ rid }), null, '\t')}
+
+Request Livechat Transcript \`livechat.requestTranscript()\`:
+${JSON.stringify(await livechat.requestTranscript(email, { rid }), null, '\t')}
+
+  `)
+}
+
+rooms().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.d.ts b/node_modules/@rocket.chat/sdk/utils/livechat/visitors.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js b/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js
deleted file mode 100644
index 3585c7f..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js
+++ /dev/null
@@ -1,76 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var Livechat_1 = __importDefault(require("../../lib/api/Livechat"));
-var log_1 = require("../../lib/log");
-var config_1 = require("../config");
-log_1.silence();
-var livechat = new Livechat_1.default({});
-function visitors() {
-    return __awaiter(this, void 0, void 0, function () {
-        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
-        return __generator(this, function (_q) {
-            switch (_q.label) {
-                case 0:
-                    _b = (_a = console).log;
-                    _c = "\n\nDemo of API livechat query helpers\n\nCreate Livechat Visitor `livechat.grantVisitor()`:\n";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, livechat.grantVisitor(config_1.mockVisitor)];
-                case 1:
-                    _f = _c + _e.apply(_d, [_q.sent(), null, '\t']) + "\n\nAdd new Livechat CustomField `livechat.sendCustomField()`:\n";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, livechat.sendCustomField(config_1.mockCustomField)];
-                case 2:
-                    _j = _f + _h.apply(_g, [_q.sent(), null, '\t']) + "\n\nAdd new Livechat CustomFields `livechat.sendCustomFields()`:\n";
-                    _l = (_k = JSON).stringify;
-                    return [4 /*yield*/, livechat.sendCustomFields(config_1.mockCustomFields)];
-                case 3:
-                    _m = _j + _l.apply(_k, [_q.sent(), null, '\t']) + "\n\n`livechat.visitor()`:\n";
-                    _p = (_o = JSON).stringify;
-                    return [4 /*yield*/, livechat.visitor()];
-                case 4:
-                    _b.apply(_a, [_m + _p.apply(_o, [_q.sent(), null, '\t']) + "\n\n\t"]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-visitors().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=visitors.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js.map b/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js.map
deleted file mode 100644
index fd77ab0..0000000
--- a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"visitors.js","sourceRoot":"","sources":["../../../src/utils/livechat/visitors.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oEAAwC;AACxC,qCAAuC;AACvC,oCAA0E;AAE1E,aAAO,EAAE,CAAA;AACT,IAAM,QAAQ,GAAG,IAAI,kBAAG,CAAC,EAAE,CAAC,CAAA;AAE5B,SAAe,QAAQ;;;;;;oBACrB,KAAA,CAAA,KAAA,OAAO,CAAA,CAAC,GAAG,CAAA;;oBAKX,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,YAAY,CAAC,oBAAW,CAAC,EAAA;;8BAAvD,cAAe,SAAwC,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGpE,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,eAAe,CAAC,wBAAe,CAAC,EAAA;;8BAA9D,cAAe,SAA+C,EAAE,IAAI,EAAE,IAAI,EAAC;oBAG3E,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,gBAAgB,CAAC,yBAAgB,CAAC,EAAA;;8BAAhE,cAAe,SAAiD,EAAE,IAAI,EAAE,IAAI,EAAC;oBAG7E,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,QAAQ,CAAC,OAAO,EAAE,EAAA;;oBAdvC,cAAY,KAcZ,cAAe,SAAwB,EAAE,IAAI,EAAE,IAAI,EAAC,WAEpD,EAAC,CAAA;;;;;CACF;AAED,QAAQ,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["import Api from '../../lib/api/Livechat'\nimport { silence } from '../../lib/log'\nimport { mockVisitor, mockCustomField, mockCustomFields } from '../config'\n\nsilence()\nconst livechat = new Api({})\n\nasync function visitors () {\n  console.log(`\n\nDemo of API livechat query helpers\n\nCreate Livechat Visitor \\`livechat.grantVisitor()\\`:\n${JSON.stringify(await livechat.grantVisitor(mockVisitor), null, '\\t')}\n\nAdd new Livechat CustomField \\`livechat.sendCustomField()\\`:\n${JSON.stringify(await livechat.sendCustomField(mockCustomField), null, '\\t')}\n\nAdd new Livechat CustomFields \\`livechat.sendCustomFields()\\`:\n${JSON.stringify(await livechat.sendCustomFields(mockCustomFields), null, '\\t')}\n\n\\`livechat.visitor()\\`:\n${JSON.stringify(await livechat.visitor(), null, '\\t')}\n\n\t`)\n}\n\nvisitors().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/livechat/visitors.ts b/node_modules/@rocket.chat/sdk/utils/livechat/visitors.ts
new file mode 100644
index 0000000..2b27441
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/livechat/visitors.ts
@@ -0,0 +1,28 @@
+import Api from '../../lib/api/Livechat'
+import { silence } from '../../lib/log'
+import { mockVisitor, mockCustomField, mockCustomFields } from '../config'
+
+silence()
+const livechat = new Api({})
+
+async function visitors () {
+  console.log(`
+
+Demo of API livechat query helpers
+
+Create Livechat Visitor \`livechat.grantVisitor()\`:
+${JSON.stringify(await livechat.grantVisitor(mockVisitor), null, '\t')}
+
+Add new Livechat CustomField \`livechat.sendCustomField()\`:
+${JSON.stringify(await livechat.sendCustomField(mockCustomField), null, '\t')}
+
+Add new Livechat CustomFields \`livechat.sendCustomFields()\`:
+${JSON.stringify(await livechat.sendCustomFields(mockCustomFields), null, '\t')}
+
+\`livechat.visitor()\`:
+${JSON.stringify(await livechat.visitor(), null, '\t')}
+
+	`)
+}
+
+visitors().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/setup.d.ts b/node_modules/@rocket.chat/sdk/utils/setup.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/setup.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/setup.js b/node_modules/@rocket.chat/sdk/utils/setup.js
deleted file mode 100644
index 0edd629..0000000
--- a/node_modules/@rocket.chat/sdk/utils/setup.js
+++ /dev/null
@@ -1,9 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-/** On require, runs the test utils setup method */
-var testing_1 = require("./testing");
-// import { silence } from '../lib/log'
-global.fetch = require('node-fetch');
-// silence()
-testing_1.setup().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=setup.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/setup.js.map b/node_modules/@rocket.chat/sdk/utils/setup.js.map
deleted file mode 100644
index 3f141e5..0000000
--- a/node_modules/@rocket.chat/sdk/utils/setup.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"setup.js","sourceRoot":"","sources":["../../src/utils/setup.ts"],"names":[],"mappings":";;AAAA,mDAAmD;AACnD,qCAAiC;AACjC,uCAAuC;AACvC,MAAM,CAAC,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC,CAAA;AACpC,YAAY;AACZ,eAAK,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["/** On require, runs the test utils setup method */\nimport { setup } from './testing'\n// import { silence } from '../lib/log'\nglobal.fetch = require('node-fetch')\n// silence()\nsetup().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/setup.ts b/node_modules/@rocket.chat/sdk/utils/setup.ts
new file mode 100644
index 0000000..9c3a7a5
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/setup.ts
@@ -0,0 +1,6 @@
+/** On require, runs the test utils setup method */
+import { setup } from './testing'
+// import { silence } from '../lib/log'
+global.fetch = require('node-fetch')
+// silence()
+setup().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/start.d.ts b/node_modules/@rocket.chat/sdk/utils/start.d.ts
deleted file mode 100644
index 1ec64ad..0000000
--- a/node_modules/@rocket.chat/sdk/utils/start.d.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-export declare let username: string;
-export declare let password: string;
-export declare let ldap: boolean;
-export declare let host: string;
-export declare const useSsl: boolean;
-export declare let timeout: number;
-export declare let rooms: string[];
-export declare let allPublic: boolean;
-export declare let dm: boolean;
-export declare let livechat: boolean;
-export declare let edited: boolean;
-export declare let integrationId: string;
-export declare let roomCacheMaxSize: number;
-export declare let roomCacheMaxAge: number;
-export declare let dmCacheMaxSize: number;
-export declare let dmCacheMaxAge: number;
-export declare let token: string;
-export declare let rid: string;
-export declare let department: string;
diff --git a/node_modules/@rocket.chat/sdk/utils/start.js b/node_modules/@rocket.chat/sdk/utils/start.js
deleted file mode 100644
index 42460b4..0000000
--- a/node_modules/@rocket.chat/sdk/utils/start.js
+++ /dev/null
@@ -1,232 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __values = (this && this.__values) || function (o) {
-    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
-    if (m) return m.call(o);
-    return {
-        next: function () {
-            if (o && i >= o.length) o = void 0;
-            return { value: o && o[i++], done: !o };
-        }
-    };
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-// Test script uses standard methods and env config to connect and log streams
-var config_1 = require("./config");
-var Bot_1 = __importDefault(require("../lib/clients/Bot"));
-global.fetch = require('node-fetch');
-// Login settings - LDAP needs to be explicitly enabled
-exports.username = process.env.ROCKETCHAT_USER || 'g1';
-exports.password = process.env.ROCKETCHAT_PASSWORD || '1';
-exports.ldap = (process.env.ROCKETCHAT_AUTH === 'ldap');
-// Connection settings - Enable SSL by default if Rocket.Chat URL contains https
-exports.host = process.env.ROCKETCHAT_URL || 'http://localhost:3000';
-exports.useSsl = (process.env.ROCKETCHAT_USE_SSL && process.env.ROCKETCHAT_USE_SSL === 'true') || (exports.host).toLowerCase().startsWith('https');
-exports.timeout = 20 * 1000; // 20 seconds
-// Respond settings - reactive callback filters for .respondToMessages
-exports.rooms = (process.env.ROCKETCHAT_ROOM)
-    ? (process.env.ROCKETCHAT_ROOM || '').split(',').map(function (room) { return room.trim(); })
-    : [];
-exports.allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true';
-exports.dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true';
-exports.livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true';
-exports.edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true';
-// Message attribute settings
-exports.integrationId = process.env.INTEGRATION_ID || 'js.SDK';
-// Cache settings
-exports.roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10);
-exports.roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10);
-exports.dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10);
-exports.dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10);
-// Livechat settings
-exports.token = process.env.LIVECHAT_TOKEN || '';
-exports.rid = process.env.LIVECHAT_ROOM || '';
-exports.department = process.env.LIVECHAT_DEPARTMENT || '';
-var delay = function (ms) { return new Promise(function (resolve, reject) { return setTimeout(resolve, ms); }); };
-var L = /** @class */ (function () {
-    function L() {
-    }
-    L.prototype.debug = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.log(...args)
-    };
-    L.prototype.info = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.log(...args)
-    };
-    L.prototype.warning = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.warn(...args)
-    };
-    L.prototype.warn = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // return this.warning(...args)
-    };
-    L.prototype.error = function () {
-        var args = [];
-        for (var _i = 0; _i < arguments.length; _i++) {
-            args[_i] = arguments[_i];
-        }
-        // console.error(...args)
-    };
-    return L;
-}());
-var driver = new Bot_1.default({ host: exports.host, useSsl: exports.useSsl, timeout: exports.timeout, logger: new L() });
-// Start subscription to log message stream (used for e2e test and demo)
-function start() {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, driver.login({ username: exports.username, password: exports.password })];
-                case 1:
-                    _a.sent();
-                    return [4 /*yield*/, driver.connect({})
-                        // driver.subscribeNotifyAll()
-                        // driver.subscribeLoggedNotify()
-                        // driver.subscribeNotifyUser()
-                    ];
-                case 2:
-                    _a.sent();
-                    // driver.subscribeNotifyAll()
-                    // driver.subscribeLoggedNotify()
-                    // driver.subscribeNotifyUser()
-                    return [4 /*yield*/, driver.respondToMessages(function (err, msg, msgOpts) {
-                            if (err)
-                                throw err;
-                            console.log('[respond]', JSON.stringify(msg), JSON.stringify(msgOpts));
-                            if (msg)
-                                demo(msg).catch(function (e) { return console.error(e); });
-                        }, {
-                            rooms: ['GENERAL'],
-                            allPublic: false,
-                            dm: true,
-                            edited: true,
-                            livechat: false
-                        })];
-                case 3:
-                    // driver.subscribeNotifyAll()
-                    // driver.subscribeLoggedNotify()
-                    // driver.subscribeNotifyUser()
-                    _a.sent();
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-// Demo bot-style interactions
-// A: Listen for "tell everyone <something>" and send that something to everyone
-// B: Listen for "who's online" and tell that person who's online
-function demo(message) {
-    return __awaiter(this, void 0, void 0, function () {
-        var e_1, _a, match, usernames, usernames_1, usernames_1_1, username_1, e_1_1, names, niceNames;
-        return __generator(this, function (_b) {
-            switch (_b.label) {
-                case 0:
-                    if (!message.msg)
-                        return [2 /*return*/];
-                    if (!/tell everyone/i.test(message.msg)) return [3 /*break*/, 11];
-                    match = message.msg.match(/tell everyone (.*)/i);
-                    if (!match || !match[1])
-                        return [2 /*return*/];
-                    return [4 /*yield*/, driver.users.allNames()];
-                case 1:
-                    usernames = _b.sent();
-                    _b.label = 2;
-                case 2:
-                    _b.trys.push([2, 8, 9, 10]);
-                    usernames_1 = __values(usernames), usernames_1_1 = usernames_1.next();
-                    _b.label = 3;
-                case 3:
-                    if (!!usernames_1_1.done) return [3 /*break*/, 7];
-                    username_1 = usernames_1_1.value;
-                    if (!(username_1 && username_1 !== config_1.botUser.username)) return [3 /*break*/, 6];
-                    // const toWhere =
-                    return [4 /*yield*/, driver.getDirectMessageRoomId(username_1)];
-                case 4:
-                    // const toWhere =
-                    _b.sent();
-                    return [4 /*yield*/, delay(200)]; // delay to prevent rate-limit error
-                case 5:
-                    _b.sent(); // delay to prevent rate-limit error
-                    _b.label = 6;
-                case 6:
-                    usernames_1_1 = usernames_1.next();
-                    return [3 /*break*/, 3];
-                case 7: return [3 /*break*/, 10];
-                case 8:
-                    e_1_1 = _b.sent();
-                    e_1 = { error: e_1_1 };
-                    return [3 /*break*/, 10];
-                case 9:
-                    try {
-                        if (usernames_1_1 && !usernames_1_1.done && (_a = usernames_1.return)) _a.call(usernames_1);
-                    }
-                    finally { if (e_1) throw e_1.error; }
-                    return [7 /*endfinally*/];
-                case 10: return [3 /*break*/, 14];
-                case 11:
-                    if (!/who\'?s online/i.test(message.msg)) return [3 /*break*/, 14];
-                    return [4 /*yield*/, driver.users.onlineNames()];
-                case 12:
-                    names = _b.sent();
-                    niceNames = names.join(', ').replace(/, ([^,]*)$/, ' and $1');
-                    return [4 /*yield*/, driver.sendToRoomId(niceNames + ' are online', message.rid)];
-                case 13:
-                    _b.sent();
-                    _b.label = 14;
-                case 14: return [2 /*return*/];
-            }
-        });
-    });
-}
-start().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=start.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/start.js.map b/node_modules/@rocket.chat/sdk/utils/start.js.map
deleted file mode 100644
index 7768a79..0000000
--- a/node_modules/@rocket.chat/sdk/utils/start.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"start.js","sourceRoot":"","sources":["../../src/utils/start.ts"],"names":[],"mappings":"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","sourcesContent":["// Test script uses standard methods and env config to connect and log streams\nimport { botUser } from './config'\nimport { IMessage, ILogger } from '../interfaces'\nimport BotDriver from '../lib/clients/Bot'\n\nglobal.fetch = require('node-fetch')\n// Login settings - LDAP needs to be explicitly enabled\nexport let username = process.env.ROCKETCHAT_USER || 'g1'\nexport let password = process.env.ROCKETCHAT_PASSWORD || '1'\nexport let ldap = (process.env.ROCKETCHAT_AUTH === 'ldap')\n\n// Connection settings - Enable SSL by default if Rocket.Chat URL contains https\nexport let host = process.env.ROCKETCHAT_URL || 'http://localhost:3000'\nexport const useSsl = (process.env.ROCKETCHAT_USE_SSL && process.env.ROCKETCHAT_USE_SSL === 'true') || (host).toLowerCase().startsWith('https')\nexport let timeout = 20 * 1000 // 20 seconds\n\n// Respond settings - reactive callback filters for .respondToMessages\nexport let rooms = (process.env.ROCKETCHAT_ROOM)\n\t? (process.env.ROCKETCHAT_ROOM || '').split(',').map((room) => room.trim())\n\t: []\nexport let allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true'\nexport let dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true'\nexport let livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true'\nexport let edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true'\n\n// Message attribute settings\nexport let integrationId = process.env.INTEGRATION_ID || 'js.SDK'\n\n// Cache settings\nexport let roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10)\nexport let roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10)\nexport let dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10)\nexport let dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10)\n\n// Livechat settings\nexport let token = process.env.LIVECHAT_TOKEN || ''\nexport let rid = process.env.LIVECHAT_ROOM || ''\nexport let department = process.env.LIVECHAT_DEPARTMENT || ''\n\nconst delay = (ms: number) => new Promise((resolve, reject) => setTimeout(resolve, ms))\n\nclass L implements ILogger {\n  debug (...args: any[]) {\n    // console.log(...args)\n  }\n  info (...args: any[]) {\n    // console.log(...args)\n  }\n  warning (...args: any[]) {\n    // console.warn(...args)\n  }\n  warn (...args: any[]) { // legacy method\n    // return this.warning(...args)\n  }\n  error (...args: any[]) {\n    // console.error(...args)\n  }\n}\n\nconst driver = new BotDriver({ host, useSsl, timeout, logger: new L() } as any)\n// Start subscription to log message stream (used for e2e test and demo)\nasync function start () {\n  await driver.login({ username, password })\n  await driver.connect({})\n  // driver.subscribeNotifyAll()\n  // driver.subscribeLoggedNotify()\n  // driver.subscribeNotifyUser()\n\n  await driver.respondToMessages((err, msg, msgOpts) => {\n    if (err) throw err\n    console.log('[respond]', JSON.stringify(msg), JSON.stringify(msgOpts))\n    if (msg) demo(msg).catch((e) => console.error(e))\n  }, {\n    rooms: ['GENERAL'],\n    allPublic: false,\n    dm: true,\n    edited: true,\n    livechat: false\n  })\n}\n\n// Demo bot-style interactions\n// A: Listen for \"tell everyone <something>\" and send that something to everyone\n// B: Listen for \"who's online\" and tell that person who's online\nasync function demo (message: IMessage) {\n  if (!message.msg) return\n  if (/tell everyone/i.test(message.msg)) {\n    const match = message.msg.match(/tell everyone (.*)/i)\n    if (!match || !match[1]) return\n    // const sayWhat = `@${message.u!.username} says \"${match[1]}\"`\n\n    const usernames = await driver.users.allNames()\n    for (let username of usernames) {\n      if (username && username !== botUser.username) {\n\t\t\t\t// const toWhere =\n        await driver.getDirectMessageRoomId(username)\n        await delay(200) // delay to prevent rate-limit error\n      }\n    }\n  } else if (/who\\'?s online/i.test(message.msg)) {\n    const names = await driver.users.onlineNames()\n    const niceNames = names.join(', ').replace(/, ([^,]*)$/, ' and $1')\n    await driver.sendToRoomId(niceNames + ' are online', message.rid!)\n  }\n}\n\nstart().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/start.ts b/node_modules/@rocket.chat/sdk/utils/start.ts
new file mode 100644
index 0000000..0c0d356
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/start.ts
@@ -0,0 +1,107 @@
+// Test script uses standard methods and env config to connect and log streams
+import { botUser } from './config'
+import { IMessage, ILogger } from '../interfaces'
+import BotDriver from '../lib/clients/Bot'
+
+global.fetch = require('node-fetch')
+// Login settings - LDAP needs to be explicitly enabled
+export let username = process.env.ROCKETCHAT_USER || 'g1'
+export let password = process.env.ROCKETCHAT_PASSWORD || '1'
+export let ldap = (process.env.ROCKETCHAT_AUTH === 'ldap')
+
+// Connection settings - Enable SSL by default if Rocket.Chat URL contains https
+export let host = process.env.ROCKETCHAT_URL || 'http://localhost:3000'
+export const useSsl = (process.env.ROCKETCHAT_USE_SSL && process.env.ROCKETCHAT_USE_SSL === 'true') || (host).toLowerCase().startsWith('https')
+export let timeout = 20 * 1000 // 20 seconds
+
+// Respond settings - reactive callback filters for .respondToMessages
+export let rooms = (process.env.ROCKETCHAT_ROOM)
+	? (process.env.ROCKETCHAT_ROOM || '').split(',').map((room) => room.trim())
+	: []
+export let allPublic = (process.env.LISTEN_ON_ALL_PUBLIC || 'false').toLowerCase() === 'true'
+export let dm = (process.env.RESPOND_TO_DM || 'false').toLowerCase() === 'true'
+export let livechat = (process.env.RESPOND_TO_LIVECHAT || 'false').toLowerCase() === 'true'
+export let edited = (process.env.RESPOND_TO_EDITED || 'false').toLowerCase() === 'true'
+
+// Message attribute settings
+export let integrationId = process.env.INTEGRATION_ID || 'js.SDK'
+
+// Cache settings
+export let roomCacheMaxSize = parseInt(process.env.ROOM_CACHE_SIZE || '10', 10)
+export let roomCacheMaxAge = 1000 * parseInt(process.env.ROOM_CACHE_MAX_AGE || '300', 10)
+export let dmCacheMaxSize = parseInt(process.env.DM_ROOM_CACHE_SIZE || '10', 10)
+export let dmCacheMaxAge = 1000 * parseInt(process.env.DM_ROOM_CACHE_MAX_AGE || '100', 10)
+
+// Livechat settings
+export let token = process.env.LIVECHAT_TOKEN || ''
+export let rid = process.env.LIVECHAT_ROOM || ''
+export let department = process.env.LIVECHAT_DEPARTMENT || ''
+
+const delay = (ms: number) => new Promise((resolve, reject) => setTimeout(resolve, ms))
+
+class L implements ILogger {
+  debug (...args: any[]) {
+    // console.log(...args)
+  }
+  info (...args: any[]) {
+    // console.log(...args)
+  }
+  warning (...args: any[]) {
+    // console.warn(...args)
+  }
+  warn (...args: any[]) { // legacy method
+    // return this.warning(...args)
+  }
+  error (...args: any[]) {
+    // console.error(...args)
+  }
+}
+
+const driver = new BotDriver({ host, useSsl, timeout, logger: new L() } as any)
+// Start subscription to log message stream (used for e2e test and demo)
+async function start () {
+  await driver.login({ username, password })
+  await driver.connect({})
+  // driver.subscribeNotifyAll()
+  // driver.subscribeLoggedNotify()
+  // driver.subscribeNotifyUser()
+
+  await driver.respondToMessages((err, msg, msgOpts) => {
+    if (err) throw err
+    console.log('[respond]', JSON.stringify(msg), JSON.stringify(msgOpts))
+    if (msg) demo(msg).catch((e) => console.error(e))
+  }, {
+    rooms: ['GENERAL'],
+    allPublic: false,
+    dm: true,
+    edited: true,
+    livechat: false
+  })
+}
+
+// Demo bot-style interactions
+// A: Listen for "tell everyone <something>" and send that something to everyone
+// B: Listen for "who's online" and tell that person who's online
+async function demo (message: IMessage) {
+  if (!message.msg) return
+  if (/tell everyone/i.test(message.msg)) {
+    const match = message.msg.match(/tell everyone (.*)/i)
+    if (!match || !match[1]) return
+    // const sayWhat = `@${message.u!.username} says "${match[1]}"`
+
+    const usernames = await driver.users.allNames()
+    for (let username of usernames) {
+      if (username && username !== botUser.username) {
+				// const toWhere =
+        await driver.getDirectMessageRoomId(username)
+        await delay(200) // delay to prevent rate-limit error
+      }
+    }
+  } else if (/who\'?s online/i.test(message.msg)) {
+    const names = await driver.users.onlineNames()
+    const niceNames = names.join(', ').replace(/, ([^,]*)$/, ' and $1')
+    await driver.sendToRoomId(niceNames + ' are online', message.rid!)
+  }
+}
+
+start().catch((e) => console.error(e))
diff --git a/node_modules/@rocket.chat/sdk/utils/testing.d.ts b/node_modules/@rocket.chat/sdk/utils/testing.d.ts
deleted file mode 100644
index 0b781b4..0000000
--- a/node_modules/@rocket.chat/sdk/utils/testing.d.ts
+++ /dev/null
@@ -1,48 +0,0 @@
-import { IMessageUpdateAPI, IMessageResultAPI, INewUserAPI, IRoomResultAPI, IChannelResultAPI, IGroupResultAPI, IMessageReceipt, IUserAPI } from '../interfaces';
-/** Define common attributes for DRY tests */
-export declare const testChannelName = "tests";
-export declare const testPrivateName = "p-tests";
-/** Get information about a user */
-export declare function userInfo(username: string): Promise<IUserAPI>;
-/** Create a user and catch the error if they exist already */
-export declare function createUser(user: INewUserAPI): Promise<IUserAPI>;
-/** Get information about a channel */
-export declare function channelInfo(query: {
-    roomName?: string;
-    roomId?: string;
-}): Promise<IChannelResultAPI>;
-/** Get information about a private group */
-export declare function privateInfo(query: {
-    roomName?: string;
-    roomId?: string;
-}): Promise<IGroupResultAPI>;
-/** Get the last messages sent to a channel (in last 10 minutes) */
-export declare function lastMessages(roomId: string, count?: number): Promise<IMessageReceipt[]>;
-/** Create a room for tests and catch the error if it exists already */
-export declare function createChannel(name: string, members?: string[], readOnly?: boolean): Promise<IChannelResultAPI>;
-/** Create a private group / room and catch if exists already */
-export declare function createPrivate(name: string, members?: string[], readOnly?: boolean): Promise<any>;
-/** Send message from mock user to channel for tests to listen and respond */
-/** @todo Sometimes the post request completes before the change event emits
- *        the message to the streamer. That's why the interval is used for proof
- *        of receipt. It would be better for the endpoint to not resolve until
- *        server side handling is complete. Would require PR to core.
- */
-export declare function sendFromUser(payload: any): Promise<IMessageResultAPI>;
-/** Leave user from room, to generate `ul` message (test channel by default) */
-export declare function leaveUser(room?: {
-    id?: string;
-    name?: string;
-}): Promise<Boolean>;
-/** Invite user to room, to generate `au` message (test channel by default) */
-export declare function inviteUser(room?: {
-    id?: string;
-    name?: string;
-}): Promise<boolean>;
-/** @todo : Join user into room (enter) to generate `uj` message type. */
-/** Update message sent from mock user */
-export declare function updateFromUser(payload: IMessageUpdateAPI): Promise<IMessageResultAPI>;
-/** Create a direct message session with the mock user */
-export declare function setupDirectFromUser(): Promise<IRoomResultAPI>;
-/** Initialise testing instance with the required users for SDK/bot tests */
-export declare function setup(): Promise<void>;
diff --git a/node_modules/@rocket.chat/sdk/utils/testing.js b/node_modules/@rocket.chat/sdk/utils/testing.js
deleted file mode 100644
index cd86f9f..0000000
--- a/node_modules/@rocket.chat/sdk/utils/testing.js
+++ /dev/null
@@ -1,412 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-var api_1 = __importDefault(require("../lib/api/api"));
-var config_1 = require("./config");
-var api = new api_1.default({});
-/** Define common attributes for DRY tests */
-exports.testChannelName = 'tests';
-exports.testPrivateName = 'p-tests';
-/** Get information about a user */
-function userInfo(username) {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, api.get('users.info', { username: username }, true)];
-                case 1: return [2 /*return*/, _a.sent()];
-            }
-        });
-    });
-}
-exports.userInfo = userInfo;
-/** Create a user and catch the error if they exist already */
-function createUser(user) {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, api.post('users.create', user, true, /already in use/i)];
-                case 1: return [2 /*return*/, (_a.sent())];
-            }
-        });
-    });
-}
-exports.createUser = createUser;
-/** Get information about a channel */
-function channelInfo(query) {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            return [2 /*return*/, api.get('channels.info', query, true)];
-        });
-    });
-}
-exports.channelInfo = channelInfo;
-/** Get information about a private group */
-function privateInfo(query) {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            return [2 /*return*/, api.get('groups.info', query, true)];
-        });
-    });
-}
-exports.privateInfo = privateInfo;
-/** Get the last messages sent to a channel (in last 10 minutes) */
-function lastMessages(roomId, count) {
-    if (count === void 0) { count = 1; }
-    return __awaiter(this, void 0, void 0, function () {
-        var now, latest, oldest, history;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    now = new Date();
-                    latest = now.toISOString();
-                    oldest = new Date(now.setMinutes(now.getMinutes() - 10)).toISOString();
-                    return [4 /*yield*/, api.get('channels.history', { roomId: roomId, latest: latest, oldest: oldest, count: count })];
-                case 1:
-                    history = _a.sent();
-                    return [2 /*return*/, history.messages];
-            }
-        });
-    });
-}
-exports.lastMessages = lastMessages;
-/** Create a room for tests and catch the error if it exists already */
-function createChannel(name, members, readOnly) {
-    if (members === void 0) { members = []; }
-    if (readOnly === void 0) { readOnly = false; }
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, api.post('channels.create', { name: name, members: members, readOnly: readOnly }, true)];
-                case 1: return [2 /*return*/, _a.sent()];
-            }
-        });
-    });
-}
-exports.createChannel = createChannel;
-/** Create a private group / room and catch if exists already */
-function createPrivate(name, members, readOnly) {
-    if (members === void 0) { members = []; }
-    if (readOnly === void 0) { readOnly = false; }
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            return [2 /*return*/, (api.post('groups.create', { name: name, members: members, readOnly: readOnly }, true))];
-        });
-    });
-}
-exports.createPrivate = createPrivate;
-/** Send message from mock user to channel for tests to listen and respond */
-/** @todo Sometimes the post request completes before the change event emits
- *        the message to the streamer. That's why the interval is used for proof
- *        of receipt. It would be better for the endpoint to not resolve until
- *        server side handling is complete. Would require PR to core.
- */
-function sendFromUser(payload) {
-    return __awaiter(this, void 0, void 0, function () {
-        var user, endpoint, roomId, _a, messageDefaults, data, oldest, result, proof;
-        var _this = this;
-        return __generator(this, function (_b) {
-            switch (_b.label) {
-                case 0: return [4 /*yield*/, api.login({ username: config_1.mockUser.username, password: config_1.mockUser.password })];
-                case 1:
-                    user = _b.sent();
-                    endpoint = (payload.roomId && payload.roomId.indexOf(user.userId) !== -1)
-                        ? 'dm.history'
-                        : 'channels.history';
-                    if (!(payload.roomId)) return [3 /*break*/, 2];
-                    _a = payload.roomId;
-                    return [3 /*break*/, 4];
-                case 2: return [4 /*yield*/, channelInfo({ roomName: exports.testChannelName })];
-                case 3:
-                    _a = (_b.sent()).channel._id;
-                    _b.label = 4;
-                case 4:
-                    roomId = _a;
-                    messageDefaults = { roomId: roomId };
-                    data = Object.assign({}, messageDefaults, payload);
-                    oldest = new Date().toISOString();
-                    return [4 /*yield*/, api.post('chat.postMessage', data, true)];
-                case 5:
-                    result = _b.sent();
-                    proof = new Promise(function (resolve, reject) {
-                        var looked = 0;
-                        var look = setInterval(function () { return __awaiter(_this, void 0, void 0, function () {
-                            var messages, found;
-                            return __generator(this, function (_a) {
-                                switch (_a.label) {
-                                    case 0: return [4 /*yield*/, api.get(endpoint, { roomId: roomId, oldest: oldest })];
-                                    case 1:
-                                        messages = (_a.sent()).messages;
-                                        found = messages.some(function (message) {
-                                            return result.message._id === message._id;
-                                        });
-                                        if (found || looked > 10) {
-                                            clearInterval(look);
-                                            if (found)
-                                                resolve();
-                                            else
-                                                reject('API send from user, proof of receipt timeout');
-                                        }
-                                        looked++;
-                                        return [2 /*return*/];
-                                }
-                            });
-                        }); }, 100);
-                    });
-                    return [4 /*yield*/, proof];
-                case 6:
-                    _b.sent();
-                    return [2 /*return*/, result];
-            }
-        });
-    });
-}
-exports.sendFromUser = sendFromUser;
-/** Leave user from room, to generate `ul` message (test channel by default) */
-function leaveUser(room) {
-    if (room === void 0) { room = {}; }
-    return __awaiter(this, void 0, void 0, function () {
-        var roomId, _a;
-        return __generator(this, function (_b) {
-            switch (_b.label) {
-                case 0: return [4 /*yield*/, api.login({ username: config_1.mockUser.username, password: config_1.mockUser.password })];
-                case 1:
-                    _b.sent();
-                    if (!room.id && !room.name)
-                        room.name = exports.testChannelName;
-                    if (!(room.id)) return [3 /*break*/, 2];
-                    _a = room.id;
-                    return [3 /*break*/, 4];
-                case 2: return [4 /*yield*/, channelInfo({ roomName: room.name })];
-                case 3:
-                    _a = (_b.sent()).channel._id;
-                    _b.label = 4;
-                case 4:
-                    roomId = _a;
-                    return [4 /*yield*/, api.post('channels.leave', { roomId: roomId })];
-                case 5: return [2 /*return*/, _b.sent()];
-            }
-        });
-    });
-}
-exports.leaveUser = leaveUser;
-/** Invite user to room, to generate `au` message (test channel by default) */
-function inviteUser(room) {
-    if (room === void 0) { room = {}; }
-    return __awaiter(this, void 0, void 0, function () {
-        var mockInfo, roomId, _a;
-        return __generator(this, function (_b) {
-            switch (_b.label) {
-                case 0: return [4 /*yield*/, userInfo(config_1.mockUser.username)];
-                case 1:
-                    mockInfo = _b.sent();
-                    return [4 /*yield*/, api.login({ username: config_1.apiUser.username, password: config_1.apiUser.password })];
-                case 2:
-                    _b.sent();
-                    if (!room.id && !room.name)
-                        room.name = exports.testChannelName;
-                    if (!(room.id)) return [3 /*break*/, 3];
-                    _a = room.id;
-                    return [3 /*break*/, 5];
-                case 3: return [4 /*yield*/, channelInfo({ roomName: room.name })];
-                case 4:
-                    _a = (_b.sent()).channel._id;
-                    _b.label = 5;
-                case 5:
-                    roomId = _a;
-                    return [4 /*yield*/, api.post('channels.invite', { userId: mockInfo._id, roomId: roomId })];
-                case 6: return [2 /*return*/, _b.sent()];
-            }
-        });
-    });
-}
-exports.inviteUser = inviteUser;
-/** @todo : Join user into room (enter) to generate `uj` message type. */
-/** Update message sent from mock user */
-function updateFromUser(payload) {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, api.login({ username: config_1.mockUser.username, password: config_1.mockUser.password })];
-                case 1:
-                    _a.sent();
-                    return [4 /*yield*/, api.post('chat.update', payload, true)];
-                case 2: return [2 /*return*/, _a.sent()];
-            }
-        });
-    });
-}
-exports.updateFromUser = updateFromUser;
-/** Create a direct message session with the mock user */
-function setupDirectFromUser() {
-    return __awaiter(this, void 0, void 0, function () {
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0: return [4 /*yield*/, api.login({ username: config_1.mockUser.username, password: config_1.mockUser.password })];
-                case 1:
-                    _a.sent();
-                    return [4 /*yield*/, api.post('im.create', { username: config_1.botUser.username }, true)];
-                case 2: return [2 /*return*/, _a.sent()];
-            }
-        });
-    });
-}
-exports.setupDirectFromUser = setupDirectFromUser;
-/** Initialise testing instance with the required users for SDK/bot tests */
-function setup() {
-    return __awaiter(this, void 0, void 0, function () {
-        var error_1, botInfo, error_2, botInfo, mockInfo, error_3, mockInfo, e_1, error_4, testPrivateInfo;
-        return __generator(this, function (_a) {
-            switch (_a.label) {
-                case 0:
-                    console.log('\nPreparing instance for tests...');
-                    _a.label = 1;
-                case 1:
-                    _a.trys.push([1, 3, , 4]);
-                    // Verify API user can login
-                    return [4 /*yield*/, api.login({ password: config_1.apiUser.password, username: config_1.apiUser.username })];
-                case 2:
-                    // Verify API user can login
-                    _a.sent();
-                    console.log("API user (" + config_1.apiUser.username + ") logged in");
-                    return [3 /*break*/, 4];
-                case 3:
-                    error_1 = _a.sent();
-                    console.log(error_1, config_1.apiUser);
-                    throw new Error("API user (" + config_1.apiUser.username + ") could not login");
-                case 4:
-                    _a.trys.push([4, 6, , 8]);
-                    return [4 /*yield*/, userInfo(config_1.botUser.username)];
-                case 5:
-                    botInfo = _a.sent();
-                    console.log("API user (" + botInfo.username + ") exists");
-                    return [3 /*break*/, 8];
-                case 6:
-                    error_2 = _a.sent();
-                    console.log("Bot user (" + config_1.botUser.username + ") not found");
-                    return [4 /*yield*/, createUser(config_1.botUser)
-                        // if (!botInfo.success) {
-                        //   throw new Error(`Bot user (${botUser.username}) could not be created`)
-                        // }
-                    ];
-                case 7:
-                    botInfo = _a.sent();
-                    // if (!botInfo.success) {
-                    //   throw new Error(`Bot user (${botUser.username}) could not be created`)
-                    // }
-                    console.log("Bot user (" + botInfo.username + ") created");
-                    return [3 /*break*/, 8];
-                case 8:
-                    _a.trys.push([8, 10, , 12]);
-                    return [4 /*yield*/, userInfo(config_1.mockUser.username)];
-                case 9:
-                    mockInfo = _a.sent();
-                    console.log("Mock user (" + mockInfo.username + ") exists");
-                    return [3 /*break*/, 12];
-                case 10:
-                    error_3 = _a.sent();
-                    console.log("Mock user (" + config_1.mockUser.username + ") not found");
-                    return [4 /*yield*/, createUser(config_1.mockUser)
-                        // if (!mockInfo || mockInfo.success) {
-                        //   throw new Error(`Mock user (${mockUser.username}) could not be created`)
-                        // }
-                    ];
-                case 11:
-                    mockInfo = _a.sent();
-                    // if (!mockInfo || mockInfo.success) {
-                    //   throw new Error(`Mock user (${mockUser.username}) could not be created`)
-                    // }
-                    console.log("Mock user (" + mockInfo.username + ") created");
-                    return [3 /*break*/, 12];
-                case 12:
-                    _a.trys.push([12, 14, , 16]);
-                    // Verify or create user for bot
-                    // Verify or create channel for tests
-                    return [4 /*yield*/, channelInfo({ roomName: exports.testChannelName })];
-                case 13:
-                    // Verify or create user for bot
-                    // Verify or create channel for tests
-                    _a.sent();
-                    console.log("Test channel (" + exports.testChannelName + ") exists");
-                    return [3 /*break*/, 16];
-                case 14:
-                    e_1 = _a.sent();
-                    console.log("Test channel (" + exports.testChannelName + ") not found");
-                    return [4 /*yield*/, createChannel(exports.testChannelName, [
-                            config_1.apiUser.username, config_1.botUser.username, config_1.mockUser.username
-                        ])
-                        // if (!testChannelInfo.success) {
-                        //   throw new Error(`Test channel (${testChannelName}) could not be created`)
-                        // }
-                    ];
-                case 15:
-                    _a.sent();
-                    // if (!testChannelInfo.success) {
-                    //   throw new Error(`Test channel (${testChannelName}) could not be created`)
-                    // }
-                    console.log("Test channel (" + exports.testChannelName + ") created");
-                    return [3 /*break*/, 16];
-                case 16:
-                    _a.trys.push([16, 18, , 20]);
-                    // Verify or create private room for tests
-                    return [4 /*yield*/, privateInfo({ roomName: exports.testPrivateName })];
-                case 17:
-                    // Verify or create private room for tests
-                    _a.sent();
-                    console.log("Test private room (" + exports.testPrivateName + ") exists");
-                    return [3 /*break*/, 20];
-                case 18:
-                    error_4 = _a.sent();
-                    return [4 /*yield*/, createPrivate(exports.testPrivateName, [
-                            config_1.apiUser.username, config_1.botUser.username, config_1.mockUser.username
-                        ])];
-                case 19:
-                    testPrivateInfo = _a.sent();
-                    console.log("Test private room (" + testPrivateInfo.name + ") created");
-                    return [3 /*break*/, 20];
-                case 20: return [4 /*yield*/, api.logout()];
-                case 21:
-                    _a.sent();
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-exports.setup = setup;
-//# sourceMappingURL=testing.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/testing.js.map b/node_modules/@rocket.chat/sdk/utils/testing.js.map
deleted file mode 100644
index 36abe0b..0000000
--- a/node_modules/@rocket.chat/sdk/utils/testing.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"testing.js","sourceRoot":"","sources":["../../src/utils/testing.ts"],"names":[],"mappings":"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","sourcesContent":["import ApiBase from '../lib/api/api'\nimport { apiUser, botUser, mockUser } from './config'\nimport {\n  IMessageAPI,\n  IMessageUpdateAPI,\n  IMessageResultAPI,\n  INewUserAPI,\n  IRoomResultAPI,\n  IChannelResultAPI,\n  IGroupResultAPI,\n  IHistoryAPI,\n  IMessageReceipt,\n\tIUserAPI\n} from '../interfaces'\n\nconst api = new ApiBase({})\n\n/** Define common attributes for DRY tests */\nexport const testChannelName = 'tests'\nexport const testPrivateName = 'p-tests'\n\n/** Get information about a user */\nexport async function userInfo (username: string) {\n  return (await api.get('users.info', { username }, true) as IUserAPI)\n}\n\n/** Create a user and catch the error if they exist already */\nexport async function createUser (user: INewUserAPI) {\n  return (await api.post('users.create', user, true, /already in use/i)) as IUserAPI\n}\n\n/** Get information about a channel */\nexport async function channelInfo (query: { roomName?: string, roomId?: string }) {\n  return api.get('channels.info', query, true) as Promise<IChannelResultAPI>\n}\n\n/** Get information about a private group */\nexport async function privateInfo (query: { roomName?: string, roomId?: string }) {\n  return api.get('groups.info', query, true) as Promise<IGroupResultAPI>\n}\n\n/** Get the last messages sent to a channel (in last 10 minutes) */\nexport async function lastMessages (roomId: string, count: number = 1) {\n  const now = new Date()\n  const latest = now.toISOString()\n  const oldest = new Date(now.setMinutes(now.getMinutes() - 10)).toISOString()\n  const history = (await api.get('channels.history', { roomId, latest, oldest, count }) as IHistoryAPI)\n  return history.messages\n}\n\n/** Create a room for tests and catch the error if it exists already */\nexport async function createChannel (\n  name: string,\n  members: string[] = [],\n  readOnly: boolean = false\n) {\n  return (await api.post('channels.create', { name, members, readOnly }, true) as IChannelResultAPI)\n}\n\n/** Create a private group / room and catch if exists already */\nexport async function createPrivate (\n  name: string,\n  members: string[] = [],\n  readOnly: boolean = false\n) {\n  return (api.post('groups.create', { name, members, readOnly }, true))\n}\n\n/** Send message from mock user to channel for tests to listen and respond */\n/** @todo Sometimes the post request completes before the change event emits\n *        the message to the streamer. That's why the interval is used for proof\n *        of receipt. It would be better for the endpoint to not resolve until\n *        server side handling is complete. Would require PR to core.\n */\nexport async function sendFromUser (payload: any): Promise<IMessageResultAPI> {\n  const user = await api.login({ username: mockUser.username, password: mockUser.password })\n  const endpoint = (payload.roomId && payload.roomId.indexOf(user.userId) !== -1)\n    ? 'dm.history'\n    : 'channels.history'\n  const roomId = (payload.roomId)\n    ? payload.roomId\n    : (await channelInfo({ roomName: testChannelName })).channel._id\n  const messageDefaults: IMessageAPI = { roomId }\n  const data: IMessageAPI = Object.assign({}, messageDefaults, payload)\n  const oldest = new Date().toISOString()\n  const result = (await api.post('chat.postMessage', data, true) as IMessageResultAPI)\n  const proof = new Promise((resolve, reject) => {\n    let looked = 0\n    const look = setInterval(async () => {\n      const { messages } = (await api.get(endpoint, { roomId, oldest }) as IHistoryAPI)\n      const found = messages.some((message: IMessageReceipt) => {\n        return result.message._id === message._id\n      })\n      if (found || looked > 10) {\n        clearInterval(look)\n        if (found) resolve()\n        else reject('API send from user, proof of receipt timeout')\n      }\n      looked++\n    }, 100)\n  })\n  await proof\n  return result\n}\n\n/** Leave user from room, to generate `ul` message (test channel by default) */\nexport async function leaveUser (room: { id?: string, name?: string } = {}) {\n  await api.login({ username: mockUser.username, password: mockUser.password })\n  if (!room.id && !room.name) room.name = testChannelName\n  const roomId = (room.id)\n    ? room.id\n    : (await channelInfo({ roomName: room.name })).channel._id\n  return (await api.post('channels.leave', { roomId }) as Boolean)\n}\n\n/** Invite user to room, to generate `au` message (test channel by default) */\nexport async function inviteUser (room: { id?: string, name?: string } = {}) {\n  let mockInfo = await userInfo(mockUser.username)\n  await api.login({ username: apiUser.username, password: apiUser.password })\n  if (!room.id && !room.name) room.name = testChannelName\n  const roomId = (room.id)\n    ? room.id\n    : (await channelInfo({ roomName: room.name })).channel._id\n  return (await api.post('channels.invite', { userId: mockInfo._id, roomId }) as boolean)\n}\n\n/** @todo : Join user into room (enter) to generate `uj` message type. */\n\n/** Update message sent from mock user */\nexport async function updateFromUser (payload: IMessageUpdateAPI) {\n  await api.login({ username: mockUser.username, password: mockUser.password })\n  return (await api.post('chat.update', payload, true) as IMessageResultAPI)\n}\n\n/** Create a direct message session with the mock user */\nexport async function setupDirectFromUser () {\n  await api.login({ username: mockUser.username, password: mockUser.password })\n  return (await api.post('im.create', { username: botUser.username }, true) as IRoomResultAPI)\n}\n\n/** Initialise testing instance with the required users for SDK/bot tests */\nexport async function setup () {\n  console.log('\\nPreparing instance for tests...')\n  try {\n\t\t// Verify API user can login\n    await api.login({ password: apiUser.password, username: apiUser.username })\n    console.log(`API user (${apiUser.username}) logged in`)\n  } catch (error) {\n    console.log(error, apiUser)\n    throw new Error(`API user (${apiUser.username}) could not login`)\n  }\n\n  try {\n    const botInfo = await userInfo(botUser.username)\n    console.log(`API user (${botInfo.username}) exists`)\n  } catch (error) {\n    console.log(`Bot user (${botUser.username}) not found`)\n    const botInfo = await createUser(botUser)\n    // if (!botInfo.success) {\n    //   throw new Error(`Bot user (${botUser.username}) could not be created`)\n    // }\n    console.log(`Bot user (${botInfo.username}) created`)\n  }\n  try {\n\t\t// Verify or create mock user for talking to bot\n    let mockInfo = await userInfo(mockUser.username)\n    console.log(`Mock user (${mockInfo.username}) exists`)\n  } catch (error) {\n    console.log(`Mock user (${mockUser.username}) not found`)\n    const mockInfo = await createUser(mockUser)\n    // if (!mockInfo || mockInfo.success) {\n    //   throw new Error(`Mock user (${mockUser.username}) could not be created`)\n    // }\n    console.log(`Mock user (${mockInfo.username}) created`)\n  }\n  try {\n\t\t// Verify or create user for bot\n    // Verify or create channel for tests\n    await channelInfo({ roomName: testChannelName })\n    console.log(`Test channel (${testChannelName}) exists`)\n  } catch (e) {\n    console.log(`Test channel (${testChannelName}) not found`)\n    await createChannel(testChannelName, [\n      apiUser.username, botUser.username, mockUser.username\n    ])\n    // if (!testChannelInfo.success) {\n    //   throw new Error(`Test channel (${testChannelName}) could not be created`)\n    // }\n    console.log(`Test channel (${testChannelName}) created`)\n  }\n  try {\n    // Verify or create private room for tests\n    await privateInfo({ roomName: testPrivateName })\n    console.log(`Test private room (${testPrivateName}) exists`)\n  } catch (error) {\n    const testPrivateInfo = await createPrivate(testPrivateName, [\n      apiUser.username, botUser.username, mockUser.username\n    ])\n    console.log(`Test private room (${testPrivateInfo.name}) created`)\n  }\n  await api.logout()\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/testing.ts b/node_modules/@rocket.chat/sdk/utils/testing.ts
new file mode 100644
index 0000000..8737a0b
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/testing.ts
@@ -0,0 +1,202 @@
+import ApiBase from '../lib/api/api'
+import { apiUser, botUser, mockUser } from './config'
+import {
+  IMessageAPI,
+  IMessageUpdateAPI,
+  IMessageResultAPI,
+  INewUserAPI,
+  IRoomResultAPI,
+  IChannelResultAPI,
+  IGroupResultAPI,
+  IHistoryAPI,
+  IMessageReceipt,
+	IUserAPI
+} from '../interfaces'
+
+const api = new ApiBase({})
+
+/** Define common attributes for DRY tests */
+export const testChannelName = 'tests'
+export const testPrivateName = 'p-tests'
+
+/** Get information about a user */
+export async function userInfo (username: string) {
+  return (await api.get('users.info', { username }, true) as IUserAPI)
+}
+
+/** Create a user and catch the error if they exist already */
+export async function createUser (user: INewUserAPI) {
+  return (await api.post('users.create', user, true, /already in use/i)) as IUserAPI
+}
+
+/** Get information about a channel */
+export async function channelInfo (query: { roomName?: string, roomId?: string }) {
+  return api.get('channels.info', query, true) as Promise<IChannelResultAPI>
+}
+
+/** Get information about a private group */
+export async function privateInfo (query: { roomName?: string, roomId?: string }) {
+  return api.get('groups.info', query, true) as Promise<IGroupResultAPI>
+}
+
+/** Get the last messages sent to a channel (in last 10 minutes) */
+export async function lastMessages (roomId: string, count: number = 1) {
+  const now = new Date()
+  const latest = now.toISOString()
+  const oldest = new Date(now.setMinutes(now.getMinutes() - 10)).toISOString()
+  const history = (await api.get('channels.history', { roomId, latest, oldest, count }) as IHistoryAPI)
+  return history.messages
+}
+
+/** Create a room for tests and catch the error if it exists already */
+export async function createChannel (
+  name: string,
+  members: string[] = [],
+  readOnly: boolean = false
+) {
+  return (await api.post('channels.create', { name, members, readOnly }, true) as IChannelResultAPI)
+}
+
+/** Create a private group / room and catch if exists already */
+export async function createPrivate (
+  name: string,
+  members: string[] = [],
+  readOnly: boolean = false
+) {
+  return (api.post('groups.create', { name, members, readOnly }, true))
+}
+
+/** Send message from mock user to channel for tests to listen and respond */
+/** @todo Sometimes the post request completes before the change event emits
+ *        the message to the streamer. That's why the interval is used for proof
+ *        of receipt. It would be better for the endpoint to not resolve until
+ *        server side handling is complete. Would require PR to core.
+ */
+export async function sendFromUser (payload: any): Promise<IMessageResultAPI> {
+  const user = await api.login({ username: mockUser.username, password: mockUser.password })
+  const endpoint = (payload.roomId && payload.roomId.indexOf(user.userId) !== -1)
+    ? 'dm.history'
+    : 'channels.history'
+  const roomId = (payload.roomId)
+    ? payload.roomId
+    : (await channelInfo({ roomName: testChannelName })).channel._id
+  const messageDefaults: IMessageAPI = { roomId }
+  const data: IMessageAPI = Object.assign({}, messageDefaults, payload)
+  const oldest = new Date().toISOString()
+  const result = (await api.post('chat.postMessage', data, true) as IMessageResultAPI)
+  const proof = new Promise((resolve, reject) => {
+    let looked = 0
+    const look = setInterval(async () => {
+      const { messages } = (await api.get(endpoint, { roomId, oldest }) as IHistoryAPI)
+      const found = messages.some((message: IMessageReceipt) => {
+        return result.message._id === message._id
+      })
+      if (found || looked > 10) {
+        clearInterval(look)
+        if (found) resolve()
+        else reject('API send from user, proof of receipt timeout')
+      }
+      looked++
+    }, 100)
+  })
+  await proof
+  return result
+}
+
+/** Leave user from room, to generate `ul` message (test channel by default) */
+export async function leaveUser (room: { id?: string, name?: string } = {}) {
+  await api.login({ username: mockUser.username, password: mockUser.password })
+  if (!room.id && !room.name) room.name = testChannelName
+  const roomId = (room.id)
+    ? room.id
+    : (await channelInfo({ roomName: room.name })).channel._id
+  return (await api.post('channels.leave', { roomId }) as Boolean)
+}
+
+/** Invite user to room, to generate `au` message (test channel by default) */
+export async function inviteUser (room: { id?: string, name?: string } = {}) {
+  let mockInfo = await userInfo(mockUser.username)
+  await api.login({ username: apiUser.username, password: apiUser.password })
+  if (!room.id && !room.name) room.name = testChannelName
+  const roomId = (room.id)
+    ? room.id
+    : (await channelInfo({ roomName: room.name })).channel._id
+  return (await api.post('channels.invite', { userId: mockInfo._id, roomId }) as boolean)
+}
+
+/** @todo : Join user into room (enter) to generate `uj` message type. */
+
+/** Update message sent from mock user */
+export async function updateFromUser (payload: IMessageUpdateAPI) {
+  await api.login({ username: mockUser.username, password: mockUser.password })
+  return (await api.post('chat.update', payload, true) as IMessageResultAPI)
+}
+
+/** Create a direct message session with the mock user */
+export async function setupDirectFromUser () {
+  await api.login({ username: mockUser.username, password: mockUser.password })
+  return (await api.post('im.create', { username: botUser.username }, true) as IRoomResultAPI)
+}
+
+/** Initialise testing instance with the required users for SDK/bot tests */
+export async function setup () {
+  console.log('\nPreparing instance for tests...')
+  try {
+		// Verify API user can login
+    await api.login({ password: apiUser.password, username: apiUser.username })
+    console.log(`API user (${apiUser.username}) logged in`)
+  } catch (error) {
+    console.log(error, apiUser)
+    throw new Error(`API user (${apiUser.username}) could not login`)
+  }
+
+  try {
+    const botInfo = await userInfo(botUser.username)
+    console.log(`API user (${botInfo.username}) exists`)
+  } catch (error) {
+    console.log(`Bot user (${botUser.username}) not found`)
+    const botInfo = await createUser(botUser)
+    // if (!botInfo.success) {
+    //   throw new Error(`Bot user (${botUser.username}) could not be created`)
+    // }
+    console.log(`Bot user (${botInfo.username}) created`)
+  }
+  try {
+		// Verify or create mock user for talking to bot
+    let mockInfo = await userInfo(mockUser.username)
+    console.log(`Mock user (${mockInfo.username}) exists`)
+  } catch (error) {
+    console.log(`Mock user (${mockUser.username}) not found`)
+    const mockInfo = await createUser(mockUser)
+    // if (!mockInfo || mockInfo.success) {
+    //   throw new Error(`Mock user (${mockUser.username}) could not be created`)
+    // }
+    console.log(`Mock user (${mockInfo.username}) created`)
+  }
+  try {
+		// Verify or create user for bot
+    // Verify or create channel for tests
+    await channelInfo({ roomName: testChannelName })
+    console.log(`Test channel (${testChannelName}) exists`)
+  } catch (e) {
+    console.log(`Test channel (${testChannelName}) not found`)
+    await createChannel(testChannelName, [
+      apiUser.username, botUser.username, mockUser.username
+    ])
+    // if (!testChannelInfo.success) {
+    //   throw new Error(`Test channel (${testChannelName}) could not be created`)
+    // }
+    console.log(`Test channel (${testChannelName}) created`)
+  }
+  try {
+    // Verify or create private room for tests
+    await privateInfo({ roomName: testPrivateName })
+    console.log(`Test private room (${testPrivateName}) exists`)
+  } catch (error) {
+    const testPrivateInfo = await createPrivate(testPrivateName, [
+      apiUser.username, botUser.username, mockUser.username
+    ])
+    console.log(`Test private room (${testPrivateInfo.name}) created`)
+  }
+  await api.logout()
+}
diff --git a/node_modules/@rocket.chat/sdk/utils/users.d.ts b/node_modules/@rocket.chat/sdk/utils/users.d.ts
deleted file mode 100644
index cb0ff5c..0000000
--- a/node_modules/@rocket.chat/sdk/utils/users.d.ts
+++ /dev/null
@@ -1 +0,0 @@
-export {};
diff --git a/node_modules/@rocket.chat/sdk/utils/users.js b/node_modules/@rocket.chat/sdk/utils/users.js
deleted file mode 100644
index 0fb269e..0000000
--- a/node_modules/@rocket.chat/sdk/utils/users.js
+++ /dev/null
@@ -1,84 +0,0 @@
-"use strict";
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-// Test script uses standard methods and env config to connect and log streams
-var RocketChat_1 = __importDefault(require("../lib/api/RocketChat"));
-var log_1 = require("../lib/log");
-log_1.silence();
-var api = new RocketChat_1.default({});
-function users() {
-    return __awaiter(this, void 0, void 0, function () {
-        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
-        return __generator(this, function (_w) {
-            switch (_w.label) {
-                case 0:
-                    _b = (_a = console).log;
-                    _c = "\n\n\t\t\tDemo of API user query helpers\n\n\t\t\tALL users `api.users.all()`:\n\t\t\t";
-                    _e = (_d = JSON).stringify;
-                    return [4 /*yield*/, api.users.all()];
-                case 1:
-                    _f = _c + _e.apply(_d, [_w.sent(), null, '\t']) + "\n\n\t\t\tALL usernames `api.users.allNames()`:\n\t\t\t";
-                    _h = (_g = JSON).stringify;
-                    return [4 /*yield*/, api.users.allNames()];
-                case 2:
-                    _j = _f + _h.apply(_g, [_w.sent(), null, '\t']) + "\n\n\t\t\tALL IDs `api.users.allIDs()`:\n\t\t\t";
-                    _l = (_k = JSON).stringify;
-                    return [4 /*yield*/, api.users.allIDs()];
-                case 3:
-                    _m = _j + _l.apply(_k, [_w.sent(), null, '\t']) + "\n\n\t\t\tONLINE users `api.users.online()`:\n\t\t\t";
-                    _p = (_o = JSON).stringify;
-                    return [4 /*yield*/, api.users.online()];
-                case 4:
-                    _q = _m + _p.apply(_o, [_w.sent(), null, '\t']) + "\n\n\t\t\tONLINE usernames `api.users.onlineNames()`:\n\t\t\t";
-                    _s = (_r = JSON).stringify;
-                    return [4 /*yield*/, api.users.onlineNames()];
-                case 5:
-                    _t = _q + _s.apply(_r, [_w.sent(), null, '\t']) + "\n\n\t\t\tONLINE IDs `api.users.onlineIds()`:\n\t\t\t";
-                    _v = (_u = JSON).stringify;
-                    return [4 /*yield*/, api.users.onlineIds()];
-                case 6:
-                    _b.apply(_a, [_t + _v.apply(_u, [_w.sent(), null, '\t']) + "\n\n  "]);
-                    return [2 /*return*/];
-            }
-        });
-    });
-}
-users().catch(function (e) { return console.error(e); });
-//# sourceMappingURL=users.js.map
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/users.js.map b/node_modules/@rocket.chat/sdk/utils/users.js.map
deleted file mode 100644
index 4f30273..0000000
--- a/node_modules/@rocket.chat/sdk/utils/users.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"users.js","sourceRoot":"","sources":["../../src/utils/users.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8EAA8E;AAC9E,qEAA8C;AAC9C,kCAAoC;AACpC,aAAO,EAAE,CAAA;AAET,IAAM,GAAG,GAAG,IAAI,oBAAU,CAAC,EAAE,CAAC,CAAA;AAC9B,SAAe,KAAK;;;;;;oBAClB,KAAA,CAAA,KAAA,OAAO,CAAA,CAAC,GAAG,CAAA;;oBAKR,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,EAAA;;8BAApC,cAAe,SAAqB,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGjD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAA;;8BAAzC,cAAe,SAA0B,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGtD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,EAAA;;8BAAvC,cAAe,SAAwB,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGpD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,EAAA;;8BAAvC,cAAe,SAAwB,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGpD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,WAAW,EAAE,EAAA;;8BAA5C,cAAe,SAA6B,EAAE,IAAI,EAAE,IAAI,EAAC;oBAGzD,KAAA,CAAA,KAAA,IAAI,CAAA,CAAC,SAAS,CAAA;oBAAC,qBAAM,GAAG,CAAC,KAAK,CAAC,SAAS,EAAE,EAAA;;oBApB7C,cAAY,KAoBT,cAAe,SAA2B,EAAE,IAAI,EAAE,IAAI,EAAC,WAEzD,EAAC,CAAA;;;;;CACH;AAED,KAAK,EAAE,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAhB,CAAgB,CAAC,CAAA","sourcesContent":["// Test script uses standard methods and env config to connect and log streams\nimport ClientRest from '../lib/api/RocketChat'\nimport { silence } from '../lib/log'\nsilence()\n\nconst api = new ClientRest({})\nasync function users () {\n  console.log(`\n\n\t\t\tDemo of API user query helpers\n\n\t\t\tALL users \\`api.users.all()\\`:\n\t\t\t${JSON.stringify(await api.users.all(), null, '\\t')}\n\n\t\t\tALL usernames \\`api.users.allNames()\\`:\n\t\t\t${JSON.stringify(await api.users.allNames(), null, '\\t')}\n\n\t\t\tALL IDs \\`api.users.allIDs()\\`:\n\t\t\t${JSON.stringify(await api.users.allIDs(), null, '\\t')}\n\n\t\t\tONLINE users \\`api.users.online()\\`:\n\t\t\t${JSON.stringify(await api.users.online(), null, '\\t')}\n\n\t\t\tONLINE usernames \\`api.users.onlineNames()\\`:\n\t\t\t${JSON.stringify(await api.users.onlineNames(), null, '\\t')}\n\n\t\t\tONLINE IDs \\`api.users.onlineIds()\\`:\n\t\t\t${JSON.stringify(await api.users.onlineIds(), null, '\\t')}\n\n  `)\n}\n\nusers().catch((e) => console.error(e))\n"]}
\ No newline at end of file
diff --git a/node_modules/@rocket.chat/sdk/utils/users.ts b/node_modules/@rocket.chat/sdk/utils/users.ts
new file mode 100644
index 0000000..9e6594d
--- /dev/null
+++ b/node_modules/@rocket.chat/sdk/utils/users.ts
@@ -0,0 +1,33 @@
+// Test script uses standard methods and env config to connect and log streams
+import ClientRest from '../lib/api/RocketChat'
+import { silence } from '../lib/log'
+silence()
+
+const api = new ClientRest({})
+async function users () {
+  console.log(`
+
+			Demo of API user query helpers
+
+			ALL users \`api.users.all()\`:
+			${JSON.stringify(await api.users.all(), null, '\t')}
+
+			ALL usernames \`api.users.allNames()\`:
+			${JSON.stringify(await api.users.allNames(), null, '\t')}
+
+			ALL IDs \`api.users.allIDs()\`:
+			${JSON.stringify(await api.users.allIDs(), null, '\t')}
+
+			ONLINE users \`api.users.online()\`:
+			${JSON.stringify(await api.users.online(), null, '\t')}
+
+			ONLINE usernames \`api.users.onlineNames()\`:
+			${JSON.stringify(await api.users.onlineNames(), null, '\t')}
+
+			ONLINE IDs \`api.users.onlineIds()\`:
+			${JSON.stringify(await api.users.onlineIds(), null, '\t')}
+
+  `)
+}
+
+users().catch((e) => console.error(e))
